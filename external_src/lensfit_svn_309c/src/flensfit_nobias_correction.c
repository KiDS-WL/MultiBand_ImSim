/*-----------------------------------------------------------------------------------

lensfit

History:
Lance Miller with Thomas Kitching
version 1.  April 2002, LM
version 2.  14th November 2003, LM
version 7.  modified January 2007, TDK/LM
version 11. modified June 2007, TDK/LM
general release version.  Lance Miller, Tom Kitching, January 2008.
    error in call to fftw plan, fixed, LM, 24 Jan 2008
    added check of prior normalisation to derivative, LM/TDK, 11 Feb 2008
    added option of reading chip PA, TDK, 27 Feb 2008
    modified to use shapelet PSF, LM/LVW 2 Mar 2008
    ability to read multiple input images enabled, LM 16/03/2008
    modified from shapelet to directly-fitted PSF, LM, 14/5/2008
v3 improved galaxy-size searching and adaptive-grid ellipticity searching, LM, 19/6/2008
    modified to allow the analysis postage stamp to have a different size from the PSF
    LM, June 2008
   modified to swap around order of acoeffs elements, thus allowing use of function
    reconstruct  LM, July 2008
   includes measurement of PSF ellipticity, output to lensfit table, LM July 2008

tlensfit - multi-threaded version  LM Sep 2008
simulations added Sep 16-18 2008, LM
error in image stacking corrected, LM 26 Sep 2008
modified to allow WCS catalogue reads, LM 27 Sep 2008
modified to output noise-per-pixel to lensfit table, LM Oct 2008
modified to read/create joint ellipticity-size prior, in bins of magnitude, LM Oct-Nov 08
modified to read latest joint prior, LM 28 Nov 2008
corrected memory leak caused by repeated calls to FFTW routine fftw_plan_dft_r2c_2d, LM 5 Dec 2008
fixed bugs that caused failure when first input image has been disqualified, LM 10/12/08
fixed non thread-safe routine dsvdcmp.c (thanks to Joerg Dietrich) LM 18/12/08
fixed memory allocation for varylpthresholdf arrays, also now require SATLEV to be set LM 18/12/08
fixed error in selection of galaxies used to calculate astrometric shifts LM 6/1/2009
Major change: included swarp distortion correction LM 16/1/2009
Major change: modified to allow global PSF files for a mosaic camera like Megacam, LM 23/1/2009
Major change: v5p2 initial data input and preparation now handled by multiple threads, LM 27/1/2009
Various fixes related to new threads code, especially stack size management, bug fix,
  also testing of valid PSF and reporting of numbers of disqualified postage stamps, LM 6/2/09
Created option of having a continuous prior, being a linear function of magnitude, LM 13/2/09
Major restructuring, v5p3 code created to monitor and change memory use, according to size
  of dataset and memory available - should now be able to run on very large datasets
  provided there is some minimum memory available, LM 20-25/2/09
v5p4 code has reduced memory requirements by more careful definition of array types and
  sizes, LM 25/2/09-3/3/09
v5p4p2 uses improved prior function, LM March 2009
v5p4p3 fixes error in memory allocation when number of images < number of threads LM 23/04/09
v5p4p4 includes stricter criteria on acceptability of the PSF  LM 11/06/09
v5p4p5 has larger astrometric shift smoothing length and larger crosscorr array size LM.
also fixed thread-safe routines dpythag and icorrect declaration of mval variable,
thanks to Joerg Dietrich
v5p4p6 improved filename management, includes attempt to read imageID from header, also 
skips over images with short exposure times (<120 sec),  LM 5 Oct 2009

v5p5  reads in improved registration shifts from psfcoeffs files generated by globalshifts, 
and applies those shifts to the PSF (also corrects for centroid shift of the PSF).  
new function psfellipticitycentroid. LM 5 Nov 2009.
Improved likelihood calculation at low S/N, uses gsl library.  LM 9 Nov 2009.
Improved sampling of ellipticity plane when adapative sampling.  LM 9 Nov 2009.
Fix problem with sensitivity estimates which were previously too high for faint galaxies.  LM 12 Nov 2009.
Fixed problem with makediskbulgemodel - new routine makediskbulgemodelsm.  LM 20 Nov 2009.
Added option of writing out a FITS cube of model FFTs.  LM 20 Nov 2009.
Improved star classification (although has hard-wired magnitude dependence, not ideal). LM 20 Nov 2009.
Fixed numerous problems with faint object measurement, esp. removal of negative amplitude fits,
  searching for objects on stacked data, defining background objects from smoothed stacked data,
  re-estimation of background on each postage stamp with iterative rejection of objects
  new routine detectobjects.  LM 20 Nov - 6 Dec 2009.
Introduced output of marginalised galaxy scalelength instead of best-fitting.  
  NB this means the old version of readlensfits will not work on these files LM 13 Dec 2009
Improved model routine makediskbulgecoremodel, now part of this code.  LM 14 Dec 2009
Added improved testing of goodness-of-fit.  The best-fitting model is remade, and chi-squared
  evaluated only using the region where the model is significantly above zero surface brightness.  LM 28-31 Dec 2009.
Corrected chi-squared calculation in the above.  Also added calculation of numbers of bad fits in
  each individual image ("chip") and measurement of mean PSF-galaxy cross-correlation in each image. LM 1-2 Jan 2010
Allowed VERBOSE switch to turn off excessive output LM 4--Jan-2010
Allowed separate specification of distortion-correction and swarp astrometry. LM 5-Jan-2010
Included S/N calculation into detectobject, this is now reported instead of noiseperpixel LM 13/1/10

v5p6p3revb  
reinstatement of v5p6p3 from 13/1/2010 but with speed-up and marginalisation improvements:
a) better samping strategy to avoid measurement far from likelihood peak
b) improved numerical marginalisation over scalelength, but fitting cubic splines to log(posterior)
v. scalelength and then integrating the spline-fit (exponentiated) using GSL routines
Also modified slightly the sampling in scalelength.
This version still uses the v5p6 prior definition and sensitivity calculation
LM 20 Feb 2010

v5p6p3b code reformatted and bug correction by Joerg Dietrich
Upgraded code ported to SVN repository, 5th August 2010, 

re-aligned with version v5.6.4:
 fixed array size declaration in detectobject LM April 2010
 v5p6p4 minor changes to handling of single-image input, and added optional bright magnitude
 limit onto command-line.  LM 12 May 2010.

made camera definitions more self-consistent using the #define CFHT flags etc.  LM 9 Aug 2010

v5.6.5 improvements to reduce systematics measured by PSF-galaxy cross-correlation:
i) dilate weight mask to reduce problems of inaccurate masks
ii) remove background subtraction from swarpextract (this is now done in detectobject)
iii) remove cosmic-ray filter (actually this was previously correcting for the above
problems and is now neither necessary nor beneficial)
iv) remove filtering out of bad fits (this was introducing a PSF-galaxy correlation because
bad fits were preferentially aligned with the PSF)
v) in readlensfits remove the ellipticity cut (this was previously necessary because of iv)
vi) scalelength prior now uses latest version from fits to disk galaxies of Simard et al 2002
vii) ellipticity prior now uses latest version from observed axis ratios of SDSS by Unterborn & Ryder 2008
viii) hence new functions rfunc, efunc, efuncderiv, also command-line change as the prior information
is now fixed inside the code and not input as a separate file.  The rfunc prior is also defined
in arcsec rather than pixels, so provided the pixel scale is known or can be determined the r prior
should be camera-independent.  The magnitude dependence of r is fixed to the i(AB) band however.
The ellipticity prior is assumed dominated by orientation and is assumed magnitude independent
(should be almost true).
LM August 2010.

Increased length of delimiter string LM 11/9/2010

revised branch v.5.6.5, incorporated weight mask dilation and erosion into getdata routines, and placed these inside the relevant programs. Improvements to passing of PSF keywords. Improvements to main lensfit 5.6.5 program version, especially distortion correction of models inside likelihood function and no interpolation of the data inside swarp extraction routines, plus better handling of background objects and cosmic ray rejection in PSF programs. New routines weightfilter (same as weightimagefilter separate program) and tbswarpextract_distortion_measure (measures swarp distortion but does not interpolate data). Removed getdata_badpix seprate function. Included catalogue magnitude into lensfit output, and modified readlensfits accordingly, removing need to read the input catalogue. Makefile.am updated for new dependencies. No update of documentation yet, note changes to define statements. 
LM 28/9/2010

Improved handling of star deconvolution in make2Dgalaxymodels.  LM 2 Nov 2010.

Implemented marginalisation over bulge fraction and total flux inside likelihood function,
also updated likelfunc to use the expint Ei function.  LM 4-7 Nov 2010.

Implemented separate ellipticity priors for disk and bulge-dominated galaxies. LM 9 Nov 2010.

Marginalised bulge-fraction, also improved exponential trapping.  LM 10 Nov 2010.

Experimentally included approximately the effects of optically-thick disks on disk surface brightness profiles
using the calibration provided by Graham & Worley (2008) coupled to a simplified model of
extinction which is coupled to emission.  LM 19-21 Nov 2010.

Modified ellipticity and priors.  LM Dec 2010.

Modified galaxy catalogue input format, now reads ID number and passes this through.  LM 18/12/2010.

Correction of satlev bug that incorrectly caused postage stamps to be excluded in second and
subsequent data reads.  Also remove redundant routine varylpthresholdf3 and associated memory 
allocations.  LM 9 Jan 2011.

v7.1  Tidying-up of code, removing redundant option of using galaxy cross-correlation to measure
astrometric shifts between images (this was noisy and using the stars is much better). LM 5/02/2011.

Writes prior information and lensfit version number as keywords into first FITS table

Changed calculation of marP (marginalised posterior) so that this is now only marginalised over
scalelength and has not been multiplied by the ellipticity prior, hence the output is likelihood
not posterior probability of ellipticity.  LM 10/2/2011

Converted modelft arrays from double to float to save memory.  LM 11/2/2011.

v 7.1.1 Corrected bug in convolvemodel.c (correct modelft to be float as modified above) and data
race condition for psfgal.  LM 27/4/2011.

Added in evaluation of range of galaxy sizes that will be needed, setting sampling of
scalelength appropriately, and simplified rfunc function with removal of Rmaxarcsec variable,
also placed afit parameters in global declarations so they can be accessed by main program.  LM 27/4/2011.

v 7.2  Added additional command-line argument, postage-stamp size

v 7.2.1 Modified handling of output strings that hold expousre names, to allow longer exposure names
to be passed through.  LM 10/6/2013

Modified reporting of deblending status flags, and handling of blended objects, to match SVN trunk and branches/Lance versions.  Blended objects are now fitted, but have a negative status flag attached as described in the comments in detectobject().

14th June CH hack - following CFHTLenS version, I 
added in a different number of threads for the postage stamp
extraction to make sure the memory limits were not violated


SVN Revision $Rev: 233 $ 
last changed by $Author: miller $
on $LastChangedDate: 2014-02-14 08:36:39 +0000 (Fri, 14 Feb 2014) $

--------------------------------------------------------------------------- */

#define DATE_STRING "$LastChangedDate: 2014-02-14 08:36:39 +0000 (Fri, 14 Feb 2014) $"
#define REV_STRING "$Rev: 233 $"

#include <pthread.h>
#include <errno.h>
#include <stdio.h>
#include <stdlib.h>
#include <stdarg.h>
#include <math.h>
#include <float.h>
#include <time.h>
#include <string.h>
#include <unistd.h>
#include <fitsio.h>
#include <complex.h>
#include <fftw3.h>
#include <nrutil.h>
#include <lensutil.h>
#include <gsl/gsl_math.h>
#include <gsl/gsl_sf_exp.h>
#include <gsl/gsl_sf_erf.h>
#include <gsl/gsl_sf_gamma.h>
#include <gsl/gsl_sf_result.h>
#include <gsl/gsl_randist.h>
#include <gsl/gsl_cdf.h>
#include <gsl/gsl_integration.h>
#include <gsl/gsl_errno.h>
#include <gsl/gsl_spline.h>
#include <gsl/gsl_sf_expint.h>
#include <gsl/gsl_interp.h>
#include <gsl/gsl_matrix.h>
#include <gsl/gsl_eigen.h>
#include <gsl/gsl_blas.h>

/* swarp wcs include files (but note custom version of fitscat.h to avoid conflict with cfitsio */
#include "define.h"
#include "types.h"
#include "globals.h"
#include "./fitscat.h"
#include "fitswcs.h"
#include "data.h"
#include "field.h"
#include "header.h"
#include "interpolate.h"
#include "prefs.h"
#include "projapprox.h"
#include "resample.h"
#include "weight.h"
#include "wcs/wcs.h"
				      
// set value of Pi
#define pi M_PI
				      
// define return values from functions - don't change these!
#define NOT_MEASURED -1.e10
#define UNSATISFACTORY_VALUE -2.e10

/*--------------------------------------------------------------------*/
/* set some global variables that control the program execution modes */
/*--------------------------------------------------------------------*/

/*------------------------------------------------------------*/
/* functioning of the program                                 */
/*------------------------------------------------------------*/

/* set whether verbose output (info on memory allocation and input images) is output (1) or not (0) */
#define VERBOSE 1

/* set number of threads = number of shared-memory processors */
#define NUM_THREAD 24

// set number of threads for postage-stamp extraction
// MUST BE LESS THAN OR EQUAL TO NUM_THREAD
#define NUM_IMAGE_THREAD 8

/* specify how much memory is available (MB). If this is too close to
   the hard memory limit of the machine, it may run into problems on
   large datasets, because memory is freed and then reallocated,
   depending on the virtual memory management this might fragment the
   swap space.  Also, you should allow some memory for the operating
   system and any other processes that are running */
#define MEMORY_LIMIT 20000

/*------------------------------------------------------------*/
/* datafile and instrument settings                           */
/*------------------------------------------------------------*/

/* define whether input files are gzipped fits or plain fits
   0=not zipped, 1=weight files are zipped, 2=both data and weight files zipped */
#define GZIPPED 1

/* set whether weight files are *required* (exits if not found) 
   0=not required, 1=required */
#define WEIGHTS_REQUIRED 1

/* set the minimum accepted exposure time for each image (requires keyword to
   be present in image FITS headers) */
#define minexposuretime 0.

/* set the minimum accepted fraction of exposures that each galaxy must have.
   If minexposurefraction <= 0. at least one exposure will be required.
   If minexposurefraction >= 1. all exposures must be used.
   NB needs care if there are field boundaries with fewer exposures covering the sky
   than in the main part of the field - you might end up flagging out whole sky areas. 
   Usually it's best to set this to zero and then filter by number of exposures later
   at catalogue level (lensfit putputs info on which exposures were used for each galaxy. */
#define minexposurefraction 0.

/* Set the instrument here by defining the flag that is checked later
   in the code. Possible flags to set here are KIDS, CFHT, SINGLE or SUPRIME */
#define KIDS (1)
				      //#define CFHT (1)

/* define whether to use an r-band or i-band prior */
// #define IBAND (1)
#define RBAND (1)

						 
/* switch rejection of blended galaxies on (1) or off (0)
For cosmic shear measurement this should normally be set to 1 so that noisy object are removed.
If you want to measure shapes for irregularly-shaped objects regardless, then set this to zero.
In either case, lensfit output flags are set to a negative number for blended galaxies.
If it is set to zero, there will be an additional chi-squared criterion applied, in which
badly-fitting objects are rejected: this additional rejection is normally not enabled for shear
measurement because it introduces a low-level correlation with the PSF */
#define DEBLENDING_REJECTION (0)

/* If DEBLENDING_REJECTION is set to zero, there can be an additional chi-squared criterion applied, in which
badly-fitting objects are rejected: this additional rejection is normally not enabled for shear
measurement because it introduces a low-level correlation with the PSF */
#define REJECT_BAD (0)
// this is only in effect if deblending_rejection is turned off

/*------------------------------------------------------------*/
/* astrometry settings                                        */
/*------------------------------------------------------------*/

/* define whether input galaxy catalogue positions are in WCS (WCS=1)
   or pixel (WCS=0) coordinates */
#define WCS 1

/* set whether to use swarp coordinate conversion or not 
   NB normal use requires WCS=1 also */
#define USE_SWARP 1

/* set how to apply swarp distortion correction:
   0  no correction applied
   1  correction applied to data (using interpolation)
   2  correction applied to model (recommended)
   NB if set, requires WCS=1 and USE_SWARP=1 also */
#define CORRECT_DISTORTION 2

/* set whether to apply globalshifts (1) or not (0).  If not, then subixel shifts arising
from the pixelisation are applied (only) provided the subpixel_shift flag is also set.
Note that the global shifts must exist in the PSF coeffs file regardless of whether this
flag is set to 1 or 0. */
#define APPLY_GLOBALSHIFTS 1

/* set whether to allow sub-pixel shifts (-1=no shifts 0=nearest integer shifts only, 1=subpixel shifts) */
#define SUBPIXEL_SHIFT 1


/*------------------------------------------------------------*/
/* PSF settings                                               */
/*------------------------------------------------------------*/

/* define whether a global polynomial PSF file, as created by
   makeglobalpsf, is to be used or not (1=yes).  If it is, the
   identification of each chip in the mosaic will be determined from
   the input image filenames, assuming the CFHTLSW filename
   convention.  That part will need to be modified for surveys with
   other names.  The survey geometry will also need to be explicitly
   given in the code below (as well as in makeglobalpsf) */
#define GLOBAL_PSF 1

/* For the case of individual-chip PSFs (GLOBAL_PSF=0) only, created by makepsfsurface,
   set a lower limit to the number of stars required in each subregion of each chip
   when the PSF was made.  This guards against subregions that have badly fitting PSFs
   because of a lack of stars.  
   For the case of global PSFs (GLOBAL_PSF=1) set a lower limit to the number of stars
   required in each individual chip - if fewer than this number were used, that chip
   will be disqualified */
#define PSF_STAR_LIMIT 30

/* set the rejection threshold for excluding postage stamps whose PSF is more elliptical
   than the specified limit (set value 1.0 to avoid any cut) */
#define psfelimit 1.0

/*--------------------------------------------------------------------*/
/*   diagnostic flags and detailed behaviour                          */
/*--------------------------------------------------------------------*/

/* define 3D or 2D galaxy models (1=true=3D, 0=false=2D) */
#define MODELS_3D 0

/* set number of simulation iterations:
   NITER=1 analyse data only 
   NITER=4 create simulations also */
#define NITER 1

/* set whether to oversample the models (1) or not (0) */
#define MODEL_OVERSAMPLING 1

/* set whether or not to subtract a constant median background 
   (0=no 1=yes) */
#define SUBTRACT_MEDIAN 0
/* NB this subtracts the median value of the input image */

/* set whether to interpret the input filenames as CFHTLSW filenames and then
   print out astrometric shifts to a file (0=no 1=yes) */
#define PRINT_SHIFTS 0

/* set whether to write out extra fits tables of the summed likelihoods in bins of
   magnitude.  This data is used to iteratively construct the prior but is not
   needed otherwise (0=no output, 1=create output files) */
#define WRITE_SUMMED_LIKELIHOODS 0

/* set whether to write out FITS cube of chi-squared surfaces (NB use only for a small
   number of objects, <2000) */
#define WRITE_CHISQ_SURFACES 0

/* set whether to write out models to a FITS cube (environment variable MODELFILE must be set) */
#define WRITE_MODELS 0

/* for testing, write out a number of postage stamps to a 3D fits file.
   Do not set this too high or the file will be enormous.  Set to zero for normal use.  */
#define NTEST_LIMIT 0

/* set the level of allowed systematic error when testing when the model is a good fit.
   This is defined as a fraction of the model surface brightness (not currently used) */
#define systematic 0.03

/*--------------------------------------------------------------------*/

/* function prototypes */

void galaxy_ellipticity (int, double, double*);
// 3D galaxy model integration kernel
double f (double, void*);
// gsl marginalisation kernels
double marf(double, void *);
double marr(double, void *);
double marflux(double, void *);

void propagate_scalelengths(int);
void propagate_rstep_values(int);
int marginaliser(int, int, int, int, int, int, double);
int findmaxr (int, int, int, int, int, int, double*);
int quadfit(int, int, double*, double*, double*);
void dsvbksb(double **, double[], double **, int, int, double[], double[]);
void dsvdcmp(double **, int, int, double[], double **);
int getcoeffs_fits_expand_v5(char *, double **, int, int, int, int, int,
                             int *);
int getglobalcoeffs(char *, double **, int, int, int, int, int, int, double *,
                    double *);
int getpsfsize_v5(char *, int *, int *, int *, int *, int *, int *, int *);
int getglobalpsfsizes(char *, int *, int *, int *, int *, int *, int *, int *, int *,
                      int *, int *, int *, int *, int *, double *, double *, float *,
                      double *, int *, int *, int *, int *);
int extractpostagestamp(float *, float *, int *, double *, double *, float *,
                        float *, float, float, float, float, float, int, int,
                        float, float);
int tbswarpextract_noflag(wcsstruct *, float *, float *, int *, double *,
                          double *, float, float, float, int, int,
                          ikernelstruct *, float, double *, float,
                          double *, double *, double *, double *, double **);
int tbswarpextract_distortion_measure (wcsstruct *, 
				       float *, float *, int *, double *, double *,
				       float, float, float, int, int,
				       float, float, double *, double *);
void getdata_badpix(char *, char *, int *, float *, float *, float *);
void dilatemask(float *, int *);
void mediansub(float *, float *, int *, float, float *);
double likelihood(int, int, int, int, float *, float *);
double likelfunc(double);
int readludocat_dec2010(char *, int, int, int, int, int, int, double *, double *,
			float **, float **, float *, int *);
int readgalcatsize(char *);
// int    readpsfcatsize  (char*);
// int    readpsfcat      (char*, float*, float*, float*);
int getimagesize(char *, char *, int *, float *, float *, float *, float *,
                 int *, int *, float);
void make2Dgalaxymodel(int, float**, double, double, double);
void make3Dgalaxymodel (int, float**, double, double, double);
void convolvemodel(fftw_plan *, fftw_complex *, float **, int, int,
                   fftw_complex **);
int xcorr_measure(fftw_plan, fftw_complex *, fftw_complex *, int, int, int,
                  int, fftw_complex *, double *, fftw_complex *, double *);
int shiftft(int, int, fftw_complex *, double *);
void svdfit2dsqc(double *, double *, double *, double *, int, int, int,
                 double *, double **, double **, double *);
void reconstruct(double, double, int, int, double *, double *);
void globalreconstruct(double, double, int, int, int, int, int, int, double *,
                       double *);
void psfmoments(double *, int, int, double *, double *, double *);
//int varylpthresholdf3(int, int);
int detectobject(int, int, double **);
double rfunc (double, float);
double efunc(double);
double bulgefunc(double);
//double efuncderiv(double);
int wcs_to_raw(wcsstruct *, double *, double *);
void load_dfield(fieldstruct *, catstruct *, char *, int, int);
ikernelstruct *init_ikernel(interpenum *, int);
int read_images();
int expand_wanted(int, int, int);

/* thread functions */
void *imageloop(void *);
void *detectobjloop(void *);
void *objectloop(void *);
void *model_loop(void *);
void* ellipticity_lookup (void*);

static int
compare(const void *ii, const void *jj)
{
    float *i, *j;
    i = (float *) ii;
    j = (float *) jj;
    if (*j > *i)
        return -1;
    if (*j < *i)
        return 1;
    return 0;
}



/* global variables & pointers */

// set ellipticity posterior threshold at 0.02 in probability (i.e. enclosing 98% of a 2D gaussian)
float Pcut = 0.02;
// set likelihood threshold at 0.02
float Lcut = 0.02;

int subtract_background=1; // define whether to fit and subtract linear background from postage stamps (0=no, 1=yes)

// printlikel is used to print diagnostic likelihood info for the selected object
// remember that objects are numbered starting at 0 (C convention)
int printlikel={-1}; 

int status = { 0 };
int postage_stamp_size;       
int minexposurenumber;          /*  minimum acceptable number of exposures per galaxy */
int NCHIPS;                     /*  number of CCDs in mosaic */
int **dim;                      /*  dimensions of main input image  */
unsigned int *npass, *nfail;
int nobj, numstar, pwidth, pheight, nimages;
int nmaximages, chipvariation, chiporder, ncoeffs, forder, crossterm;
int numzero, nume, numR, edim, halfpwidth, halfpheight;
int expandedwidth, expandedheight;
int nsampling, nxchip, nychip, xchipsampling, ychipsampling, big_gap;
int *chipnumber;
int mheight, mwidth, halfmwidth;
int *fitclass;
int *badccd;
short int *no_psf;
short int *nim;
unsigned short int **numgoodpix;
int *imageid;
int **elookup, *e1lookup, *e2lookup;
int *boxsize, *xboxnum, *yboxnum, *maxboxno;
int **listnum;
int phiset;
int minsamplepoints;
int nmin, nmax, nselected;
int exit_after_one_extracted;
int sorder, schipvariation, scrossterm, schiporder, sncoeffs;
int *ochipnum, *catid;
int maximagefilelen;

short int **extractedobject;

float snlimit, blim, flim;
float *ximageoffset, *yimageoffset;
float *arcperpix, *gain, *satlev, *rawsatlev, *angle;       /*  image properties  */
float poserror, *psfposerror, phi, noiserefval;
float *noise, *weight, **objx, **objy, *catmag;
float datamemory, datamemory1;
float ***modelft;
double **moments[NUM_THREAD];

double EXPMIN, EXPMAX;
double **modelelookup, *mu_array;
double defaultmeanscalefactor;
double *opsf0, *opsf1;
double *psfgal, *psfgalsq, *psfgaln;
double fsize, mfsize;
double meanmoments[3], mm[2], moffatbeta, moffatfwhm;
double e_interval, coarse_e_sampling;
double *e1, *e2, *Ro;
double ***acoeffs, **xcoeffs, **ycoeffs;
double **datasq, *fprob, *rmar;
double *wcsx, *wcsy, *noiseperpixel, *snratio, *hxsize, *hysize;
double *rp, *rd, *rc;
double ***Dreal, ***dmoments;
double *summedrposterior, *rposterior[NUM_THREAD], *interp_rval[NUM_THREAD];
float **oval;
int *numval;
fftw_complex ***D;
fitsfile *ofptr[NITER], *pfptr;
FILE *shiftsfile;
char **exposurename;
char *badpixdir;
char *pwd, *headevariable, *dataevariable, *catevariable, *psfevariable;
char *weight_suffix, delimiter[5], headdelimiter[5];
char **image_file;
char **imageweightname, **imagename, **headerfile;
char *satname;
char *rootname, *stampname, **ostring, *ostring_tform;

/* swarp wcs variables */
catstruct **rawcat;
fieldstruct **rawfield;
wcsstruct **wcs_raw;

/* array for test output images */
double *otestout, *meantestout;
int ntestobj = 0;
int nmtestobj = 0;
int *testobj, *testimage;

/* variables for the continuous prior function */
double Rmin, Rmax, Rinterval, Rcutoff, kappaval, diskratio, beta0, bscalefactor, Sindex;
double bfpeakval, bfsigma, fluxpriorslope, bulgepopfrac;
// disk ellipticity prior parameters
double efunc_a, efunc_emax, efunc_sigma;
// bulge ellipticity prior parameters
double bulgefunc_b, bulgefunc_c;

// nominal fit to log(median) from V606 Simard photometry
#ifdef RBAND
double afit[2]={-1.319698, -0.277907};  
#else 
 #ifdef IBAND
    double afit[2]={-1.1448076, -0.26932025};  
 #else
    double afit[2]={0., 0.};  
 #endif
#endif
float refmag={23.0};


/* set magnitude limits of bins for output summed posterior distributions */
int nmagarray[12];
float *magarray[12];
int nmagbins = { 12 };

float maglimits[] =
    { 22.0, 22.5, 23.0, 23.25, 23.5, 23.75, 24.0, 24.25, 24.5, 24.75, 25.0,
    30.
};

// pointers to work arrays (must be made threadsafe)
int currentobject[NUM_THREAD];
int numgoodpsf[NUM_THREAD], numbadpsf[NUM_THREAD], numcosmicreject[NUM_THREAD];
//int nmaxregion[NUM_THREAD];
int *badid[NUM_THREAD], *goodid[NUM_THREAD], *ellipticalpsf[NUM_THREAD];
int imagesize[NUM_THREAD], allocatedimagesize[NUM_THREAD];
int nodata[NUM_THREAD];
int badfit[NUM_THREAD];
int notdetected[NUM_THREAD];
int closefit[NUM_THREAD];
int starfit[NUM_THREAD];
int goodfit[NUM_THREAD];
int numblend[NUM_THREAD];
int numtoobig[NUM_THREAD];
int chisqcut[NUM_THREAD];
int toofewexposures[NUM_THREAD];
int noexposures[NUM_THREAD];
int *checkimage[NUM_THREAD];
short int *wanted[NUM_THREAD], *new_wanted[NUM_THREAD], *old_wanted[NUM_THREAD];
int *etable[NUM_THREAD];
int **connected[NUM_THREAD], *objpix[NUM_THREAD];
int *objnum[NUM_THREAD], *colour[NUM_THREAD];
short int *offscale[NUM_THREAD];
int thread_running[NUM_THREAD], imagethread[NUM_THREAD];
int *fittednRo[NUM_THREAD], *fittedrstep[NUM_THREAD];

// GSL interpolation functions and integration workspace
// GSL interpolation functions and integration workspace
gsl_interp_accel *facc[NUM_THREAD], *racc;
gsl_spline *fspline[NUM_THREAD], *rspline;
int gsl_work_size={1000};
gsl_integration_workspace *gsl_work[NUM_THREAD];
gsl_eigen_symmv_workspace *gsl_eigen_work[NUM_THREAD];
gsl_matrix *umatrix[NUM_THREAD], *evec[NUM_THREAD];
gsl_vector *eval[NUM_THREAD], *bvec[NUM_THREAD], *yvec[NUM_THREAD];

double *xmarvals[NUM_THREAD], *ymarvals[NUM_THREAD], *rmarvals[NUM_THREAD], *marbtvals[NUM_THREAD];
double *xevals[NUM_THREAD], *yevals[NUM_THREAD], *wevals[NUM_THREAD], *revals[NUM_THREAD];
double **rfitvals[NUM_THREAD], maxrposterior[NUM_THREAD];
int num_marvals[NUM_THREAD], numlookup;

int ncall[NUM_THREAD], nmarfail[NUM_THREAD];
int totalncall = 0;
int meannsample = 0;
int meansampling = 0;

// tswarpextract
float maxlevel[NUM_THREAD];
double *rawpos[NUM_THREAD], *wcspos[NUM_THREAD];
double *wcsneg[NUM_THREAD], *wcscentre[NUM_THREAD];
double **kern[NUM_THREAD];

float *nimweight[NUM_THREAD];
float *ltable[NUM_THREAD];
float *vals[NUM_THREAD], memd[NUM_THREAD];
float *apix[NUM_THREAD], *sortarray[NUM_THREAD], *temp[NUM_THREAD];
float *badpix[NUM_THREAD], *badtemp[NUM_THREAD];        /*  image arrays  */
float memi = { 0. };            /* input image memory usage counter */
float meme = { 0. };            /* miscellaneous memory usage counter */
float swapamount;
float max_eta;

int *galselected;

char keywordfile[10][FLEN_VALUE];
char keystring[FLEN_KEYWORD];

double **psfevals[NUM_THREAD];
double *sn[NUM_THREAD], *sw[NUM_THREAD];
double *sn1[NUM_THREAD], *sw1[NUM_THREAD];
double *rprior[NUM_THREAD], *eprior[NUM_THREAD];
double *likel[NUM_THREAD], *marP[NUM_THREAD];
double *linearposterior[NUM_THREAD];
double *xfit[NUM_THREAD], *yfit[NUM_THREAD], *zfit[NUM_THREAD], *wfit[NUM_THREAD];
double **u[NUM_THREAD], **v[NUM_THREAD], *w[NUM_THREAD], *avals[NUM_THREAD];
double **c[NUM_THREAD], *psf[NUM_THREAD];
double *chisq[NUM_THREAD], *bestchisq, **spos;
double *bulge[NUM_THREAD], *disk[NUM_THREAD], *dmodel[NUM_THREAD];
double *stardmodel[NUM_THREAD], *star[NUM_THREAD];
double *dpix[NUM_THREAD], *cumulative[NUM_THREAD];
double ***sumlikel[NUM_THREAD];
float **testmodel[NUM_THREAD];
double *dbadpix[NUM_THREAD];
double shift[NUM_THREAD][2];
double *datasqp[NUM_THREAD];
double **mshift[NUM_THREAD];
double sumdata[NUM_THREAD];
double peaklikel[NUM_THREAD];
double *scalefactor, ***edist;
double **modelflux[NUM_THREAD];
double **tdist[NUM_THREAD];
double **expandedft[NUM_THREAD];
double ***interpft[NUM_THREAD];

fftw_complex **Dp[NUM_THREAD];
fftw_complex *A[NUM_THREAD], **B[NUM_THREAD], **C[NUM_THREAD],
  *DFT[NUM_THREAD], *starA[NUM_THREAD], *dstarA[NUM_THREAD], 
  **AA[NUM_THREAD], **CC[NUM_THREAD];
fftw_plan *p[NUM_THREAD], *pinv[NUM_THREAD], *pmodel[NUM_THREAD];
fftw_plan q[NUM_THREAD], fmodel[NUM_THREAD], smodel[NUM_THREAD], 
  starfmodel[NUM_THREAD], starsmodel[NUM_THREAD], moffatpsf[NUM_THREAD];


ikernelstruct *ikernel[NUM_THREAD];

// structure to pass to threads
struct threadindex {
    int objectnum;
    int threadnum;
};
struct threadindex threadarg[NUM_THREAD];

pthread_mutex_t fitsfilelock, shiftsfilelock, noiserefvallock,
    nimlock, memdlock, testlock;
pthread_attr_t attr;
size_t stacksize, mystacksize, guardsize;  // stack sizes set and checked in threads
pthread_t threads[NUM_THREAD];
void *tstatus;

/* --------------------------------------------------------------------------- */
/*  main program  */

int
main(int argc, char *argv[])
{
  // output version information based on SVN info
    char version[100];
    bzero(version,100);
    strcpy(version, REV_STRING);
    int len; 
    len = strlen(version);
    strcpy(&version[len-2],"\0");
    printf("\n lensfit version SVN:%s",&version[len-5]);
    char datedelims[]="()";
    char *dstring = NULL;
    char date_string[200];
    bzero(date_string,200);
    strcpy(date_string, DATE_STRING);
    dstring  = strtok(date_string, datedelims);
    if (dstring != NULL) dstring = strtok(NULL, datedelims);
    if (dstring != NULL) printf(" %s ",dstring);
    printf("\n");

    // initialise threads stuff, mutex locks etc
    pthread_mutex_init(&fitsfilelock, NULL);
    pthread_mutex_init(&shiftsfilelock, NULL);
    pthread_mutex_init(&noiserefvallock, NULL);
    pthread_mutex_init(&nimlock, NULL);
    pthread_mutex_init(&testlock, NULL);
    pthread_mutex_init(&memdlock, NULL);

    pthread_attr_init(&attr);
    pthread_attr_setdetachstate(&attr, PTHREAD_CREATE_JOINABLE);
    /*
     * check and set the stack size.  Because the threads call
     * functions it's hard to know exactly how much is needed.  Guess
     * that 100MB is enough
     */
    pthread_attr_getstacksize(&attr, &stacksize);
    // set stack size to 100MB
    mystacksize = 100 * 1024 * 1024;
    if (stacksize < mystacksize) {
        if (VERBOSE == 1)
            printf(" default stack size = %li \n", (long) stacksize);
        stacksize = mystacksize;
        pthread_attr_setstacksize(&attr, stacksize);
        pthread_attr_getstacksize(&attr, &stacksize);
        pthread_attr_getguardsize(&attr, &guardsize);
        if (VERBOSE == 1)
	  {
            printf(" stack size reset to %li \n", (long) stacksize);
            printf(" stack guard size %li \n", (long) guardsize);
	  }
    }

// find min, max allowed exponent 
    EXPMAX = (DBL_MAX_EXP-1)*log(FLT_RADIX);
    EXPMIN = (DBL_MIN_EXP-1)*log(FLT_RADIX);
    // printf (" exponent min, max %f %f \n",EXPMIN,EXPMAX);
    // printf (" exponent min, max %f %f %f \n",exp(EXPMIN),exp(EXPMAX),exp(EXPMIN)*exp(EXPMAX));


    float memm = { 0. };        /* model memory usage counter */

    int foundexposure, nfoundexposures, nanalysed;
    int correctd;
    int nt, mt, nvalid, ic;
    int psfwarning = { 0 };
    int tnodata = { 0 };
    int toofew = { 0 };
    int tnone = { 0 };
    int tbadfit = { 0 };
    int tnotdetected = { 0 };
    int tgoodfit = { 0 };
    int tstarfit = { 0 };
    int tclosefit = { 0 };
    int tchisqcut = { 0 };
    int tblend={ 0 };
    int toobig={ 0 };
    int tswap = { 0 };
    int toutsidemag = { 0 };
    int thread_return;
    int originalpwidth, originalpheight;
    int modelsize;
    int i, j, ii, jj, x, y, yx, row, nn;
    int is, ts, sampling, modelnum;
    int magbin;
    int msize, mcomplexsize;
    int ne, nRo;
    int nobj2, ncatimages, ntotalimages;
    int startobj, endobj, startexp, endexp;
    int psfsize;
    int *order, pixel;
    int ie1, ie2;
    int maxncoeffs = 0;         /* shut up compiler warning */
    int **numstars;
    int number_available, recalculate_models;
    int numthisthread;
    int xchip, ychip, ichip;
    int msf;
    int exclude;
    int nfield;
    int gsl_status;
    unsigned int tot;

    long pcount;

    time_t t1, t2, t3;

    double modelmemory, memory_per_object;
    double dx, dy;
    double minmoment;
    double **tsumlikel;
    double xval, yval;
    //double de[2];
    double rprob, meanp, psfgalerr;
    double cosi, modelelimit[2];

    double rval, aval, pmax;
    float catminmag, catmaxmag;

    float lowerbin, medianmag, fmag, fthresh, *smag;
    float max_aob, etasq, max_etasq, ee1, ee2;

    int nstringcat, len0, slen;
    char *catname, *psfname, *startp;
    char *prefsname, *pstr;
    char *starcatname, *shiftsfilename;
    char *rawfile;
    char **galcat_file, **psf_file, **starcat_file, *tempname;
    char ofile[300], string[10], *spfile;

    FILE *ret;

    int *numst, *ngals, *pw;

    /*
     * output FITS file variables  
     */

    long nrows = 0;             /*  initial number of table rows  */

/*  table of posterior probability for each galaxy  */
    int tfields = 20;           /*  number of table columns in main table  */
    char extname[] = "Likelihood probability surface";   /*  extension name  */
    char *ttype[] = {"ID", "ra", "dec", "mag", "exposures", "chips", "PSFe1", "PSFe2", "meanPSFe", "Strehl", "class", "size", "bfrac", "flux", "SNratio", "profileSN", "sampling", "stargalprob", "evalues", "logP" }; /*  names of columns  */
    char *tform[20];            /*  data types of columns  */
    for(i = 0; i < 20; i++)
        tform[i] = (char *) calloc(8, sizeof(char));
    char *tunit[] = {"", "degs", "degs", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "log"};      /*  units  */

/*  table defining grid of e1,e2 values  */
    int efields = 2;            /*  number of table columns in e1,e2 definition table  */
    char e_extname[] = "ellipticity values";    /*  extension name  */
    char *etype[] = { "e1", "e2" };     /*  names of columns  */
    char *eform[] = { "1D", "1D" };     /*  data types of columns  */
    char *eunit[] = { "", "" }; /*  units  */

/*  table defining grid of r values  */
    int rfields = 1;            /*  number of table columns */
    char r_extname[] = "r values";      /*  extension name  */
    char *rtype[] = { "r" };    /*  names of columns  */
    char *rform[] = { "1D" };   /*  data types of columns  */
    char *runit[] = { "" };     /*  units  */

/*  table defining grid of summed posterior values  */
    int pfields = 3;            /*  number of table columns in table  */
    char p_extname[] = "posterior values";      /*  extension name  */
    char *ptype[] = { "e1", "e2", "p" };        /*  names of columns  */
    /*
     * the fourth column is a vector, each element corresponding to a different Ro value 
     */
    char *pform[] = { "1D", "1D", "1PD" };      /*  data types of columns  */
    char *punit[] = { "", "", "" };     /*  units  */

/* fits file for output models */
    char *modelfile;
    modelfile = (char *) calloc(500, sizeof(char));
    int mnaxis = 3;
    long mfpixel[3] = { 1, 1, 1 }, manaxes[3];
    int mbitpix = -64;
    fitsfile *mfptr;
    double psfe[2], centroid[2];

    char **argkey, **argval;
    int narg, naxis;

    /*
     * number of exposures given in input catalogue (relevant only for an xy
     * catalogue when WCS=0) 
     */
    ncatimages = 7;

    /*
     * set area limits on detected objects for routine varylpthresholdf
     
    lower_area_limit = 5;
    merging_area_limit = 15.;
    arealimit = 100000;
    */

/*  read command-line and test the input arguments  */

    if (argc != 6 && argc != 8) {
        printf
            (" %s <input file name> <output name> <postage stamp size> <start exposure> <end exposure> [<bright mag limit> <faint mag limit>]\n",
             argv[0]);
        exit(EXIT_FAILURE);
    }

    /*
     * turn off default GSL error handler 
     */
    gsl_set_error_handler_off();


    if (CORRECT_DISTORTION >= 1) {
        if (USE_SWARP == 0 || WCS == 0) {
            fprintf(stderr,
                    " CORRECT_DISTORTION is set but USE_SWARP or WCS are not\n");
            exit(EXIT_FAILURE);
        }
    }

    satname = (char *) calloc(30, sizeof(char));

    if (USE_SWARP == 1) {
        printf(" swarp astrometric corrections will be applied \n");
        if (WCS == 0) {
            printf
                (" WARNING:  WCS flag not set, using pixel object coordinates \n");
            printf
                (" even though WCS information is needed for the swarp correction \n");
        }
        /*
         * read the swarp preferences file 
         */
        narg = 0;
        naxis = 2;
        QMALLOC(argkey, char *, 1);
        QMALLOC(argval, char *, 1);
	prefsname = (char *) calloc(300, sizeof(char));
        prefsname = getenv("SWARP_CONFIG");
        if (prefsname != NULL) {
            strcpy(prefs.prefs_name, prefsname);
            readprefs(prefs.prefs_name, argkey, argval, narg);
            prefs.verbose_type = QUIET; // turn off verbose reporting
            useprefs();
        } else {
            fprintf(stderr,
                    "configuration file environment variable SWARP_CONFIG not set \n");
            exit(EXIT_FAILURE);
        }
        free(argkey);
        free(argval);
        //printf(" resampling type x-axis %d \n",prefs.resamp_type[0]);
        //printf(" resampling type y-axis %d \n",prefs.resamp_type[1]);
        /*
         * initialise the convolution kernel 
         */
        for(nt = 0; nt < NUM_THREAD; nt++)
            ikernel[nt] = init_ikernel(prefs.resamp_type, naxis);
	/*
	 * copy the keyword name for the saturation level 
	 */
	strcpy(satname, prefs.sat_keyword);
    } 
    else 
      {
        printf(" no swarp astrometric corrections will be applied \n");
	strcpy(satname, "SATLEVEL");
      }


    if (CORRECT_DISTORTION == 0)
		printf(" no distortion correction applied \n");
    if (CORRECT_DISTORTION == 1)
		printf(" distortion correction applied to data \n");
    if (CORRECT_DISTORTION == 2)
		printf(" distortion correction applied to models \n");

    for(nt = 0; nt < NUM_THREAD; nt++) {
        nodata[nt] = 0;
	toofewexposures[nt] = 0;
	noexposures[nt] = 0;
        badfit[nt] = 0;
        notdetected[nt] = 0;
        goodfit[nt] = 0;
        starfit[nt] = 0;
        closefit[nt] = 0;
        chisqcut[nt] = 0;
	numblend[nt]=0;
	numtoobig[nt]=0;
        // allocate swarp-variable memory
        rawpos[nt] = (double *) calloc(2, sizeof(double));
        wcspos[nt] = (double *) calloc(2, sizeof(double));
        wcsneg[nt] = (double *) calloc(2, sizeof(double));
        wcscentre[nt] = (double *) calloc(2, sizeof(double));
        kern[nt] = (double **) calloc(2, sizeof(double *));
	meme += 8.*sizeof(double) + 2.*sizeof(double*);
        for(i = 0; i < 2; i++)
	  {
            kern[nt][i] = 
              ml_calloc(INTERP_MAXKERNELWIDTH, sizeof(double), &meme, "kern");
	  }
        // allocate GSL objects
        /*
         * allocate spline interpolation for marginalisation 
         */
        facc[nt] = gsl_interp_accel_alloc();
        if (facc[nt] == NULL) {
            fflush(stdout);
            fprintf(stderr, " error from gsl_interp_accel_alloc, facc \n");
            exit(EXIT_FAILURE);
        }
	meme += sizeof(gsl_interp_accel);
	// allocate the workspace for the integrator
	gsl_work[nt] = gsl_integration_workspace_alloc(gsl_work_size);
        if (gsl_work[nt] == NULL) {
            fflush(stdout);
            fprintf(stderr, " error from gsl_integration_workspace, work \n");
            exit(EXIT_FAILURE);
        }
	meme += (float)gsl_work_size*(4.*sizeof(double)+2.*sizeof(size_t));
    }

    /*
     * allocate memory for filename strings etc 
     */

    pwd = (char *) calloc(300, sizeof(char));
    dataevariable = (char *) calloc(300, sizeof(char));
    headevariable = (char *) calloc(300, sizeof(char));
    catevariable = (char *) calloc(300, sizeof(char));
    psfevariable = (char *) calloc(300, sizeof(char));
    badpixdir = (char *) calloc(300, sizeof(char));
    rootname = (char *) calloc(300, sizeof(char));
    stampname = (char *) calloc(300, sizeof(char));
    psfname = (char *) calloc(500, sizeof(char));
    catname = (char *) calloc(500, sizeof(char));
    rawfile = (char *) calloc(500, sizeof(char));
    weight_suffix = (char *) calloc(100, sizeof(char));
    starcatname = (char *) calloc(500, sizeof(char));
    if (catevariable == NULL || dataevariable == NULL || psfevariable == NULL
        || psfname == NULL || catname == NULL || starcatname == NULL
        || badpixdir == NULL) {
        printf("Memory allocation error for filename strings\n");
        exit(EXIT_FAILURE);
    }

    meme += (8 * 300. + 7 * 500 + 130) * sizeof(char);

    /*
     * set the weight file suffix -
     * in the same example, the code will look for a weight
     * file named 715349p_12C.weight.fits or 715349p_12C.weight.fits.gz 
     */
    if (USE_SWARP == 1)
      {
#ifdef KIDS
        strcpy(weight_suffix, "OFCS.weight.fits");
	strcpy(delimiter,"O");
	strcpy(headdelimiter,"O");
#endif
#ifdef CFHT
	strcpy(weight_suffix, "C.weight.fits");
	strcpy(delimiter,"C");
	strcpy(headdelimiter,"C");
#endif
#ifdef SINGLE
        strcpy(weight_suffix, "C.weight.fits");
	strcpy(delimiter,"C");
	strcpy(headdelimiter,"C");
#endif
#ifdef SUPRIME
	strcpy(weight_suffix, "OFCS.weight.fits");
	strcpy(delimiter,"O");
	strcpy(headdelimiter,"O");
#endif
      }
    else
      {
	strcpy(weight_suffix, ".weight.fits");
	strcpy(delimiter,".");
	strcpy(headdelimiter,".");
      }

/* get input environment variables */

    catevariable = getenv("CATALOGUE_GALAXIES");        // galaxy catalogue name
    dataevariable = getenv("DATA_DIR"); // path to data fits files
    headevariable = getenv("HEAD_DIR"); // path to scamp head files
    badpixdir = getenv("BADPIX_DIR");   // path to weight image fits files
    psfevariable = getenv("PSF_DIR");   // path to PSF coefficients files
    modelfile = getenv("MODELFILE");    // model filename (if created already)
    pwd = getenv("PWD");

    printf("\n DATA PATHS:\n");
    printf(" current path %s \n",pwd);
    if (dataevariable != NULL)
        printf(" path to data files %s \n", dataevariable);
    else
      printf(" path to data files . \n");
    if (headevariable != NULL)
        printf(" path to head files %s \n", headevariable);
    else
      printf(" path to head files . \n");
    if (badpixdir != NULL)
        printf(" path to good/bad pixel weight images %s \n", badpixdir);
    else
      printf(" path to good/bad pixel weight images . \n");
    if (WEIGHTS_REQUIRED == 1)
      printf(" pixel weight files are required \n");
    else
      printf(" pixel weight files are not required \n");
    if (psfevariable != NULL)
      printf(" path to PSF files %s \n",psfevariable);
    else
      printf(" path to PSF files . \n");

    /*
     * if modelfile is not set but model-writing is specified, exit 
     */
    if (modelfile != NULL) {
        printf(" Model file %s \n", modelfile);
    } else {
        if (WRITE_MODELS == 1) {
            fflush(stdout);
            fprintf(stderr,
                    " model-writing specified but MODELFILE not set \n");
            exit(EXIT_FAILURE);
        }
    }

    /*
     * catalogue name MUST be specified through the environment variable 
     */
    if (catevariable != NULL) {
        printf(" catalogue %s \n", catevariable);
    } else {
        fprintf(stderr,
                " ERROR no catalogue specified - use environment variable CATALOGUE_GALAXIES \n");
        exit(EXIT_FAILURE);
    }

    printf("\n");
    fflush(stdout);

    /*
     * set up number of exposures for each chip, and total number of chips,
     * these numbers are right for CFHTLS 
     */
    NCHIPS = 1;  // default to 1 CCD in the "mosaic"

#ifdef KIDS
    NCHIPS = 32;
    defaultmeanscalefactor = 0.2; // default scale factor in arcsec/pixel for this camera
#endif
#ifdef SINGLE
    NCHIPS = 1;
    defaultmeanscalefactor = 0.1; // default scale factor in arcsec/pixel for this camera
#endif
#ifdef CFHT
    NCHIPS = 36;
    defaultmeanscalefactor = 0.186; // default scale factor in arcsec/pixel for this camera
#endif
#ifdef SUPRIME
    NCHIPS = 10;
    defaultmeanscalefactor = 0.2; // default scale factor in arcsec/pixel for this camera
#endif

    /* get postage stamp size from command-line */
    postage_stamp_size = atoi(argv[3]);
    printf(" requested postage-stamp size %d \n",postage_stamp_size);
    if (2*(int)(postage_stamp_size/2) != postage_stamp_size)
      {
	fflush(stdout);
	fprintf(stderr,"ERROR postage stamp size must be an even integer \n");
	exit(EXIT_FAILURE);
      }
    if (postage_stamp_size <= 0 || postage_stamp_size > 256)
      {
	fflush(stdout);
	fprintf(stderr," ERROR in command-line postage stamp size %s \n",argv[3]);
	fprintf(stderr," value out of range 1 <= size <= 256 \n");
	exit(EXIT_FAILURE);
      }

    /*
     * default start, end objects 
     */
    startobj = 1;
    endobj = 0;

    /*
     * start, end exposure numbers to be analysed,
     * read from command line (numbering starts at 1) 
     */
    startexp = (int) atoi(argv[4]);
    endexp = (int) atoi(argv[5]);
    nmaximages = endexp - startexp + 1;

    ostring = (char **) calloc(nmaximages, sizeof(char *));
    ochipnum = (int *) calloc(nmaximages, sizeof(int));
    opsf0 = (double *) calloc(nmaximages, sizeof(double));
    opsf1 = (double *) calloc(nmaximages, sizeof(double));

    /*
     * total number of input images expected, to match above 
     */
    ntotalimages = NCHIPS * nmaximages;

    objx = (float **) calloc((ntotalimages), sizeof(float *));
    objy = (float **) calloc((ntotalimages), sizeof(float *));
    //starx = (float**)calloc((ntotalimages),sizeof(float*));
    //stary = (float**)calloc((ntotalimages),sizeof(float*));
    //starmag = (float**)calloc((ntotalimages),sizeof(float*));
    meme += 5. * ntotalimages * sizeof(float *);
    ngals = (int *) calloc((ntotalimages), sizeof(int));
    numst = (int *) calloc((ntotalimages), sizeof(int));
    pw = (int *) calloc((ntotalimages), sizeof(int));
    meme += 3. * ntotalimages * sizeof(int);

    galcat_file = (char **) calloc((ntotalimages), sizeof(char *));
    starcat_file = (char **) calloc((ntotalimages), sizeof(char *));
    psf_file = (char **) calloc((ntotalimages), sizeof(char *));
    image_file = (char **) calloc((ntotalimages), sizeof(char *));
    meme += 4. * ntotalimages * sizeof(char *);

    tempname = (char *) calloc(500, sizeof(char));
    meme += 500. * sizeof(char);

    for(i = 0; i < (ntotalimages); i++) {
        galcat_file[i] = (char *) calloc(500, sizeof(char));
        starcat_file[i] = (char *) calloc(500, sizeof(char));
        image_file[i] = (char *) calloc(500, sizeof(char));
        psf_file[i] = (char *) calloc(500, sizeof(char));
        meme += 4. * 500. * sizeof(char);

        if (galcat_file[i] == NULL ||
            starcat_file[i] == NULL ||
            image_file[i] == NULL || psf_file[i] == NULL) {
            printf("Memory allocation error for filename strings\n");
            exit(EXIT_FAILURE);
        }
    }


    /*
     * read the input file list 
     */
    ret = fopen(argv[1], "r");
    if (ret == NULL) {
        fprintf(stderr, " Error opening file %s \n", argv[1]);
        exit(EXIT_FAILURE);
    }

    nimages = 0;
    len = maximagefilelen = 0;
    while (!feof(ret) && !ferror(ret)) {
        if (fscanf(ret, "%s", tempname) != 0) {
            if (!feof(ret) && !ferror(ret)) {
                if (nimages >= ntotalimages) {
                    fflush(stdout);
                    fprintf(stderr,
                            " too many images found in input list compared with expected number\n");
                    fprintf(stderr,
                            " nimages %d > ntotalimages %d = nmaximages %d x NCHIPS %d \n",
                            1 + nimages, ntotalimages, nmaximages,
                            (int) NCHIPS);
                    exit(EXIT_FAILURE);
                }
                strcpy(image_file[nimages], tempname);
		len = strlen(image_file[nimages]);
		if (len > maximagefilelen) maximagefilelen = len;
                nimages++;
            }
        }
    }
    fclose(ret);
    status = 0;

    printf(" filenames read for %d input images \n", nimages);
    printf(" filenames have a maximum string length of %d \n", maximagefilelen);

    if (nimages <= 0) {
        fflush(stdout);
        fprintf(stderr, " no images read from input list \n");
        exit(EXIT_FAILURE);
    }

    if (WCS == 0 && nimages != (nmaximages * NCHIPS)) {
        // for xy catalogue input the catalogue and input image list must match exactly
        fflush(stdout);
        fprintf(stderr,
                " number of images read in does not match number specified in code \n");
        exit(EXIT_FAILURE);
    }

    if (maximagefilelen <= 0)
      {
	fprintf(stderr," error, input file name strings have zero length");
	exit(EXIT_FAILURE);
      }

    // increment image filename length to allow for termination character
    maximagefilelen++;

    // create tform keyword for the filename string
    if (maximagefilelen < 10)
      ostring_tform = (char*)calloc(3, sizeof(char));
    else if (maximagefilelen < 100)
      ostring_tform = (char*)calloc(4, sizeof(char));
    else
      ostring_tform = (char*)calloc(5, sizeof(char));

    sprintf(ostring_tform, "A%d", maximagefilelen);

    // allocate memory for output strings, depends on size of file names
    for(i = 0; i < nmaximages; i++)
        ostring[i] = (char *) calloc(maximagefilelen, sizeof(char));
    /*
     * update the output FITS table specification 
     */
    if (nmaximages <= 999) {
        strcpy(tform[0], "1J");
        for(i = 1; i < 20; i++)
            strcpy(tform[i], "1D");
	strcpy(tform[3], "1E");
        sprintf(tform[4], "%d%s", nmaximages*maximagefilelen, ostring_tform);
        sprintf(tform[5], "%dJ", nmaximages);
        sprintf(tform[6], "%dD", nmaximages);
        sprintf(tform[7], "%dD", nmaximages);
        strcpy(tform[8], "2D");
        strcpy(tform[10], "1J");
        strcpy(tform[16], "1J");
        strcpy(tform[17], "2D");
        strcpy(tform[18], "1PJ");
        strcpy(tform[19], "1PE");

    } else {
        fflush(stdout);
        fprintf(stderr, "nmaximages %d > 999 \n", nmaximages);
        exit(EXIT_FAILURE);
    }


    if (PRINT_SHIFTS == 1) {
        /*
         * open the output file for the astrometric shifts, if wanted 
         */
        shiftsfilename = (char *) calloc(500, sizeof(char));
        meme += 500. * sizeof(char);
        if (shiftsfilename == NULL) {
            fprintf(stderr, " error allocating memory for shiftsfilename\n");
            exit(EXIT_FAILURE);
        }
        strcpy(shiftsfilename, argv[2]);
        strcat(shiftsfilename, "_shifts.lis");
        shiftsfile = fopen(shiftsfilename, "w");
        if (shiftsfile == NULL) {
            fprintf(stderr, " Error opening file %s \n", shiftsfilename);
            exit(EXIT_FAILURE);
        }
    }

    /*
     * record the exposure number and chip number assuming CFHTLS
     * filename format e.g. 715349p_12C.sub.fits will be decomposed
     * into exposure name 715349 and chip ID number 12
     */
    exposurename = (char **) calloc(nimages, sizeof(char *));
    chipnumber = (int *) calloc(nimages, sizeof(int));
    psfposerror = (float*)calloc(nimages, sizeof(float));
    meme += (float) nimages *sizeof(char *);
    meme += (float) nimages *sizeof(int);
    meme += (float) nimages*sizeof(float);
    numstars = (int **) calloc(nimages, sizeof(int *));
    meme += (float) nimages *sizeof(int *);
    for(i = 0; i < nimages; i++) {
        numstars[i] = (int *) calloc(NCHIPS, sizeof(int));
        meme += NCHIPS * sizeof(int);
    }
    // char cdelims[] = "C";      // we will extract string out of filename starting at first occurence of either p_ or C
#ifdef KIDS
    char pdelims[] = "_";
#else
    char pdelims[] = "p_";      // we will extract string out of filename starting at first occurence of either p_ or C
#endif
    char *item = NULL;
    nfoundexposures = 0;
    for(j = 0; j < nimages; j++) {
        exposurename[j] = (char *) calloc(32, sizeof(char));
        meme += (float) 32 *sizeof(char);
        bzero(tempname, 500);
        strcpy(tempname, image_file[j]);
        // create exposure name by stripping characters out up til pdelims is found
        item = strtok(tempname, pdelims);
        strcpy(exposurename[j], item);    

	//printf(" filenames %s and exposure name %s \n", image_file[j], exposurename[j]);

	/*
        if (item != NULL)
            item = strtok(NULL, pdelims);        // strip out characters up to p_
        if (item != NULL)
            item = strtok(NULL, cdelims);        // strip out characters up to C
        if (item != NULL) 
	  {
            chipnumber[j] = atoi(item); // what's left should be the integer chip ID number
	    if (VERBOSE==1)
	      {
		printf ("string %s data %s %d \n",item,exposurename[j],chipnumber[j]);
	      }
            if (chipnumber[j] > NCHIPS) 
	      {
                fflush(stdout);
                fprintf(stderr, " error specifying chip ID numbers, exceeds value of NCHIPS \n");
                exit(EXIT_FAILURE);
	      }
	  } 
	else 
	  {
            chipnumber[j] = 0;
	    if (NCHIPS==1) chipnumber[j] = 1;
	  }
	*/
	/* check number of unique exposure names */
	foundexposure = 0;
	for (i=0; i<j; i++)
	  {
	    if (strcmp(exposurename[i],exposurename[j])==0)
	      {
		foundexposure = 1;
	      }
	  }
	if (foundexposure==0) nfoundexposures++;
    }
    printf (" number of unique exposures found = %d \n",nfoundexposures);
    if (nfoundexposures==0)
      {
	fflush(stdout);
	fprintf(stderr,"failed to find exposure names from input list \n");
	exit(EXIT_FAILURE);
      }
    if (nfoundexposures<nmaximages) nmaximages = nfoundexposures;

    /* set minimum required number of exposures per object based on specified fraction */
    minexposurenumber = (int)(minexposurefraction*(nmaximages+1));
    if (minexposurenumber <= 0) minexposurenumber = 1;
    if (minexposurenumber > nmaximages) minexposurenumber = nmaximages;
    printf(" requiring galaxies to have at least %d exposures out of possible maximum %d \n",
	   minexposurenumber,nmaximages);

    t1 = time(NULL);            // initialise time recorder

    /*
     * seed the random number generator for the case where random simulations
     * are to be generated (NITER=4) 
     */
    srand48((long) t1);
    drand48();

    /*
     * set default image offsets for multiple input frames - here always set to zero 
     * ximageoffset = (float*)calloc(nimages,sizeof(float));
     * yimageoffset = (float*)calloc(nimages,sizeof(float));
     * meme += (float)2.*nimages*sizeof(float);
     * for (i=0; i<nimages; i++)
     * {
     * ximageoffset[i] = 0.;
     * yimageoffset[i] = 0.;
     * }
     */
    /*
     * ximageoffset is redundant in current useage, so don't allocate memory to it.
     * keep it available in principle though. make sure the value below is zero (use calloc) 
     */
    ximageoffset = (float *) calloc(1, sizeof(float));
    yimageoffset = (float *) calloc(1, sizeof(float));
    meme += (float) 2. *sizeof(float);

    /*
     * read the PSF files  
     */

    acoeffs = (double ***) calloc(nimages, sizeof(double **));
    xcoeffs = (double **) calloc(nimages, sizeof(double *));
    ycoeffs = (double **) calloc(nimages, sizeof(double *));
    if (acoeffs == NULL || xcoeffs == NULL || ycoeffs == NULL) {
        printf("Memory allocation error for coefficient pointers\n");
        exit(EXIT_FAILURE);
    }
    meme += (float) nimages *sizeof(double **);
    meme += (float) 2 *nimages * sizeof(double *);

    dim = (int **) calloc(nimages, sizeof(int *));
    hxsize = (double *) calloc(nimages, sizeof(double));
    hysize = (double *) calloc(nimages, sizeof(double));
    scalefactor = (double *) calloc(nimages, sizeof(double));
    order = (int *) calloc(nimages, sizeof(int));
    badccd = (int *) calloc(nimages, sizeof(int));
    boxsize = (int *) calloc(nimages, sizeof(int));
    xboxnum = (int *) calloc(nimages, sizeof(int));
    yboxnum = (int *) calloc(nimages, sizeof(int));
    maxboxno = (int *) calloc(nimages, sizeof(int));
    listnum = (int **) calloc(nimages, sizeof(int *));
    no_psf = (short int *) calloc(nimages, sizeof(short int));
    npass = (unsigned int *) calloc(nimages, sizeof(unsigned int));
    nfail = (unsigned int *) calloc(nimages, sizeof(unsigned int));
    psfgal = (double *) calloc(nimages, sizeof(double));
    psfgalsq = (double *) calloc(nimages, sizeof(double));
    psfgaln = (double *) calloc(nimages, sizeof(double));

    meme += (float) nimages *8 * sizeof(int);
    meme += (float) nimages *sizeof(short int);
    meme += (float) nimages *2 * sizeof(int *);
    meme += (float) nimages *2. * sizeof(double);

    /*
     * allocate memory for image stacks 
     */
    rawcat = (catstruct **) calloc(nimages, sizeof(catstruct *));
    rawfield = (fieldstruct **) calloc(nimages, sizeof(fieldstruct *));
    wcs_raw = (wcsstruct **) calloc(nimages, sizeof(wcsstruct *));
    meme += (float) nimages *sizeof(catstruct *);
    meme += (float) nimages *sizeof(fieldstruct *);
    meme += (float) nimages *sizeof(wcsstruct *);

    /*
     * memory for filename pointers 
     */
    imageweightname = (char **) calloc(nimages, sizeof(char *));
    imagename = (char **) calloc(nimages, sizeof(char *));
    headerfile = (char **) calloc(nimages, sizeof(char *));
    meme += (float) nimages *3 * sizeof(char *);

    // memory for image attributes
    imageid = (int *) calloc(nimages, sizeof(int));
    meme += nimages*sizeof(int);
    gain = (float *) calloc(nimages, sizeof(float));
    angle = (float *) calloc(nimages, sizeof(float));
    satlev = (float *) calloc(nimages, sizeof(float));
    rawsatlev = (float *) calloc(nimages, sizeof(float));
    arcperpix = (float *) calloc(nimages, sizeof(float));
    if (angle == NULL || gain == NULL || satlev == NULL || arcperpix == NULL) {
        printf("Memory allocation error for image header info\n");
        exit(EXIT_FAILURE);
    }
    meme += (float) 4 *nimages * sizeof(float);

    forder = -99;               // initialise the fit order to signify this has not yet been set

    if (VERBOSE == 1)
        printf(" PSF information: \n");

    for(j = 0; j < nimages; j++) {
        no_psf[j] = 0;          // this counter tells us whether the image has a valid PSF (=0) or not (=1) 
        // its value will be reset below if PSF is not valid

        /*
         * create filenames 
         */

        imageweightname[j] = (char *) calloc(500, sizeof(char));
        imagename[j] = (char *) calloc(500, sizeof(char));
        headerfile[j] = (char *) calloc(500, sizeof(char));
        meme += (float) 3 *500 * sizeof(char);

        /*
         * get the image weight filename 
         */
        bzero(imageweightname[j], 500);
        if (badpixdir != NULL) {
            // printf(" Path to good/bad pixel images %s \n",badpixdir);
            strcpy(imageweightname[j], badpixdir);
            len = strlen(imageweightname[j]);
            if (strncmp(&imageweightname[j][len - 1], "/", 1) != 0) {
                strncat(imageweightname[j], "/", 1);
                len++;
            }
            len = strlen(image_file[j]);
            strncat(imageweightname[j], image_file[j], len);
        } else {
            strcpy(imageweightname[j], image_file[j]);
        }

        /*
         * strip off end of input image name so that weight suffix can be added 
         */
        if (!(pstr = strrchr(imageweightname[j], *delimiter)))
            pstr = imageweightname[j] + strlen(imageweightname[j]);
        sprintf(pstr, "%s", weight_suffix);

        if (GZIPPED > 0) {
            strcat(imageweightname[j], ".gz");
        }

        /*
         * get the data FITS filename 
         */
        bzero(imagename[j], 500);
        if (dataevariable != NULL) {
            //      printf(" Data path %s \n",dataevariable);
            strcpy(imagename[j], dataevariable);
            len = strlen(imagename[j]);
            if (strncmp(&imagename[j][len - 1], "/", 1) != 0) {
                strncat(imagename[j], "/", 1);
            }
            strcat(imagename[j], image_file[j]);
        } else {
            strcpy(imagename[j], image_file[j]);
        }

        /*
         * by default, look for the head files in the same place as the data files
         * but if the head environment variable is set, use that location instead 
         */


        if (USE_SWARP == 1) {
            /*
             * create headerfile name needed for the swarp code 
             */
            bzero(headerfile[j], 500);
            if (headevariable == NULL && dataevariable != NULL) {
                headevariable = dataevariable;
            }
            if (headevariable != NULL) {
                strcpy(headerfile[j], headevariable);
                len = strlen(headerfile[j]);
                if (strncmp(&headerfile[j][len - 1], "/", 1) != 0) {
                    strncat(headerfile[j], "/", 1);
                }
                strcat(headerfile[j], image_file[j]);
            } else {
                strcpy(headerfile[j], image_file[j]);
            }
            if (!(pstr = strrchr(headerfile[j], *headdelimiter)))
                pstr = headerfile[j] + strlen(headerfile[j]);
            sprintf(pstr, "%s", prefs.head_suffix);
        }

        if (GZIPPED >= 2)
            strcat(imagename[j], ".fits.gz");
        else
            strcat(imagename[j], ".fits");

        dim[j] = (int *) calloc(2, sizeof(int));
        meme += (float) 2 *sizeof(int);

	/*
	if (VERBOSE==1)
	  {
	    printf(" getting image attributes for %s \n",imagename[j]);
	  }
	*/
	    /*
	     * get the data image properties 
	     */
	    if (getimagesize(imagename[j], satname, dim[j], &gain[j],
			     &rawsatlev[j], &arcperpix[j], &angle[j], &badccd[j],
			     &imageid[j], (float) minexposuretime)) {
	      fprintf(stderr, " failed to get image %s \n", imagename[j]);
	      exit(EXIT_FAILURE);
	    }
	    chipnumber[j] = imageid[j];
	    if (chipnumber[j] <= 0 && NCHIPS==1) chipnumber[j]=1;
	    if (chipnumber[j]>NCHIPS || chipnumber[j]<=0)
	      {
		fflush(stdout);
		fprintf(stderr," error handling chip identifier IMAGEID for image %s \n",image_file[j]);
		fprintf(stderr," IMAGEID %d but expected number of chips %d \n",chipnumber[j],NCHIPS);
		exit(EXIT_FAILURE);
	      }
	    

        /*
         * create psf name for this image 
         */
        bzero(psfname, 500);
        if (psfevariable != NULL) {
            strcpy(psfname, psfevariable);
            len = strlen(psfname);
            if (strncmp(&psfname[len - 1], "/", 1) != 0) {
                strncat(psfname, "/", 1);
            }
            if (access(psfname, F_OK) != 0) {
                /*
                 * exit if the PSF directory can't be accessed 
                 */
                printf(" Can't read psf file from %s \n", psfname);
                no_psf[j] = 1;
                exit(EXIT_FAILURE);
            }
            if (GLOBAL_PSF == 0) {
                /*
                 * use individual psf files per chip 
                 */
                strcat(psfname, image_file[j]);
                strcat(psfname, ".psfcoeffs.fits");
            }
        } else {
            if (GLOBAL_PSF == 0) {
                /*
                 * use individual psf files per chip 
                 */
                strcpy(psfname, image_file[j]);
                strcat(psfname, ".psfcoeffs.fits");
            }
        }

        if (GLOBAL_PSF == 0) {
            /*
             * break out of this image loop if no individual PSF file found 
             */
            if (access(psfname, F_OK) != 0) {
                printf(" Can't read psf file from %s \n", psfname);
                no_psf[j] = 1;  // set the PSF flag to "no valid PSF for this image"
                continue;       // skip this image but carry on with program execution on other images
            }

            /*
             * read PSF size and polynomial order for PSF variation, also info on numbers of stars across chip 
             */
            getpsfsize_v5(psfname, &originalpwidth, &originalpheight,
                          &order[j], &ncoeffs, &boxsize[j], &xboxnum[j],
                          &yboxnum[j]);

        } else {
            /*
             * or instead assume global PSF file, work out its name from the image filename 
             */
            strcat(psfname, exposurename[j]);
#ifdef CFHT
            strcat(psfname, ".psfcoeffs.fits");
#else
            strcat(psfname, ".psfcoeffs.fits");
#endif

            // printf(" reading global psf from %s \n",psfname);

            /*
             * if global PSF is specified, check that PSF coefficients for this field exist.
             * if they do not, there is a later check that tests whether the image is flagged
             * as good, if it is but no PSF was found then execution will halt. 
             */
            if (access(psfname, F_OK) != 0) {
                printf(" Can't read psf file from %s \n", psfname);
                no_psf[j] = 1;
                continue;       // skip this image but carry on with program execution on other images      
            }
            // fflush(stdout);

            /*
             * read PSF size and polynomial order etc for global PSF variation  
             */
            /*
             * the keyword read here initialise the scalefactor value (arcsec per pixel) for this image.  
             * Note this isn't ideal, because
             * really we would like the same image scalefactor for all data.  However, the
             * PSFs have been independently fitted to each image, so intrinsically they are
             * different.  The solution adopted here is to set the scalefactor
             * for each image the same as when the PSF code ran, so that the scalefactors
             * for the data and the PSF are exactly matched.  Then, when the models are fitted,
             * this isn't quite right, but as the scalefactors differ only by one percent
             * typically, this will have negligible effect on the model-fitting.  It's more
             * important to make sure PSFs and data are correctly matched 
             */

	    getglobalpsfsizes(psfname, &correctd, &originalpwidth, &originalpheight,
			      &order[j], &chipvariation, &chiporder,
			      &ncoeffs, numstars[j], &nxchip, &nychip,
			      &xchipsampling, &ychipsampling, &big_gap,
			      &hxsize[j], &hysize[j], &psfposerror[j], &scalefactor[j],
			      &sorder, &schipvariation, &schiporder,
			      &sncoeffs);

	    if (psfposerror[j]<=0.)
	      {
		fflush(stdout);
		fprintf(stderr," error reading PSF tolerance keyword TOL from PSF file %s\n",psfname);
		exit(EXIT_FAILURE);
	      }

	    /* check that the distortion correction keyword matches what is specified here */
	    if (CORRECT_DISTORTION == 0)
	      {
		if (correctd != 0)
		  {
		    fflush(stdout);
		    fprintf(stderr," error, PSF file is distortion-corrected, check CORRECT_DISTORTION \n");
		    exit(EXIT_FAILURE);
		  }
	      }
	    else if (CORRECT_DISTORTION == 1)
	      {
		if (correctd != 1)
		  {
		    fflush(stdout);
		    fprintf(stderr," error, PSF file is not distortion-corrected, check CORRECT_DISTORTION \n");
		    exit(EXIT_FAILURE);
		  }
	      }
	    else 
	      {
		if (correctd != 0)
		  {
		    fflush(stdout);
		    fprintf(stderr," error, PSF file is distortion-corrected, check CORRECT_DISTORTION \n");
		    exit(EXIT_FAILURE);
		  }
	      }

            /*
             * (assume survey geometry same for all chips, don't bother checking) 
             */
            // printf(" scalefactor %f \n",scalefactor[j]); fflush(stdout);

            /*
             * check number of chips agrees though 
             */
            if ((int) NCHIPS != nxchip * nychip) {
                fflush(stdout);
                fprintf(stderr,
                        " mismatch in assumed survey geometry and PSF-file geometry\n");
                fprintf(stderr, " %d x %d != %d \n", nxchip, nychip,
                        (int) NCHIPS);
                exit(EXIT_FAILURE);
            }

            /*
             * find number of stars that were used on this chip - if
             * the number is too small then disqualify the image
             */
            if (chipnumber[j] > 0) {
                if (VERBOSE == 1)
                    printf(" exposure %s chip %d number of stars used %d \n",
                           exposurename[j], chipnumber[j],
                           numstars[j][chipnumber[j] - 1]);
                if (numstars[j][chipnumber[j] - 1] < PSF_STAR_LIMIT) {
                    printf
                        (" number of stars %d < %d: too few for PSF in chip %d exposure %s \n",
                         numstars[j][chipnumber[j] - 1], 
			 (int)PSF_STAR_LIMIT,
			 chipnumber[j],
                         exposurename[j]);
                    no_psf[j] = 2;
                    continue;
                }
            }

            xboxnum[j] = yboxnum[j] = 0;

        }

        maxboxno[j] = xboxnum[j] * yboxnum[j];
        if (maxboxno[j] > 0) {
            listnum[j] = (int *) calloc(maxboxno[j], sizeof(int));
            if (listnum[j] == NULL) {
                fprintf(stderr,
                        " error allocating memory for PSF star numbers \n");
                exit(EXIT_FAILURE);
            }
            meme += (float) maxboxno[j] * sizeof(int);
        }
        //printf (" image %d PSF order = %d ncoeffs = %d size = %d x %d \n",j+1,order[j],ncoeffs,originalpwidth,originalpheight);

        //printf (" image %d shifts order = %d ncoeffs = %d \n",j,sorder,sncoeffs);

        /*
         * test if the PSF order has been set already, if not then set
         * things up (forder is -99 initially).
         */
        if (forder < 0) {
            forder = order[j];
            crossterm = 0;

            if (chipvariation == 1)
                printf(" PSF global order %d, chip-dependent order %d\n",
                       forder, chiporder);
            else
                printf(" PSF global order %d \n", forder);

            if (order[j] < 0) {
                crossterm = 1;
                forder = -order[j];
            }

            if (sorder < 0) {
                scrossterm = 1;
                sorder = -sorder;
            } else {
                scrossterm = 0;
            }

            maxncoeffs = ncoeffs > sncoeffs ? ncoeffs : sncoeffs;
            if (maxncoeffs < 6)
                maxncoeffs = 6;

            for(nt = 0; nt < NUM_THREAD; nt++) {
	      avals[nt] = (double*)ml_calloc((1+maxncoeffs), sizeof(double), &meme, "avals[nt]");
	      w[nt] = (double*)ml_calloc((1+maxncoeffs), sizeof(double), &meme, "w[nt]");
	      u[nt] = (double **)ml_calloc((1 + maxncoeffs), sizeof(double*), &meme, "u[nt]");
	      v[nt] = (double **)ml_calloc((1 + maxncoeffs), sizeof(double *), &meme, "v[nt][i]");
	      for(i = 0; i <= maxncoeffs; i++) {
		u[nt][i] = (double *)ml_calloc((1 + maxncoeffs), sizeof(double), &meme, "u[nt][i]");
		v[nt][i] = (double *)ml_calloc((1 + maxncoeffs), sizeof(double), &meme, "v[nt][i]");
	      }
            }
        } else {
            if (ncoeffs > maxncoeffs) {
                fprintf(stderr,
                        " error: image %d fit order larger than assumed for previous images \n",
                        j);
                fprintf(stderr, " and fit order larger than 2 \n");
                exit(EXIT_FAILURE);
            }
        }

        /*
         * change the size of the postage stamp arrays to whatever we want 
         */

        pwidth = originalpwidth;
        pheight = originalpheight;

	if (postage_stamp_size > pwidth)
	  {
	    pwidth = postage_stamp_size;
            if (psfwarning == 0) 
	      {
                printf
		  (" WARNING all postage stamps will be reset from %d to %d in size \n",
		   originalpwidth, pwidth);
                psfwarning = 1;
	      }
	  }
	else
	  {
	    postage_stamp_size = pwidth;
	    if (psfwarning == 0)
	      {
		printf(" PSF postage stamp size %d will be used \n",pwidth);
		psfwarning = 1;
	      }
	  }
        if (pheight < postage_stamp_size) 
	  {
	    pheight = postage_stamp_size;
	  }

	// allocate memory for fit arrays
	for(nt = 0; nt < NUM_THREAD; nt++) 
	  {
	    chisq[nt] = (double *)ml_calloc(pwidth * pheight, sizeof(double), &meme, "chisq");
	    xfit[nt] = (double *)ml_calloc(pwidth * pheight, sizeof(double), &meme, "xfit");
	    yfit[nt] = (double *)ml_calloc(pwidth * pheight, sizeof(double), &meme, "yfit");
	    zfit[nt] = (double *)ml_calloc(pwidth * pheight, sizeof(double), &meme, "zfit");
	    wfit[nt] = (double *)ml_calloc(pwidth * pheight, sizeof(double), &meme, "wfit");
	  }

        /*
         * allocate coefficients memory 
         */
        acoeffs[j] = (double **) calloc((pwidth * pheight), sizeof(double *));
        if (acoeffs[j] == NULL) {
            printf("Memory allocation error for coefficient pointers\n");
            exit(EXIT_FAILURE);
        }
        meme += (float) pwidth *pheight * sizeof(double *);

        for(i = 0; i < (pwidth * pheight); i++) {
            acoeffs[j][i] = (double *) calloc((ncoeffs), sizeof(double));
            if (acoeffs[j][i] == NULL) {
                printf("Memory allocation error for coefficients \n");
                exit(EXIT_FAILURE);
            }
            meme += (float) (ncoeffs) * sizeof(double);
        }

        xcoeffs[j] = (double *) calloc(sncoeffs, sizeof(double));
        if (xcoeffs[j] == NULL) {
            printf("Memory allocation error for coefficients \n");
            exit(EXIT_FAILURE);
        }
        meme += (float) (sncoeffs) * sizeof(double);

        ycoeffs[j] = (double *) calloc(sncoeffs, sizeof(double));
        if (ycoeffs[j] == NULL) {
            printf("Memory allocation error for coefficients \n");
            exit(EXIT_FAILURE);
        }
        meme += (float) (sncoeffs) * sizeof(double);

        /*
         * read PSF coefficients 
         */
	getglobalcoeffs(psfname, acoeffs[j], pwidth, pheight,
			originalpwidth, originalpheight, ncoeffs,
			sncoeffs, xcoeffs[j], ycoeffs[j]);
            /*
             * for (i=0; i<sncoeffs; i++)
             * printf (" shift coeff %d %lf %lf \n",i,xcoeffs[j][i],ycoeffs[j][i]);
             */

    }

    if (psfwarning == 0)
        printf(" postage stamp size = %d x %d pixels\n", pwidth, pheight);

    for(nt = 0; nt < NUM_THREAD; nt++) {
        psf[nt] = (double *) fftw_malloc(pwidth * pheight * sizeof(double));
        if (psf[nt] == NULL) {
            fprintf(stderr,
                    " failed to allocate memory for an individual psf \n");
            exit(EXIT_FAILURE);
        }
        meme += (float) pwidth *pheight * sizeof(double);
    }

    /*
     * set some more dimensions  
     */

    /*
     * position prior error - galaxy fits with centroids further away than this in
     * pixels from the postagestamp centre will be disqualified 
     */
    poserror = 4.0;
    /*
     * useful values when dealing with the postage stamps 
     */
    halfpwidth = pwidth / 2 + 1;  // NB addition of unity to this dimension for fftw arrays
    halfpheight = pheight / 2;
    psfsize = pheight * halfpwidth;
    fsize = (double) (pheight * pwidth);
    expandedwidth = 1+pwidth;
    expandedheight = 1+pheight;

  /************************************************************/
  /* set the sampling of the size-ellipticity parameter space
     and galaxy model parameters.
     scale-lengths are defined as semi-major axis 
     The prior in scalelength is defined as a Rayleigh distribution
     and the sampling in r is linear */ 
    numR = 1000;  /* maximum number of steps in galaxy scalelength incl star profile (will be updated below) */
    //Rmax = 5.0; /* maximum galaxy scalelength (pixels) */
    Rmin = 0.3; /* minimum galaxy scalelength (pixels) */
    /* galaxy model truncation radius (scalelengths) based on van der Kruit & Searle (1981)
       and subsequent papers */
    Rcutoff = 4.5;
    /* disk extinction coefficent used in make3Dgalaxymodel, chosen to match
       Unterborn & Ryden (2008) dependence of galaxy luminosity on inclination */
    kappaval = 0.; 
    /* axial ratio of assumed prolate ellipsoid for the bulge component of 3D bulges */
    beta0 = 0.3; 
    /* inverse Sersic index 1/n - MUST be 0.25 (n=4) or 0.5 (n=2)*/
    Sindex = 0.25;
    /* ratio of bulge half-light radius to disk scalelength */
    bscalefactor = 1.0;
    /* index of Moffat profile (must be >2) */
    moffatbeta = 4.;
    /* peak value of gaussian prior for bulge-fraction */
    bfpeakval = 0.0;
    /* sigma of gaussian prior for bulge-fraction (e.g. CFRS, Simard et al) */
    bfsigma = 0.1;
    /* fraction of pure bulge-only galaxies */
    bulgepopfrac = 0.1;
    /* logarithmic slope of galaxy flux prior, flatter than euclidean (e.g. Gabasch et al 2008) */
    fluxpriorslope = 2.0; 
    // ellipticity plane sampling parameters:
    e_interval = 0.02;  /*  finest allowable sampling in e1, e2  */
    coarse_e_sampling = 0.16;  /* coarsest allowed sampling in e1, e2 */ 
    minsamplepoints = 20;  /* target number of points in (e1, e2) in final measurement */
    /************************************************************/

    printf("\n Fitting information:\n");

    if (APPLY_GLOBALSHIFTS == 1)
      {
	printf(" applying global shifts\n");
      }
    else
      {
	printf(" WARNING: not applying global shifts\n");
      }

    if (DEBLENDING_REJECTION == 1)
      {
	printf(" rejecting blended and oversized galaxies\n");
	printf(" but not applying any cut on cut-squared of best fit\n");
      }
    else
      {
	printf(" not rejecting blended and oversized galaxies\n");
	if (REJECT_BAD == 1)
	  {
	    printf(" but excluding bad-chi-squared fits\n");
	    printf(" do not use these results for cosmic shear measurement!\n");
	  }
      }

    if (subtract_background==1)
      printf(" subtracting linear background from postage stamps\n");
    else 
      printf(" NOT subtracting linear background from postage stamps\n");

    printf(" Ellipticity posterior cut %4.2f and likelihood threshold cut %4.2f\n", Pcut, Lcut);

    if (MODELS_3D==1)
      {
	printf(" using 3D galaxy models with beta0 = %f\n",beta0);
      }
    else
      {
	printf(" using 2D galaxy models \n");
	printf(" pure exponential disks \n");
	// printf(" with Graham & Worley rest-frame V-band extinction correction\n");
	//printf(" including correction of scalelengths \n");
	printf(" bulge Sersic index n = %3.1f \n",1./Sindex);
      }
    printf(" bulge scale factor = %f \n",bscalefactor);
    printf(" bulge fraction prior parameters: %f %f %f \n",bfpeakval,bfsigma,bulgepopfrac);
    printf(" using SDSS g-band ellipticity fit for disk prior \n");
#ifdef RBAND
    printf(" using r band for scalelength prior\n");
#else 
 #ifdef IBAND
    printf(" using i band for scalelength prior\n");
 #else
    fflush(stdout);
    fprintf(stderr," band not correctly set for scalelength prior\n");
    exit(EXIT_FAILURE);
 #endif
#endif

    /* 
     * set the parameter values for the ellipticity prior as evaluated
     * in efunc and efuncderiv.
     * This parameterisation matches the apparent axis ratio distribution
     * of SDSS disk galaxies by Unterborn & Ryden 2008.
     */
    // disk prior parameters from fits to Unterborn & Ryden 2008
    //efunc_a = 0.0183;    // intrinsic ellipticity term
    //efunc_emax = 0.767;  // cut-off ellipticity 
    //efunc_sigma = 0.651; // cut-off sigma term
    // disk prior parameters from fits to downloaded SDSS DR7 g-band galaxies
    // with M_g < -19
    efunc_a = 0.0256;    // intrinsic ellipticity term
    efunc_emax = 0.804;  // cut-off ellipticity 
    efunc_sigma = 0.2539; // cut-off sigma term
    // bulge prior parameters from fits to Simard et al 2002 
    bulgefunc_b = 2.3677769;
    bulgefunc_c = 6.6907854;
    // maximum calculated ratio of disk a/b
    diskratio = (1.+efunc_emax)/(1.-efunc_emax);

    /*
     * set up a grid of points in (e1, e2)
     *
     * find the maximum limit on the range of e investigated
     *  given the disk model parameters.  Also compare with
     * the values given for the prior in efunc.  
     *
     */
    if (MODELS_3D == 1)
      {
	cosi = 0.;
	nt = 0;
	galaxy_ellipticity(nt,cosi,modelelimit);
	max_eta = modelelimit[0]; 
	max_aob = (1.+max_eta)/(1.-max_eta);
      }
    else
      {
	max_aob = diskratio;  
	max_eta = (max_aob-1.)/(max_aob+1.);
	//max_eta = 0.95;
	//max_aob = (1.+max_eta)/(1.-max_eta);
      }
    // add a guard region to help with poor samping near edge
    max_eta += coarse_e_sampling/2.;
    // check the guard region hasn't extended too far
    if (max_eta >= 0.95) max_eta = 0.95;
    // square for speed: this is the quantity actually tested against in loops
    max_etasq = max_eta * max_eta;

    printf(" maximum axial ratio %f and maximum ellipticity %f \n", max_aob,max_eta);
    printf(" finest ellipticity sampling %f \n", e_interval);

    /*
     * model postage stamp size.  Models are initally created oversampled by some factor
     * and then downsampled in an attempt to get the flux  in the central pixels correct.
     * Choose a scaling so that the semi-minor axis is oversampled when the semi-major
     * axis has been chosen to fit inside the array (this scaling is done in make3Dgalaxymodel)
     */
    msf = 1 + 2*((int)(12.*max_aob*Rcutoff/pwidth)/2);  // must be an odd integer multiplier
    if (MODEL_OVERSAMPLING ==  0) msf = 1;
    mheight = msf * pheight;
    mwidth = msf * pwidth;
    halfmwidth = 1 + mwidth/2;
    printf(" model array expansion factor %d \n", msf);
    mfsize = (double)mheight * (double)mwidth;


    /*
     * allocate memory for cross-correlation and other arrays 
     */
    for(nt = 0; nt < NUM_THREAD; nt++) {
      C[nt] = (fftw_complex**)fftw_malloc(2*sizeof(fftw_complex*));
        if (C[nt] == NULL) {
            printf("Memory allocation error for cross-correlation C array\n");
            exit(EXIT_FAILURE);
        }
        meme += (float) 2. *sizeof(fftw_complex*);
        for(j = 0; j < 2; j++) 
	  {
	    C[nt][j] = (fftw_complex*)fftw_malloc(halfpwidth*pheight*sizeof(fftw_complex));
	    if (C[nt][j] == NULL) {
	      printf("Memory allocation error for cross-correlation C[nt][j] array\n");
	      exit(EXIT_FAILURE);
	    }
	    meme += (float) halfpwidth *pheight * sizeof(fftw_complex);
	  }

	CC[nt] = (fftw_complex**)fftw_malloc(2*sizeof(fftw_complex*));
        if (CC[nt] == NULL) {
            printf("Memory allocation error for cross-correlation CC array\n");
            exit(EXIT_FAILURE);
        }
        meme += (float) 2. *sizeof(fftw_complex*);
        for(j = 0; j < 2; j++) 
	  {
	    CC[nt][j] = (fftw_complex*)fftw_malloc(halfpwidth*pheight*sizeof(fftw_complex));
	    if (CC[nt][j] == NULL) {
	      printf("Memory allocation error for cross-correlation CC[nt][j] array\n");
	      exit(EXIT_FAILURE);
	    }
	    meme += (float) halfpwidth *pheight * sizeof(fftw_complex);
	  }

        c[nt] = (double **) fftw_malloc(2 * sizeof(double *));
        if (c[nt] == NULL) {
            printf("Memory allocation error for cross-correlation c array\n");
            exit(EXIT_FAILURE);
        }
        meme += (float) 2. *sizeof(double *);
        for(j = 0; j < 2; j++) {
            c[nt][j] =
                (double *) fftw_malloc(pwidth * pheight * sizeof(double));
            if (c[nt][j] == NULL) {
                printf
                    ("Memory allocation error for cross-correlation c array\n");
                exit(EXIT_FAILURE);
            }
            meme += (float) pwidth *pheight * sizeof(double);
        }

        objpix[nt] = ml_calloc((1 + pwidth * pheight), sizeof(int), &meme, "objpix");
        objnum[nt] = ml_calloc((1 + pwidth*pheight), sizeof(int), &meme, "objnum");
        colour[nt] = ml_calloc((pwidth*pheight), sizeof(int), &meme, "colour");
        connected[nt] = (int **)ml_calloc((pwidth*pheight), sizeof(int *), &meme, "connected");
        for(i = 0; i < (pwidth * pheight); i++) {
	  connected[nt][i] = (int *)ml_calloc(2, sizeof(int), &meme, "connected[i]");
        }
        sn[nt] = (double *) calloc((pwidth * pheight), sizeof(double));
        if (sn[nt] == NULL) {
            printf("Memory allocation error for sn\n");
            exit(EXIT_FAILURE);
        }
        meme += (float) pwidth *pheight * sizeof(double);
        sw[nt] = (double *) calloc((pwidth * pheight), sizeof(double));
        if (sw[nt] == NULL) {
            printf("Memory allocation error for sw\n");
            exit(EXIT_FAILURE);
        }
        meme += (float) pwidth *pheight * sizeof(double);
        sn1[nt] = (double *) calloc((pwidth * pheight), sizeof(double));
        if (sn1[nt] == NULL) {
            printf("Memory allocation error for sn1\n");
            exit(EXIT_FAILURE);
        }
        meme += (float) pwidth *pheight * sizeof(double);
        sw1[nt] = (double *) calloc((pwidth * pheight), sizeof(double));
        if (sw1[nt] == NULL) {
            printf("Memory allocation error for sw1\n");
            exit(EXIT_FAILURE);
        }
        meme += (float) pwidth *pheight * sizeof(double);
        nimweight[nt] = (float *) calloc(nmaximages, sizeof(float));
        if (nimweight[nt] == NULL) {
            printf("Memory allocation error for nimweight values \n");
            exit(EXIT_FAILURE);
        }
        meme += (float) nmaximages *sizeof(float);
        dbadpix[nt] = (double *) calloc((pwidth * pheight), sizeof(double));
        if (dbadpix[nt] == NULL) {
            printf("Memory allocation error for sub-image \n");
            exit(EXIT_FAILURE);
        }
        temp[nt] = (float *) calloc((pwidth * pheight), sizeof(float));
        if (temp[nt] == NULL) {
            printf("Memory allocation error for temporary image\n");
            exit(EXIT_FAILURE);
        }
        badtemp[nt] = (float *) calloc((pwidth * pheight), sizeof(float));
        if (badtemp[nt] == NULL) {
            printf("Memory allocation error for temporary image\n");
            exit(EXIT_FAILURE);
        }
        meme += (float) pwidth *pheight * sizeof(float);
        psfevals[nt] = (double **) calloc(nmaximages, sizeof(double *));
        if (psfevals[nt] == NULL) {
            printf("Memory allocation error for psfevals\n");
            exit(EXIT_FAILURE);
        }
        meme += (float) nmaximages *sizeof(double *);
        for(i = 0; i < nmaximages; i++) {
            psfevals[nt][i] = (double *) calloc(2, sizeof(double));
            if (psfevals[nt][i] == NULL) {
                printf("Memory allocation error for psfevals\n");
                exit(EXIT_FAILURE);
            }
            meme += (float) 2 *sizeof(double);
        }
    }


    noise = (float *) calloc(nimages, sizeof(float));
    if (noise == NULL) {
        printf("Memory allocation error for noise values \n");
        exit(EXIT_FAILURE);
    }
    meme += (float) nimages *sizeof(float);

    weight = (float *) calloc(nimages, sizeof(float));
    if (weight == NULL) {
        printf("Memory allocation error for weight values \n");
        exit(EXIT_FAILURE);
    }
    meme += (float) nimages *sizeof(float);

    meme += NUM_THREAD * (float) nmaximages *sizeof(float);

    /*
     * read possible angle at which the field is rotated
     */
    /*
     * all split fields must be rotated by same angle 
     */
    /*
     * NB if CORRECT_DISTORTION is set, all rotations are automatically corrected 
     */
    phi = 0.;
    phiset = 0;
    if (CORRECT_DISTORTION >= 1)
        phiset = 1;
    /*
     * if (argc == 9) 
     * {
     * phiset=1;
     * if (CORRECT_DISTORTION==1)
     * {
     * printf (" warning, swarp will correct all image rotations automatically, angle ignored \n");
     * }
     * else
     * {
     * phi=(float)atoi(argv[8]);
     * phi=phi*pi/180.;
     * }
     * }
     */

    // get limiting magnitudes (both bright and faint limits must be specified)
    blim = 0.;
    flim = 1000.;
    if (argc >= 8)
      {
        blim = (float) atof(argv[6]);
        flim = (float) atof(argv[7]);
      }

    /*
     * get start and end obejcts to be read from catalogue, from command-line (optional) 
     * startobj=1;
     * endobj=0;
     * if (argc >= 8)
     * {
     * startobj = (int)atoi(argv[6]);
     * endobj = (int)atoi(argv[7]);
     * }
     */

/*  create output FITS file  */

    if (NITER == 1) {
        strcpy(ofile, argv[2]);
        fits_create_file(&ofptr[0], ofile, &status);

        if (status) {
	  fflush(stdout);
	  fprintf(stderr, " error creating output FITS table \n");
	  fits_report_error(stderr, status);  /*  print error message  */
	  exit(EXIT_FAILURE);
        }
    } else {
        for(i = 0; i < NITER; i++) {
            status = 0;
            strcpy(ofile, argv[2]);
            sprintf(string, ".%d.fits", i);
            strncat(ofile, string, 7);

            fits_create_file(&ofptr[i], ofile, &status);

            if (status) {
	      fflush(stdout);
                fprintf(stderr, " error creating output FITS table \n");
                fits_report_error(stderr, status);      /*  print error message  */
                exit(EXIT_FAILURE);
            }
        }
    }

    if (VERBOSE == 1) {
        if (WCS == 1) {
            printf(" input catalogue positions are WCS\n");
        } else {
            printf
                (" input catalogue positions are pixel coordinates on each chip\n");
        }
    }

    /*
    if (dataevariable != NULL)
        printf(" data path %s \n", dataevariable);
    if (headevariable != NULL)
        printf(" path to head files %s \n", headevariable);
    if (badpixdir != NULL)
        printf(" path to good/bad pixel images %s \n", badpixdir);
    */

/* read the input catalogue */

    i = 0;
    if (catevariable != NULL) {
        strcpy(catname, catevariable);
    }

    if (access(catname, F_OK) != 0) {
        printf(" Can't read object file %s \n", catname);
        exit(EXIT_FAILURE);
    }

    // break catalogue path into strings suitable for the FITS header 
    startp = catname;
    nstringcat = 0;
    len0 = strlen(catname);
    printf(" catname keyword string\n");
    slen = (int)FLEN_VALUE-3;
    while (len0>0)
      {
	bzero(keywordfile[nstringcat],slen);
	len = strlen(startp);
	if (len>slen) len=slen;
	strncat(keywordfile[nstringcat],startp,len);
	len0 -= slen;
	startp += slen;
	printf("%s\n", keywordfile[nstringcat]);
	nstringcat++;
      }

    /*
     * read catalogue of objects  
     */

    ngals[i] = readgalcatsize(catname);
    if (ngals[i] != ngals[0]) {
        fprintf(stderr,
                " numbers of galaxies in input catalogues do not agree \n");
        exit(EXIT_FAILURE);
    }

    if (VERBOSE == 1)
        printf(" %d objects in catalogue %s \n", ngals[i], catname);
    fflush(stdout);

    /*
     * now we know how many are in catalogue, fix the start and end numbers 
     */
    nobj = ngals[0];
    if (endobj < startobj) {
        startobj = 1;
        endobj = nobj;
    }
    if (startobj < 1)
        startobj = 1;
    if (endobj > nobj)
        endobj = nobj;
    nobj = (endobj - startobj + 1);

    /*
     * allocate memory for object positions (x,y in pixels, wcs in world coordinates) 
     */
    for(i = 0; i < nimages; i++) {
        objx[i] = (float *) calloc(nobj, sizeof(float));
        objy[i] = (float *) calloc(nobj, sizeof(float));
        if (objx[i] == NULL || objy[i] == NULL) {
            fprintf(stderr,
                    " memory allocation error for galaxies catalogue \n");
            exit(EXIT_FAILURE);
        }
        meme += (float) 2 *nobj * sizeof(float);
    }

    // distortion measures
    edist = (double***)calloc(nobj, sizeof(double**));
    if (edist==NULL)
      {
	fprintf(stderr," memory allocation error for distortion parameters \n");
	exit(EXIT_FAILURE);
      }
    meme += (float)nobj*sizeof(double**);
    for (j=0; j<nobj; j++)
      {
	  edist[j] = (double**)calloc(nmaximages, sizeof(double*));
	  if (edist[j]==NULL)
	    {
	      fprintf(stderr," memory allocation error for distortion parameters \n");
	      exit(EXIT_FAILURE);
	    }
	  meme += (float)nmaximages*sizeof(double*);
	  for (i=0; i<nmaximages; i++)
	    {
	      edist[j][i] = (double*)calloc(4, sizeof(double));
	      if (edist[j][i]==NULL)
		{
		  fprintf(stderr," memory allocation error for distortion parameters \n");
		  exit(EXIT_FAILURE);
		}
	      meme += 4.*sizeof(double);
	    }
      }
    
    wcsx = (double *) calloc(nobj, sizeof(double));
    wcsy = (double *) calloc(nobj, sizeof(double));
    catmag = (float *) calloc(nobj, sizeof(float));
    catid = (int *) calloc(nobj, sizeof(int));
    smag = (float *) calloc(nobj, sizeof(float));
    fprob = (double *) calloc(nobj, sizeof(double));
    rmar = (double *) calloc(nobj, sizeof(double));
    fitclass = (int *) calloc(nobj, sizeof(int));
    noiseperpixel = (double *) calloc(nobj, sizeof(double));
    snratio = (double *) calloc(nobj, sizeof(double));
    meme +=
        (float) nobj *(2 * sizeof(float) + 5. * sizeof(double) + 2.*sizeof(int));
    for(magbin = 0; magbin < nmagbins; magbin++) {
        magarray[magbin] = (float *) calloc(nobj, sizeof(float));
        meme += (float) nobj *sizeof(float);
        nmagarray[magbin] = 0;
    }
    if (wcsx == NULL || wcsy == NULL || catmag == NULL || catid == NULL
        || noiseperpixel == NULL || fprob == NULL
        || fitclass == NULL || smag == NULL || snratio == NULL) {
        fprintf(stderr, " error allocating memory for wcsx etc \n");
        exit(EXIT_FAILURE);
    }

    nobj2 =
        readludocat_dec2010(catname, ncatimages, NCHIPS, startobj, endobj, startexp,
                     endexp, wcsx, wcsy, objx, objy, catmag, catid);

    // test that catalogue magnitudes are in a sensible range
    catminmag = 100.;
    catmaxmag = 0.;
    for (j=0; j<nobj2; j++)
      {
	if (catmag[j]<5. || catmag[j]>100. || catid[j]<0 || catid[j]>1000000)
	  {
	    fflush(stdout);
	    fprintf(stderr," error: catalogue magnitude out of range or catalogue format error\n");
	    fprintf(stderr," object %d ID %d mag %f \n",j+1,catid[j],catmag[j]);
	    fprintf(stderr," check that catalogue format is correct \n");
	    fprintf(stderr," should be RA, dec, magnitude, ID-number \n");
	    exit(EXIT_FAILURE);
	  }
	if (catmag[j]<catminmag) catminmag = catmag[j];
	if (catmag[j]>catmaxmag) catmaxmag = catmag[j];
      }

    if (WCS != 1) {
        printf(" catalogue test for first few objects: \n");
        for(j = 0; j < 10 && j < nobj2; j++) {
            printf(" object %d %lf %lf \n", j, wcsx[j], wcsy[j]);
            for(i = 0; i < nimages; i++) {
                if (objx[i][j] > -999.) {
                    printf(" %s %f %f \n", image_file[i], objx[i][j],
                           objy[i][j]);
                }
            }
        }
    }

    if (nobj2 != nobj) {
        printf(" error reading catalogue \n");
        printf(" number requested = %d, number read = %d \n", nobj, nobj2);
        exit(EXIT_FAILURE);
    }

    if (nobj > 0) {
        printf(" %d objects read from galaxy catalogue %s \n", nobj, catname);
        printf(" %d <= n <= %d \n", startobj, endobj);
        /*
         * for (j=0; j<nobj; j++) printf (" %f %f \n",objx[i][j],objy[i][j]); 
         */
    } else {
        printf(" no objects found in galaxy catalogue %s \n", catname);
        exit(EXIT_FAILURE);
    }

    if (argc>=8)
      printf(" command-line magnitude limits %6.3f < m < %6.3f \n",blim,flim);

    printf(" range of galaxies magnitudes found in catalogue: %6.3f < m < %6.3f \n",catminmag,catmaxmag);

    fflush(stdout);

    // evaluate largest galaxy models that will be needed
    if (catminmag < blim) 
      catminmag = blim;
    aval = exp(afit[0] + afit[1]*(catminmag-refmag))/1.134;
    rval = pow(0.75,0.75) * aval;
    // find approx (larger) size at which prior has fallen to 20 percent of the maximum
    pmax = rfunc(rval,catminmag);
    while (rfunc(rval,catminmag) > pmax-1.609) {rval *= 1.05;}
    Rmax = rval/defaultmeanscalefactor;
    printf(" largest galaxy size required is %f pixels at bright magnitude limit %f\n",Rmax,catminmag);

    // if galaxies are too large, change the bright magnitude limit until they fit
    /*
    if (Rcutoff*Rmax > pwidth/2) 
      {
	printf(" models overfill postage stamps by factor %f \n",2*Rcutoff*Rmax/pwidth);
	catminmag = ((int)(10.*catminmag))/10.;
	while (Rcutoff*Rmax > pwidth/2)
	  {
	    catminmag += 0.1;
	    aval = exp(afit[0] + afit[1]*(catminmag-refmag))/1.134;
	    rval = pow(0.75,0.75) * aval;
	    pmax = rfunc(rval,catminmag);
	    while (rfunc(rval,catminmag) > pmax-1.609) {rval *= 1.05;}
	    Rmax = rval/defaultmeanscalefactor;
	  }
	blim = catminmag;
	printf ("WARNING: bright galaxy limit has been reset to %6.3f \n",catminmag);
	fflush(stdout);
      }    
    */

    if (blim >= flim)
      {
	fflush(stdout);
	fprintf(stderr,"ERROR: bright galaxy limit has been set to value larger than specified faint galaxy limit! \n");
	fprintf(stderr,"choose different magnitude range or postage stamp size \n");
	exit(EXIT_FAILURE);
      }

    // evaluate smallest galaxy models that will be needed
    if (catmaxmag > flim) catmaxmag = flim;
    aval = exp(afit[0] + afit[1]*(catmaxmag-refmag))/1.134;
    rval = pow(0.75,0.75) * aval;
    if (rval/defaultmeanscalefactor < 0.5)
      {
	printf(" warning: galaxies at magnitude %6.3f will have typical scalelengths < 0.5 pixels \n",catmaxmag);
	fflush(stdout);
      }
    // find approx size at which prior has fallen to 10 percent of the maximum
    pmax = rfunc(rval,catmaxmag);
    while (rfunc(rval,catmaxmag) > pmax-2.3) {rval *= 0.95;}
    // set smallest model scalelength only if larger than default value of Rmin
    if (rval/defaultmeanscalefactor > Rmin)
      {
	Rmin = rval/defaultmeanscalefactor;
      }
    else
      {
	printf(" warning: galaxies at faint magnitudes may be smaller than can be measured with these images\n");
      }

    /*
     * define steps in galaxy scale-length, Ro using initial default size of array
     */
    Ro = (double *) calloc(numR, sizeof(double));
    if (Ro == NULL) {
        fprintf(stderr, " memory allocation error for Ro \n");
        exit(EXIT_FAILURE);
    }
    meme += (float) numR *sizeof(double);

    // stellar model
    Ro[0] = 0.;

    /* define steps in galaxy scale-length, Ro IN PIXELS */
    /*
    Ro[1] = Rmin;
    nRo=2;
    while (nRo<numR && Ro[nRo-1] < Rmax)
      {
	// quadratic spacing of samples

	// time trialling for size

	//A Biuse suggestion not enough memory so trying this instead
	//	Rinterval = 0.02 + 0.05*pow( ((Ro[nRo-1]-Rmin)/(Rmax-Rmin)), 2. ); // 
	//B  
	//	Rinterval = 0.01 + 0.4*pow( ((Ro[nRo-1]-Rmin)/(Rmax-Rmin)), 2. );
	//C
	//	  	Rinterval = 0.01 + 0.2*pow( ((Ro[nRo-1]-Rmin)/(Rmax-Rmin)), 2. );
	//D - original choice used for CFHTLenS
	 Rinterval = 0.08 + 0.4*pow( ((Ro[nRo-1]-Rmin)/(Rmax-Rmin)), 2. );
	 Ro[nRo] = Ro[nRo-1] + Rinterval;
	 nRo++;
      }
    numR = nRo;
    if (Ro[nRo-1]>Rmax) Rmax=Ro[nRo-1];
    printf(" %d samples in galaxy scale-length, %f < r0 < %f pixels \n",numR-1,Rmin,Rmax);
    */

    /*
     * define steps in galaxy scale-length, Ro using initial default size of array
     */
    //Rinterval = 0.05;
    //Rinterval = 0.1;
    //numR = 1 + (int)((Rmax-Rmin)/Rinterval);

    numR = 60;

    if (numR > 1000)
      {
	fflush(stdout);
	fprintf(stderr," ERROR: too many models needed in galaxy scalelength: \n");
	fprintf(stderr," reduce the galaxy magnitude range \n");
	exit(EXIT_FAILURE);
      }

    Ro = (double *)ml_calloc(numR, sizeof(double), &meme, "Ro");
    // stellar model
    Ro[0] = 0.;

    /* define steps in galaxy scale-length, Ro IN PIXELS */
    // define steps in R squared
    Rinterval = (sqrt(Rmax)-sqrt(Rmin))/(numR-2);

    for (nRo = 1; nRo < numR; nRo++)
      {
	Ro[nRo] = pow( sqrt(Rmin) + (nRo-1)*Rinterval, 2 );
      }
    Rmax = Ro[numR-1];
    printf(" %d samples at quadratic intervals in galaxy scale-length, %f < r0 < %f pixels \n",numR-1,Rmin,Rmax);

    printf(" adopted model scalelengths (/pixels): \n");
    for(nRo = 1; nRo < numR; nRo++)
      printf(" n %d Ro %f \n", nRo, Ro[nRo]);
    
    // printf(" using CFHT-bootstrapped size prior\n");
    printf(" using Simard et al size prior with exponent 4/3 \n");

    i = 0;
    numstar = 0;
    strcpy(starcat_file[i], "none");

    /*
     * if (strncmp(starcat_file[i],"none",4)!=0) {
     * 
     * if (catevariable!=NULL)
     * {
     * strcpy(starcatname,catevariable);
     * len = strlen(starcatname);
     * if (strncmp(&starcatname[len-1],"/",1)!=0)
     * {
     * strncat(starcatname,"/",1);
     * }
     * len = strlen(starcat_file[i]);
     * strncat(starcatname,starcat_file[i],len);
     * }
     * else
     * {
     * strcpy(starcatname,starcat_file[i]);
     * }
     * 
     * if (access(starcatname,F_OK) != 0)
     * {
     * printf (" *** can't read object file %s \n",starcatname);
     * numstar = 0;
     * printf (" continuing \n");
     * }
     * else
     * {
     * numst[i] = readpsfcatsize(starcatname);
     * if (numst[i] != numst[0]) {
     * fprintf(stderr," numbers of stars disagree \n");
     * exit(EXIT_FAILURE);
     * }
     * 
     * numstar = numst[0];
     * 
     * starx[i]   = (float *)calloc(numstar+1, sizeof(float));
     * stary[i]   = (float *)calloc(numstar+1, sizeof(float));
     * starmag[i] = (float *)calloc(numstar+1, sizeof(float));  
     * if (starx[i]==NULL || stary[i]==NULL || starmag[i]==NULL)
     * {
     * fprintf(stderr," memory allocation error for stars catalogue \n");
     * exit(EXIT_FAILURE);
     * }
     * meme += 3.*(numstar+1)*sizeof(float);
     * numstar2=readpsfcat(starcatname, starx[i], stary[i], starmag[i]);
     * if (numstar!=numstar2) {
     * printf(" error reading star catalogue \n");
     * printf(" nobj = %d, nobj2 = %d \n", numstar, numstar2); 
     * exit(EXIT_FAILURE);
     * }
     * 
     * if (numstar>0) {
     * printf(" %d stars read from star catalogue %s\n",numstar,starcatname);
     * }
     * else {
     * printf(" *** no objects found in star catalogue %s\n",starcatname);
     * numstar=0;
     * }
     * 
     * }
     * }
     * else
     * {
     * numstar = 0;
     * }
     * 
     */

    /*
     * allocate memory for temporary postage-stamp storage and postage stamp pointers  
     */

    nim = (short int *) calloc(nobj, sizeof(short int));
    if (nim == NULL) {
        printf("memory allocation error for number of images, nim \n");
    }
    meme += (float) nobj *sizeof(short int);

    for(nt = 0; nt < NUM_THREAD; nt++) {
        dpix[nt] = (double *) fftw_malloc(pwidth * pheight * sizeof(double));
        if (dpix[nt] == NULL) {
            printf("Memory allocation error for dpix\n");
            exit(EXIT_FAILURE);
        }
        meme += (float) pwidth *pheight * sizeof(double);
    }

    datasq = (double **) calloc(nobj, sizeof(double *));
    if (datasq == NULL) {
        printf("memory allocation error for datasq \n");
    }
    meme += (float) nobj *sizeof(double *);
    for(j = 0; j < nobj; j++) {
        datasq[j] = (double *) calloc(nmaximages, sizeof(double));
        if (datasq[j] == NULL) {
            printf("Memory allocation error for datasq[j] \n");
            exit(EXIT_FAILURE);
        }
        meme += (float) nmaximages *sizeof(double);
    }

    /*
     * output arrays for test postage stamps 
     */
    if (NTEST_LIMIT > 0) {
        otestout =
	  (double *) calloc((2 + NTEST_LIMIT)*pwidth*pheight, sizeof(double));
        testimage = (int *) calloc((2 + NTEST_LIMIT), sizeof(int));
        testobj = (int *) calloc((2 + NTEST_LIMIT), sizeof(int));
        meme +=
	  (float) (2 + NTEST_LIMIT) * pwidth * pheight *
            sizeof(double);
        meme += (float) (2 + NTEST_LIMIT) * 2 * sizeof(int);
    }
    meantestout = (double *) calloc(pwidth * pheight, sizeof(double));
    meme += (float) pwidth *pheight * sizeof(double);

    /*
     * this (large) array tells the algorithm which images have been extracted for which
     * object, and where the postage stamp is stored 
     */
    extractedobject = (short int **) calloc(nimages, sizeof(short int *));
    meme += (float) nimages *sizeof(short int *);
    for(j = 0; j < nimages; j++) {
        extractedobject[j] = (short int *) calloc(nobj, sizeof(short int));
        if (extractedobject[j] == NULL) {
            printf("Memory allocation error for extractedobject flag \n");
            exit(EXIT_FAILURE);
        }
        meme += (float) nobj *sizeof(short int);
    }

    numgoodpix =
        (unsigned short int **) calloc(nobj, sizeof(unsigned short int *));
    meme += (float) nobj *sizeof(unsigned short int *);
    for(j = 0; j < nobj; j++) {
        numgoodpix[j] =
            (unsigned short int *) calloc(nmaximages,
                                          sizeof(unsigned short int));
        if (numgoodpix[j] == NULL) {
            printf("Memory allocation error for number of good pixels \n");
            exit(EXIT_FAILURE);
        }
        meme += (float) nmaximages *sizeof(unsigned short int);
    }


    if (WRITE_CHISQ_SURFACES == 1) {
        bestchisq =
            (double *) calloc(nobj * pwidth * pheight, sizeof(double));
        galselected = (int *) calloc(nobj, sizeof(int));
        spos = (double **) calloc(nobj, sizeof(double *));
        for(j = 0; j < nobj; j++)
            spos[j] = (double *) calloc(2, sizeof(double));
    }

    /*
     * allocate memory for FFTW arrays etc 
     */

    for(nt = 0; nt < NUM_THREAD; nt++) {
        B[nt] =
            (fftw_complex **) fftw_malloc(nmaximages *
                                          sizeof(fftw_complex *));
        if (B[nt] == NULL) {
            fprintf(stderr, " failed to allocate memory for psfs \n");
            exit(EXIT_FAILURE);
        }
        meme += (float) nmaximages *sizeof(fftw_complex *);
        for(j = 0; j < nmaximages; j++) {
            B[nt][j] =
                (fftw_complex *) fftw_malloc(psfsize * sizeof(fftw_complex));
            if (B[nt][j] == NULL) {
                fprintf(stderr, " failed to allocate memory for psfs \n");
                exit(EXIT_FAILURE);
            }
            meme += (float) psfsize *sizeof(fftw_complex);
        }

        vals[nt] = (float *) calloc(nmaximages, sizeof(float));
        if (vals[nt] == NULL) {
            printf("Memory allocation error for median array \n");
            exit(EXIT_FAILURE);
        }
        meme += (float) nmaximages *sizeof(float);

        /*
         * flags that tell us whether an object is on-chip or not 
         */
        offscale[nt] = (short int *) calloc(nobj, sizeof(short int));
        if (offscale[nt] == NULL) {
            printf("Memory allocation error for sub-image \n");
            exit(EXIT_FAILURE);
        }
        meme += (float) nobj *sizeof(short int);

        /*
         * pointers for grabbing data postage stamps 
         */
        Dp[nt] =
            (fftw_complex **) fftw_malloc(nmaximages*sizeof(fftw_complex *));
        meme += (float) nmaximages *sizeof(fftw_complex *);

	// pointer to distortion parameters (NB this will be a pointer to a pointer already allocated)
        tdist[nt] =
	  (double **) calloc(nmaximages, sizeof(double *));
        meme += (float) nmaximages *sizeof(double *);
	
	// data-squared values
        datasqp[nt] = (double *) calloc(nmaximages, sizeof(double));
        meme += (float) nmaximages *sizeof(double);

	// check on image shuffling
        checkimage[nt] = (int *) calloc(nmaximages, sizeof(int));
        meme += (float) nmaximages *sizeof(int);

	// expanded model array inside likelihood function
	expandedft[nt] = (double**)calloc(2, sizeof(double*));
	meme += 2.*sizeof(double*);
	if (CORRECT_DISTORTION==2)
	  {
	    for (mt=0; mt<2; mt++)
	      {
		expandedft[nt][mt] = (double*)calloc(expandedheight*expandedwidth, sizeof(double));
		if (expandedft[nt][mt]==NULL)
		  {
		    fflush(stdout);
		    fprintf(stderr," error allocating expandedft[%d][%d]\n",nt,mt);
		    exit(EXIT_FAILURE);
		  }
		meme += (float)expandedheight*expandedwidth*sizeof(double);
	      }
	  }
	// interpolated model array inside likelihood function
	interpft[nt] = (double***)calloc(nmaximages, sizeof(double**));
	meme += (float)nmaximages*sizeof(double**);
	for (i=0; i<nmaximages; i++)
	  {
	    interpft[nt][i] = (double**)calloc(2, sizeof(double*));
	    meme += 2.*sizeof(double*);
	    for (mt=0; mt<2; mt++)
	      {
		interpft[nt][i][mt] = (double*)calloc(pheight*halfpwidth, sizeof(double));
		if (interpft[nt][i][mt]==NULL)
		  {
		    fflush(stdout);
		    fprintf(stderr," error allocating interpft[%d][%d][%d]\n",nt,i,mt);
		    exit(EXIT_FAILURE);
		  }
		meme += (float)pheight*halfpwidth*sizeof(double);
	      }
	  }
	
    }

    /*
     * printf (" allocating approx %d MB memory for data postage stamps \n",
     * (int)((float)nobj*(float)nmaximages*(float)(halfpwidth*pheight)*sizeof(fftw_complex)/1024./1024.));
     */

    dmoments = (double***)ml_calloc(nobj, sizeof(double**), &meme, "dmoments");
    for (i=0; i<nobj; i++)
      {
	dmoments[i] = (double**)ml_calloc(nmaximages, sizeof(double*), &meme, "dmoments[i]");
	for (jj=0; jj<nmaximages; jj++)
	  {
	    dmoments[i][jj] = (double*)ml_calloc(3, sizeof(double), &meme, "dmoments[i][jj]");
	  }
      }


    D = (fftw_complex ***) fftw_malloc(nobj * sizeof(fftw_complex **));
    datamemory = (float) nobj *sizeof(fftw_complex **);
    for(i = 0; i < nobj; i++) {
        D[i] =
            (fftw_complex **) fftw_malloc(nmaximages * sizeof(fftw_complex *));
        datamemory += (float) nmaximages *sizeof(fftw_complex *);
        if (D[i] == NULL) {
            fprintf(stderr, " failed to allocate memory for D[i]\n");
            exit(EXIT_FAILURE);
        }
	for (jj=0; jj<nmaximages; jj++)
	  {
	    D[i][jj] = NULL;
	  }
        /*
         * don't allocate the actual pixel arrays yet, leave that until the last moment
         * in case we don't need it 
         */
    }
    Dreal = (double ***) fftw_malloc(nobj * sizeof(double **));
    datamemory += (float) nobj *sizeof(double **);
    for(i = 0; i < nobj; i++) {
        Dreal[i] = (double **) fftw_malloc(nmaximages * sizeof(double *));
        datamemory += (float) nmaximages *sizeof(double *);
        if (Dreal[i] == NULL) {
            fprintf(stderr, " failed to allocate memory for Dreal[i]\n");
            exit(EXIT_FAILURE);
	}
	for (jj=0; jj<nmaximages; jj++)
	  {
	    Dreal[i][jj] = NULL;
	  }
        /*
         * don't allocate the actual pixel arrays yet, leave that until the last moment
         * in case we don't need it 
         */
    }

    datamemory1 = datamemory;

    /*
     * printf (" successfully allocated %d MB memory for data postage stamps \n",
     * (int)(memd/1024./1024.)); 
     */

    /*
     * create FFTW plans  
     */

    /*
     * plans to FT the psf etc 
     */
    for(nt = 0; nt < NUM_THREAD; nt++) {
        /*
         * plan for FFT the psfs 
         */
        p[nt] = (fftw_plan *) fftw_malloc(nmaximages * sizeof(fftw_plan));
        meme += (float) nmaximages *sizeof(fftw_plan);
        for(j = 0; j < nmaximages; j++) {
            p[nt][j] =
                fftw_plan_dft_r2c_2d(pwidth, pheight, psf[nt], B[nt][j],
                                     FFTW_MEASURE);
        }
        /*
         * inverse transform for likelihood 
         */
        pinv[nt] = (fftw_plan *) fftw_malloc(2 * sizeof(fftw_plan));
        meme += (float) 2. *sizeof(fftw_plan);
        for(j = 0; j < 2; j++) {
            pinv[nt][j] =
                fftw_plan_dft_c2r_2d(pwidth, pheight, C[nt][j], c[nt][j],
                                     FFTW_MEASURE);
        }

        /*
         * plans to FT the data 
         */
        DFT[nt] =
            (fftw_complex *) fftw_malloc((halfpwidth * pheight) *
                                         sizeof(fftw_complex));
        meme += (float) halfpwidth *pheight * sizeof(fftw_complex);
        q[nt] =
            fftw_plan_dft_r2c_2d(pwidth, pheight, dpix[nt], DFT[nt],
                                 FFTW_MEASURE);
    }


  /**************************************************************************************
     read the images in and use threads to do the pre-processing 
  ***************************************************************************************/

    /*
     * initialise the reference noise value, this is set inside read_images 
     */
    noiserefval = -99.;

    /*
     * initially select all objects in catalogue 
     */
    nmin = 0;
    nmax = nobj;

    /*
     * initialise array that matches postage stamps to images 
     * (-1 means no postage stamp found for this image/object) 
     */
    for(i = 0; i < nimages; i++) {
        for(ii = nmin; ii < nmax; ii++) {
            extractedobject[i][ii] = -1;
        }
    }

    /*
     * initialise monitoring arrays 
     */
    for(nt = 0; nt < NUM_THREAD; nt++) {
        imagesize[nt] = 0;      // size of each input fits image, initialised to zero
        allocatedimagesize[nt] = 0;     // actual allocated-memory size of each fits image
        numgoodpsf[nt] = 0;     // tally of number of good postage stamps
        numbadpsf[nt] = 0;      // number having bad PSF normalisations, hence rejected
        numcosmicreject[nt] = 0;        // counter of objects disqualified by cosmicray rejection
        // allocate memory
        badid[nt] = (int *) calloc(nimages, sizeof(int));       // number of bad PSFs per image
        ellipticalpsf[nt] = (int *) calloc(nimages, sizeof(int));       // number of bad PSFs per image
        goodid[nt] = (int *) calloc(nimages, sizeof(int));      // number of good PSFs per image
        if (badid[nt] == NULL || ellipticalpsf[nt] == NULL
            || goodid[nt] == NULL) {
            fprintf(stderr,
                    " error allocating memory for badid or goodid \n");
            exit(EXIT_FAILURE);
        }
    }

    memi = 0.;                  // amount of memory allocated for input fits images

    /*
     * work out memory needed for input images
     */
    i = 0; // assume first image is typical
    if (nimages > NUM_IMAGE_THREAD)
      {
	memi = NUM_IMAGE_THREAD * dim[i][0] * dim[i][1] * 2*sizeof(float);
	if (SUBTRACT_MEDIAN==1)
	  memi += NUM_IMAGE_THREAD * dim[i][0] * dim[i][1] * sizeof(float);
      }
    else
      {
	memi = nimages * dim[i][0] * dim[i][1] * 2*sizeof(float);
	if (SUBTRACT_MEDIAN==1)
	  memi += nimages * dim[i][0] * dim[i][1] * sizeof(float);
      }
    if (memi<=0.) 
      {
	fflush(stdout);
	fprintf(stderr," error handling image size for first image \n");
	exit(EXIT_FAILURE);
      }
    
    //  printf(" ready to create models \n");

  /**********************************************************************************
  **********************************************************************************/

    /*
     * define some things needed for the models  
     */

    msize = mwidth * mheight;

    rp = (double *) calloc(msize, sizeof(double));
    if (rp == NULL) {
        fprintf(stderr, "error cannot allocate memory for rp\n");
        exit(0);
    }
    rd = (double *) calloc(msize, sizeof(double));
    if (rd == NULL) {
        fprintf(stderr, "error cannot allocate memory for rp\n");
        exit(0);
    }
    rc = (double *) calloc(msize, sizeof(double));
    if (rc == NULL) {
        fprintf(stderr, "error cannot allocate memory for rp\n");
        exit(0);
    }
    meme += (float) 3 *msize * sizeof(double);

    for(y = 0; y < (mheight / 2); y++) {
        dy = (double) y;
        for(x = 0; x < (mwidth / 2); x++) {
            yx = y * mwidth + x;
            dx = (double) x;
            rp[yx] = dx * dx + dy * dy;
            rd[yx] = dx * dx - dy * dy;
            rc[yx] = 2. * dx * dy;
        }
        x = mwidth / 2;
        yx = y * mwidth + x;
        dx = (double) (x - mwidth);
        rp[yx] = dx * dx + dy * dy;
        rd[yx] = dx * dx - dy * dy;
        rc[yx] = 2. * dx * dy;
    }

    for(y = (mheight / 2); y < mheight; y++) {
        dy = (double) (y - mheight);
        for(x = 0; x < (mwidth / 2); x++) {
            yx = y * mwidth + x;
            dx = (double) x;
            rp[yx] = dx * dx + dy * dy;
            rd[yx] = dx * dx - dy * dy;
            rc[yx] = 2. * dx * dy;
        }
        x = mwidth / 2;
        yx = y * mwidth + x;
        dx = (double) (x - mwidth);
        rp[yx] = dx * dx + dy * dy;
        rd[yx] = dx * dx - dy * dy;
        rc[yx] = 2. * dx * dy;
    }


    fflush(stdout);

/*  figure out how many ellipticity values there will be in the grid and allocate
     memory accordingly  */

    edim = (int) (max_eta / e_interval);
    nume = 0;

    for(ie1 = -edim; ie1 <= edim; ie1++) {
        for(ie2 = -edim; ie2 <= edim; ie2++) {
            if (ie1 == 0 && ie2 == 0)
                numzero = nume;
            ee1 = ie1 * e_interval;
            ee2 = ie2 * e_interval;
            etasq = ee1 * ee1 + ee2 * ee2;
            if (etasq < max_etasq) {
                nume++;
            }
        }
    }

    //  printf (" e grid sizes: %d %d \n",edim,nume);

    elookup = (int **) calloc((1 + 2 * edim), sizeof(int *));
    meme += (float) (1 + 2 * edim) * sizeof(int *);
    if (elookup == NULL) {
        fprintf(stderr, " memory allocation error for elookup array \n");
        exit(EXIT_FAILURE);
    }
    for(i = 0; i < (1 + 2 * edim); i++) {
        elookup[i] = (int *) calloc((1 + 2 * edim), sizeof(int));
        if (elookup[i] == NULL) {
            fprintf(stderr,
                    " memory allocation error for elookup[i] array \n");
            exit(EXIT_FAILURE);
        }
        meme += (float) (1 + 2 * edim) * sizeof(int);
    }
    e1lookup = (int *) calloc(nume, sizeof(int));
    if (e1lookup == NULL) {
        fprintf(stderr, " memory allocation error for e1lookup array \n");
        exit(EXIT_FAILURE);
    }
    meme += (float) nume *sizeof(int);
    e2lookup = (int *) calloc(nume, sizeof(int));
    if (e2lookup == NULL) {
        fprintf(stderr, " memory allocation error for e2lookup array \n");
        exit(EXIT_FAILURE);
    }
    meme += (float) nume *sizeof(int);
    e1 = (double *) calloc(nume, sizeof(double));
    if (e1 == NULL) {
        fprintf(stderr, " memory allocation error for e1 \n");
        exit(EXIT_FAILURE);
    }
    meme += (float) nume *sizeof(double);
    e2 = (double *) calloc(nume, sizeof(double));
    if (e2 == NULL) {
        fprintf(stderr, " memory allocation error for e2 \n");
        exit(EXIT_FAILURE);
    }
    meme += (float) nume *sizeof(double);

    /* calculate the highest sampling factor needed */
    sampling = (int)(.001+log(coarse_e_sampling/e_interval)/log(2.));
    sampling = (int)(.001+pow(2.,(double)sampling));
    if (sampling < 1) sampling = 1;
    nsampling=1;
    ts=1;
    while (ts < sampling) {
        ts = ts * 2;
        nsampling++;
    }
    printf(" coarsest ellipticity sampling %f \n", e_interval * sampling);
    printf(" maximum number of resampling steps = %d \n", nsampling);
    fflush(stdout);

    for(nt = 0; nt < NUM_THREAD; nt++) {

        eprior[nt] = (double*)ml_calloc(nume, sizeof(double), &meme, "eprior");
	rprior[nt] = (double*)ml_calloc(numR, sizeof(double), &meme, "rprior");
	fittednRo[nt] = (int*)ml_calloc(nume, sizeof(int), &meme, "fittednRo");
	fittedrstep[nt] = (int*)ml_calloc(nume, sizeof(int), &meme, "fittedrstep");
	xevals[nt] = (double*)ml_calloc(nume, sizeof(double), &meme, "xevals");
	yevals[nt] = (double*)ml_calloc(nume, sizeof(double), &meme, "yevals");
	wevals[nt] = (double*)ml_calloc(nume, sizeof(double), &meme, "wevals");
	revals[nt] = (double*)ml_calloc(nume, sizeof(double), &meme, "revals");
        rmarvals[nt] = (double *)ml_calloc(nume, sizeof(double), &meme, "rmarvals");
	if ( (numR+10) > 101 )
	  {
	    xmarvals[nt] = (double *)ml_calloc((numR + 10), sizeof(double), &meme, "xmarvals[nt]");
	    ymarvals[nt] = (double *)ml_calloc((numR + 10), sizeof(double), &meme, "ymarvals[nt]");
	    marbtvals[nt] = (double *)ml_calloc((numR + 10), sizeof(double), &meme, "marbtvals[nt]");
	  }
	else
	  {
	    xmarvals[nt] = (double *)ml_calloc(101, sizeof(double), &meme, "xmarvals[nt]");
	    ymarvals[nt] = (double *)ml_calloc(101, sizeof(double), &meme, "ymarvals[nt]");
	    marbtvals[nt] = (double *)ml_calloc(101, sizeof(double), &meme, "marbtvals[nt]");
	  }
	rfitvals[nt] = (double**)ml_calloc(nume, sizeof(double*), &meme, "rfitvals[nt]");
	for (ne=0; ne<nume; ne++)
	  {
	    rfitvals[nt][ne] = (double*)ml_calloc(5, sizeof(double), &meme, "rfitvals[nt][ne]");
	  }
        wanted[nt] = (short int *)ml_calloc(nume, sizeof(short int), &meme, "wanted");
        new_wanted[nt] = (short int *)ml_calloc(nume, sizeof(short int), &meme, "new_wanted");
        old_wanted[nt] = (short int *)ml_calloc(nume, sizeof(short int), &meme, "old_wanted");
        etable[nt] = (int *)ml_calloc(nume, sizeof(int), &meme, "etable[nt]");
        ltable[nt] = (float *)ml_calloc(nume, sizeof(float), &meme, "ltable[nt]");
        linearposterior[nt] = (double *)ml_calloc(nume, sizeof(double), &meme, "linearposterior[nt]");
        marP[nt] = (double *)ml_calloc(nume, sizeof(double), &meme, "marP[nt]");
        likel[nt] = (double *)ml_calloc(numR * nume, sizeof(double), &meme, "likel[nt]");
	rposterior[nt] = (double*)ml_calloc(numR, sizeof(double), &meme, "rposterior");
	interp_rval[nt] = (double*)ml_calloc(numR*nume, sizeof(double), &meme, "interp_rval");
	modelflux[nt] = (double**)ml_calloc(numR*nume, sizeof(double*), &meme, "modelflux[nt]");
	mshift[nt] = (double**)ml_calloc(numR*nume, sizeof(double*), &meme, "mshift[nt]");
	for (ne=0; ne<(numR*nume); ne++)
	  {
	    modelflux[nt][ne] = (double*)ml_calloc(2, sizeof(double), &meme, "modelflux[nt][ne]");
	    mshift[nt][ne] = (double*)ml_calloc(2, sizeof(double), &meme, "mshift[nt][ne]");
	  }

        if (WRITE_SUMMED_LIKELIHOODS == 1) {
            /*
             * allocate memory for the summed posterior distribution 
             */
            sumlikel[nt] = (double ***) calloc(nmagbins, sizeof(double **));
            meme += (float) nmagbins *sizeof(double **);
            for(magbin = 0; magbin < nmagbins; magbin++) {
                sumlikel[nt][magbin] =
                    (double **) calloc(nsampling, sizeof(double *));
                if (sumlikel[nt][magbin] == NULL) {
                    fprintf(stderr,
                            " memory allocation error for sumlikel \n");
                    exit(EXIT_FAILURE);
                }
                meme += (float) nsampling *sizeof(double *);
                for(is = 0; is < nsampling; is++) {
                    sumlikel[nt][magbin][is] =
                        (double *) calloc(numR * nume, sizeof(double));
                    if (sumlikel[nt][magbin][is] == NULL) {
                        fprintf(stderr,
                                " memory allocation error for sumlikel \n");
                        exit(EXIT_FAILURE);
                    }
                    meme += (float) numR *nume * sizeof(double);
                }
            }
        }
    }

    //    printf (" allocated %d MB for sumlikel \n",(int)(NUM_THREAD*nmagbins*nsampling*numR*nume*sizeof(double)/1024/1024));


    if (WRITE_SUMMED_LIKELIHOODS == 1) {
        tsumlikel = (double **) calloc(nmagbins, sizeof(double *));
        meme += (float) nmagbins *sizeof(double *);
        for(magbin = 0; magbin < nmagbins; magbin++) {
            tsumlikel[magbin] = (double *) calloc(numR, sizeof(double));
            if (tsumlikel[magbin] == NULL) {
                fprintf(stderr, " memory allocation error for tsumlikel \n");
                exit(EXIT_FAILURE);
            }
            meme += (float) numR *sizeof(double);
        }
    }


    ne = 0;

    for(ie1 = -edim; ie1 <= edim; ie1++) {
        for(ie2 = -edim; ie2 <= edim; ie2++) {
            elookup[edim + ie1][edim + ie2] = -99;

            ee1 = ie1 * e_interval;
            ee2 = ie2 * e_interval;
            etasq = ee1 * ee1 + ee2 * ee2;

            if (etasq < max_etasq) {
	      
                e1[ne] = ee1;
                e2[ne] = ee2;

                elookup[edim + ie1][edim + ie2] = ne;
                e1lookup[ne] = ie1;
                e2lookup[ne] = ie2;

                ne++;
            }
        }
    }

    if (ne != nume) {
      fflush(stdout);
        fprintf(stderr, " error creating e arrays \n");
        exit(EXIT_FAILURE);
    }


  /*  create lookup table between inclination and ellipicity, for later interpolation 
      face-on galaxies are at the start of this array (cos i = 1 at ne = 0) */
  modelelookup = (double**)calloc(2,sizeof(double*));
  meme += 2*sizeof(double*);
  numlookup = 101; // number of entries in lookup table
  for (ne=0; ne<2; ne++)
    {
      modelelookup[ne]=(double*)calloc(numlookup,sizeof(double));
      meme += numlookup*sizeof(double);
    }
  mu_array = (double*)calloc(numlookup,sizeof(double));
  meme += numlookup*sizeof(double);

  // make lookup table for interpolation at arbitrary ellipticity
  if (MODELS_3D==1 || MODELS_3D==0)
    {
      // create lookup table for 3D galaxy models, between ellipticity and inclination
      ne = 0;
      while (ne < numlookup)
	{
	  numthisthread=0;
	  for (nt=0; nt<NUM_THREAD && ne<numlookup; nt++)
	    {
	      // printf (" ne %d thread %d \n",ne,nt); fflush(stdout);
	      threadarg[nt].objectnum = ne;
	      threadarg[nt].threadnum = nt;
	      thread_return = pthread_create(&threads[nt], &attr, ellipticity_lookup, (void *)&threadarg[nt]);
	      // printf (" thread return %d from %d \n",thread_return,nt); fflush(stdout);
	      if (thread_return)
		{
		  printf(" error %d from pthread_create %d \n",thread_return,nt);
		  printf(" %s \n",strerror(thread_return));
		  exit(EXIT_FAILURE);
		}
	      ne++;
	      numthisthread++;
	    }
	  for (nt=0; nt<numthisthread; nt++)
	    {
	      thread_return = pthread_join(threads[nt], &tstatus);
	      //	  printf (" join return %d from %d \n",thread_return,nt);
	      if (thread_return !=0 && thread_return != ESRCH)
		{
		  printf(" error %d from pthread_join %d \n",thread_return,nt);
		  printf(" %s \n",strerror(thread_return));
		  exit(EXIT_FAILURE);
		}
	      //	  printf (" joined thread %d status %ld \n",nt,(long)tstatus);
	    }
	}
    } 
  else
    {
      // for 2D models just make a simple lookup between ellipticity and inclination
      // although now this isn't used even if 2D models are specified, just retained for
      // consistency
      for (ne=0; ne<numlookup; ne++)
	{
	  // cosine inclination angle
	  mu_array[ne] = 1. - (double)ne/(double)(numlookup-1);
	  // thin disk ellipticity
	  modelelookup[0][ne] = modelelookup[1][ne] = 
	    (1.-mu_array[ne])/(1.+mu_array[ne]);
	}
    }

  /* set up GSL interpolation functions to convert disk ellipticity to inclination */
  racc = gsl_interp_accel_alloc();
  if (racc==NULL)
    {
      fflush(stdout);
      fprintf(stderr," error from gsl_interp_accel_alloc, racc \n");
      exit(EXIT_FAILURE);
    }
  rspline = gsl_spline_alloc (gsl_interp_cspline, numlookup);
  if (racc==NULL)
    {
      fflush(stdout);
      fprintf(stderr," error from gsl_spline_alloc, rspline \n");
      exit(EXIT_FAILURE);
    }
  gsl_status = gsl_spline_init (rspline, modelelookup[0], mu_array, numlookup);
  if (gsl_status)
    {
      fflush(stdout);
      fprintf(stderr," error gsl_spline_init rspline \n");
      fprintf(stderr," %s \n",gsl_strerror(gsl_status));
      exit(EXIT_FAILURE);
    }

  if (VERBOSE==1)
    printf(" ellipticity lookup tables made\n"); fflush(stdout);

  /*
   * write e values into FITS file  
   */

    for(ii = 0; ii < NITER; ii++) {

        fits_create_tbl(ofptr[ii], BINARY_TBL, nrows, efields, etype, eform,
                        eunit, e_extname, &status);

        for(i = 0; i < nume; i++) {
            row = i + 1;
            fits_write_col(ofptr[ii], TDOUBLE, 1, row, 1, 1, &e1[i], &status);
            fits_write_col(ofptr[ii], TDOUBLE, 2, row, 1, 1, &e2[i], &status);
        }

        if (status) {
            fprintf(stderr, " error writing table defining e1,e2 values \n");
            fits_report_error(stderr, status);  /*  print error message  */
            exit(EXIT_FAILURE);
        }

        /*
         * write keywords  
         */
        if (fits_update_key(ofptr[ii], TSTRING, "VERSION", version,
                            "version number", &status)) {
	  fits_report_error(stderr, status);}  /*  print error message  */
	// write strings of catalogue name segments
	for (i=0; i<nstringcat; i++)
	  {
	    bzero(keystring, FLEN_KEYWORD);
	    sprintf(keystring,"GALCAT%d",i);
	    if (fits_update_key(ofptr[ii], TSTRING, keystring, keywordfile[i],
				"catalogue name", &status)) {
	      fits_report_error(stderr, status);      /* print error message */
	      return (status);
	    }
	  }
        if (fits_update_key(ofptr[ii], TINT, "PSIZE", &postage_stamp_size,
                            "postage stamp size", &status)) {
	  fits_report_error(stderr, status);}  /*  print error message  */
        if (fits_update_key(ofptr[ii], TDOUBLE, "DELTA-E", &e_interval,
                            "ellipticity sampling", &status)) {
	  fits_report_error(stderr, status);}  /*  print error message  */
        if (fits_update_key(ofptr[ii], TDOUBLE, "EMAX", &efunc_emax,
                            "disk prior e_max", &status)) {
	  fits_report_error(stderr, status);}  /*  print error message  */
        if (fits_update_key(ofptr[ii], TDOUBLE, "EFUNCA", &efunc_a,
                            "disk prior parameter", &status)) {
	  fits_report_error(stderr, status);}  /*  print error message  */
        if (fits_update_key(ofptr[ii], TDOUBLE, "EFUNCS", &efunc_sigma,
                            "disk prior parameter", &status)) {
	  fits_report_error(stderr, status);}  /*  print error message  */
        if (fits_update_key(ofptr[ii], TDOUBLE, "BPOPFRAC", &bulgepopfrac,
                            "bulge population fraction", &status)) {
	  fits_report_error(stderr, status);}  /*  print error message  */
        if (fits_update_key(ofptr[ii], TDOUBLE, "BFUNCB", &bulgefunc_b,
                            "bulge prior parameter", &status)) {
	  fits_report_error(stderr, status);}  /*  print error message  */
        if (fits_update_key(ofptr[ii], TDOUBLE, "BFUNCC", &bulgefunc_c,
                            "bulge prior parameter", &status)) {
	  fits_report_error(stderr, status); } /*  print error message  */
        if (fits_update_key(ofptr[ii], TDOUBLE, "RFIT0", &afit[0],
                            "r prior parameter", &status)) {
	  fits_report_error(stderr, status); } /*  print error message  */
        if (fits_update_key(ofptr[ii], TDOUBLE, "RFIT1", &afit[1],
                            "r prior parameter", &status)) {
	  fits_report_error(stderr, status); } /*  print error message  */
        if (fits_update_key(ofptr[ii], TFLOAT, "REFMAG", &refmag,
                            "r prior parameter", &status)) {
	  fits_report_error(stderr, status); } /*  print error message  */
        if (fits_update_key(ofptr[ii], TDOUBLE, "PSCALE", &defaultmeanscalefactor,
                            "r prior parameter", &status)) {
	  fits_report_error(stderr, status); } /*  print error message  */
	if (fits_update_key(ofptr[ii], TFLOAT, "PCUT", &Pcut,
			    "posterior threshold", &status)) {
	  fits_report_error(stderr, status); } /*  print error message  */
	if (fits_update_key(ofptr[ii], TFLOAT, "LCUT", &Lcut,
			    "likelihood threshold", &status)) {
	  fits_report_error(stderr, status); } /*  print error message  */

	// write strings containing input catalogue name

	
        if (status) {
            fprintf(stderr, " error writing keywords into FITS file \n");
            fits_report_error(stderr, status);  /*  print error message  */
            exit(EXIT_FAILURE);
        }

    }


    /*
     * create arrays for galaxies radii in numR steps  
     */

    /*
     * allocate enough memory for models with numR different Ro values,
     * nume different ellipticity values and (pheight*pwidth) double
     * precision pixels  
     */

    modelsize = halfpwidth * pheight;
    mcomplexsize = (1 + (mwidth / 2)) * mheight;

    for(nt = 0; nt < NUM_THREAD; nt++) {
        testmodel[nt] = (float **) calloc(2, sizeof(float *));
        meme += (float) 2. *sizeof(float *);
        for(j = 0; j < 2; j++) {
            testmodel[nt][j] = (float *) calloc(modelsize, sizeof(float));
            if (testmodel[nt][j] == NULL) {
                fprintf(stderr,
                        "error cannot allocate memory for testmodel[nt][j]\n");
                exit(0);
            }
            meme += (float) modelsize *sizeof(float);
        }
        bulge[nt] = (double *) fftw_malloc(msize * sizeof(double));
        if (bulge[nt] == NULL) {
            fprintf(stderr, "error cannot allocate memory for bulge\n");
            exit(0);
        }
        meme += (float) msize *sizeof(double);
        disk[nt] = (double *) fftw_malloc(msize * sizeof(double));
        if (disk[nt] == NULL) {
            fprintf(stderr, "error cannot allocate memory for disk\n");
            exit(0);
        }
        meme += (float) msize * sizeof(double);
        star[nt] = (double *) fftw_malloc(msize * sizeof(double));
        if (star[nt] == NULL) {
            fprintf(stderr, "error cannot allocate memory for star\n");
            exit(0);
        }
        meme += (float) msize * sizeof(double);
        A[nt] =
            (fftw_complex *) fftw_malloc(mcomplexsize * sizeof(fftw_complex));
        if (A[nt] == NULL) {
            fprintf(stderr, "error cannot allocate memory for A\n");
            exit(0);
        }
        meme += (float) mcomplexsize *sizeof(fftw_complex);
        AA[nt] = (fftw_complex **) fftw_malloc(2 * sizeof(fftw_complex*));
	if (AA[nt] == NULL) {
	  fprintf(stderr, "error cannot allocate memory for AA[nt]\n");
	  exit(0);
	}
        meme += 2.*sizeof(fftw_complex*);
	for (mt=0; mt<2; mt++)
	  {
	    AA[nt][mt] = (fftw_complex *) fftw_malloc(mcomplexsize * sizeof(fftw_complex));
	    if (AA[nt][mt] == NULL) {
	      fprintf(stderr, "error cannot allocate memory for AA[nt][mt]\n");
	      exit(0);
	    }
	    meme += (float) mcomplexsize *sizeof(fftw_complex);
	  }
        starA[nt] =
            (fftw_complex *) fftw_malloc(mcomplexsize * sizeof(fftw_complex));
        if (starA[nt] == NULL) {
            fprintf(stderr, "error cannot allocate memory for starA\n");
            exit(0);
        }
        meme += (float) mcomplexsize *sizeof(fftw_complex);
        dstarA[nt] =
            (fftw_complex *) fftw_malloc(modelsize * sizeof(fftw_complex));
        if (dstarA[nt] == NULL) {
            fprintf(stderr, "error cannot allocate memory for dstarA\n");
            exit(0);
        }
        meme += (float)modelsize*sizeof(fftw_complex);
        dmodel[nt] =
            (double *) fftw_malloc(pwidth * pheight * sizeof(double));
        if (dmodel[nt] == NULL) {
            fprintf(stderr, "error cannot allocate memory for dmodel\n");
            exit(0);
        }
        meme += (float) pwidth *pheight * sizeof(double);
        stardmodel[nt] =
            (double *) fftw_malloc(pwidth * pheight * sizeof(double));
        if (stardmodel[nt] == NULL) {
            fprintf(stderr, "error cannot allocate memory for stardmodel\n");
            exit(0);
        }
        meme += (float) pwidth *pheight * sizeof(double);
    }

    /*
     * get ready to make the models  
     */

    /*
     * can't do until after a and A allocated 
     */

    for(nt = 0; nt < NUM_THREAD; nt++) {
        pmodel[nt] = (fftw_plan *) fftw_malloc(2 * sizeof(fftw_plan));
        meme += (float) 2 *sizeof(fftw_plan);
        pmodel[nt][0] =
            fftw_plan_dft_r2c_2d(mwidth, mheight, disk[nt], AA[nt][0],
                                 FFTW_MEASURE);
        pmodel[nt][1] =
            fftw_plan_dft_r2c_2d(mwidth, mheight, bulge[nt], AA[nt][1],
                                 FFTW_MEASURE);
        fmodel[nt] =
            fftw_plan_dft_c2r_2d(mwidth, mheight, A[nt], disk[nt],
                                 FFTW_MEASURE);
        smodel[nt] =
            fftw_plan_dft_r2c_2d(pwidth, pheight, dmodel[nt], A[nt],
                                 FFTW_MEASURE);
        starfmodel[nt] =
            fftw_plan_dft_c2r_2d(mwidth, mheight, starA[nt], star[nt],
                                 FFTW_MEASURE);
        starsmodel[nt] =
            fftw_plan_dft_r2c_2d(pwidth, pheight, stardmodel[nt], dstarA[nt],
                                 FFTW_MEASURE);
        moffatpsf[nt] =
            fftw_plan_dft_r2c_2d(mwidth, mheight, star[nt], starA[nt],
                                 FFTW_MEASURE);

	moments[nt] = (double**)ml_calloc(2, sizeof(double*), &meme, "moments[nt]");
	for (j=0; j<2; j++)
	  {
	    moments[nt][j] = (double*)ml_calloc(3, sizeof(double), &meme, "moments[nt][j]");
	  }
    }

    /*
     * work out how much memory is going to be needed for the models 
     */
    modelmemory =
        (2. * (float) (numR * nume) * (float) modelsize * sizeof(float)
         + numR * nume * sizeof(float **)
         + numR * nume * 2. * sizeof(float *));
    if (VERBOSE == 1)
        printf(" %d MB memory needed for models \n",
               (int) (modelmemory / 1024. / 1024.));

    /*
     * now work out how much memory is left and hence how big are the data chunks we can handle 
     */
    memory_per_object = nmaximages * halfpwidth * pheight * sizeof(fftw_complex) / 1024. / 1024.;       // working in MB

    /*
     * check whether there will be enough memory to allow a single pass through the data 
     */
    if (modelmemory > memi)
        number_available =
            (int) ((MEMORY_LIMIT -
                    (modelmemory + datamemory +
                     meme) / 1024 / 1024.) / memory_per_object) - 1;
    else
        number_available =
            (int) ((MEMORY_LIMIT -
                    (datamemory + memi +
                     meme) / 1024 / 1024.) / memory_per_object) - 1;

    if (number_available >= nobj) {
        recalculate_models = 1; // specify that we can delete image memory after reading and before calculating models
    } else {
        /*
         * multiple data passes are needed, assume we'll keep both models and image memory in core,
         * recalculate available space accordingly (we could also imagine swapping between image
         * and model memory but this didn't work too well when I tried it because of memory fragmentation
         * over many cycles) 
         */
        number_available =
            (int) ((MEMORY_LIMIT -
                    (modelmemory + datamemory + memi +
                     meme) / 1024 / 1024.) / memory_per_object) - 1;
        recalculate_models = 0; // specify that we will keep both image and model memory in core
    }

    /*
     * check there's a sensible number of objects that can be processed, exit if not 
     */
    printf(" MEMORY_LIMIT         %d MB \n", (int) MEMORY_LIMIT);
    if (VERBOSE == 1) {
        printf(" model memory         %f MB \n", modelmemory / 1024. / 1024.);
        printf(" current data memory  %f MB \n", datamemory / 1024. / 1024.);
        printf(" input image memory   %f MB \n", memi / 1024. / 1024.);
        printf(" miscellaneous memory %f MB \n", meme / 1024. / 1024.);
        printf(" memory available is enough for %d objects in each chunk \n",
               number_available);
    }
    fflush(stdout);
    
    memi = 0.;

    if (number_available < 1000 && number_available < nobj) {
        printf(" not enough memory to read images and process objects \n");
        printf(" MEMORY_LIMIT         %d MB \n", (int) MEMORY_LIMIT);
        printf(" model memory         %f MB \n", modelmemory / 1024. / 1024.);
        printf(" current data memory  %f MB \n", datamemory / 1024. / 1024.);
        printf(" input image memory   %f MB \n", memi / 1024. / 1024.);
        printf(" miscellaneous memory %f MB \n", meme / 1024. / 1024.);
        fflush(stdout);
        exit(EXIT_FAILURE);
    }

    t2 = time(NULL);
    if (VERBOSE == 1)
        printf(" Initial setup time was %g secs \n", difftime(t2, t1));


    /*
     * create FITS table for output probability surfaces  
     */

/*  create variable-column-length output table  */
    nrows = (long) nobj;

    for(ii = 0; ii < NITER; ii++) {
        fits_create_tbl(ofptr[ii], BINARY_TBL, nrows, tfields, ttype, tform,
                        tunit, extname, &status);

        /*
         * write PCOUNT keyword  
         */
        pcount = 0;
        if (fits_update_key(ofptr[ii], TLONG, "PCOUNT", &pcount,
                            "heapsize", &status)) {
            fits_report_error(stderr, status);  /*  print error message  */
        }

    }

    if (VERBOSE == 1) {
        printf(" \n MEMORY ALLOCATIONS \n");
        // printf(" initial memory allocated for data postage stamps %6d MB \n",(int)(datamemory/1024./1024.));
        printf(" memory allocated for models       %6d MB \n",
               (int) (modelmemory / 1024. / 1024.));
        printf(" miscellaneous memory allocated           %6d MB \n",
               (int) (meme / 1024. / 1024.));
        printf(" memory for input images                  %6d MB \n\n",
               (int) (memi / 1024. / 1024.));
        // printf(" total memory allocated                   %6d MB \n",(int)((meme+datamemory+modelmemory+memi)/1024./1024.));
        fflush(stdout);
    }

    /*
     * now we need to read the images again, in chunks small enough to fit into memory, 
     * and fit them 
     */

    snlimit = 0.;               // select all objects irrespective of S/N
    exit_after_one_extracted = 0;       // specify we want all postage stamps for each object
    nmin = 0;                   // start at the beginning
    // extract as many as possible above the magnitude limit
    nselected = 0;
    nmax = nmin;
    while (nselected < number_available && nmax < nobj) {
        if (catmag[nmax] >= blim && catmag[nmax] <= flim)
	  nselected++;
	else
	  toutsidemag++;
        nmax++;
    }
    if (nmax > nobj)
        nmax = nobj;


  /*************************************************************************************  
      loop through images, extract each object, work out its psf, and fit it  
      process is divided into batches to allow it to fit into memory
   *************************************************************************************/

    while (nmin < nobj) {

        printf(" reading data for galaxy catalogue numbers %d <= n <= %d \n",
               nmin + 1, nmax);
        fflush(stdout);

        /*
         * check that memory exists for the image-reading arrays 
         */
        for(nt = 0; nt < NUM_IMAGE_THREAD && nt < nimages; nt++) {
            if ( (apix[nt] == NULL || badpix[nt] == NULL)) {
                imagesize[nt] = dim[0][0] * dim[0][1];  // allocate enough memory for first input image (updated in read_images)
                allocatedimagesize[nt] = imagesize[nt];
                //nmaxregion[nt] = imagesize[nt] / lower_area_limit;
                //printf(" allocating image memory for thread %d \n",nt);
		/*
                for(iw = 0; iw < 6; iw++) {
                    if (iwork[nt][iw] == NULL) {
                        iwork[nt][iw] =
                            (int *) calloc(imagesize[nt], sizeof(int));
                        memi += (float) imagesize[nt] * sizeof(int);
                        if (iwork[nt][iw] == NULL) {
                            fprintf(stderr,
                                    " error allocating memory for varylpthresholdf arrays \n");
                            exit(EXIT_FAILURE);
                        }
                    }
                }
                for(iw = 0; iw < 4; iw++) {
                    if (swork[nt][iw] == NULL) {
                        swork[nt][iw] =
                            (unsigned short int *) calloc(nmaxregion[nt],
                                                          sizeof(unsigned
                                                                 short int));
                        memi +=
                            (float) nmaxregion[nt] *
                            sizeof(unsigned short int);
                        if (swork[nt][iw] == NULL) {
                            fprintf(stderr,
                                    " error allocating memory for varylpthresholdf arrays \n");
                            exit(EXIT_FAILURE);
                        }
                    }
                }
                // Ilast and Istart should already be allocated from the first call to read_images
                if (thread_used[nt] == 1
                    && (Ilast[nt] == NULL || Istart[nt] == NULL)) {
                    fprintf(stderr,
                            " error, no memory allocated for Istart or Ilast arrays \n");
                    exit(EXIT_FAILURE);
                }
		*/
                if (apix[nt] == NULL) {
		  //printf(" allocating apix step 1 \n");
                    apix[nt] = (float *) calloc(imagesize[nt], sizeof(float));
                    memi += (float) imagesize[nt] * sizeof(float);
                    if (apix[nt] == NULL) {
                        fprintf(stderr,
                                " error allocating memory for image\n");
                        exit(EXIT_FAILURE);
                    }
                }
                if (badpix[nt] == NULL) {
                    badpix[nt] =
                        (float *) calloc(imagesize[nt], sizeof(float));
                    memi += (float) imagesize[nt] * sizeof(float);
                    if (badpix[nt] == NULL) {
                        fprintf(stderr,
                                " error allocating memory for bad pixel image\n");
                        exit(EXIT_FAILURE);
                    }
                }
                if (SUBTRACT_MEDIAN == 1)
                    if (sortarray[nt] == NULL) {
                        sortarray[nt] =
                            (float *) calloc(imagesize[nt], sizeof(float));
                        memi += (float) imagesize[nt] * sizeof(float);
                        if (sortarray[nt] == NULL) {
                            fprintf(stderr,
                                    " error allocating memory for sortarray\n");
                            exit(EXIT_FAILURE);
                        }
                    }
            }
        }

        if (VERBOSE == 1)
            printf(" memory for input images                  %6d MB \n\n",
                   (int) (memi / 1024. / 1024.));

        /*
         * read through the images and extract the current batch of objects 
         */
        nvalid = read_images();

        if (VERBOSE == 1)
            printf(" memory for postage stamps                %6d MB \n\n",
                   (int) (datamemory / 1024. / 1024.));
        fflush(stdout);

        if (nvalid <= 0) {
            printf
                (" WARNING: no objects extracted from images, object range %d <= n <= %d \n",
                 nmin + 1, nmax);
            pthread_mutex_lock(&fitsfilelock);
            /*
             * write out to FITS file  
             */
            for(ii = 0; ii < NITER; ii++) {
                for(i = nmin; i < nmax; i++) {
                    row = i + 1;
		    /* catalogue id */
		    fits_write_col (ofptr[ii], TINT, 1, row, 1, 1, &catid[i], &status);
		    if (status) fits_report_error(stderr, status); /* print error message */
                    /*
                     * galaxy position (WCS coords from catalogue) 
                     */
                    fits_write_col(ofptr[ii], TDOUBLE, 2, row, 1, 1, &wcsx[i],
                                   &status);
                    fits_write_col(ofptr[ii], TDOUBLE, 3, row, 1, 1, &wcsy[i],
                                   &status);
		    /* catalogue magnitude */
		    fits_write_col (ofptr[ii], TFLOAT, 4, row, 1, 1, &catmag[i], &status);
		    if (status) fits_report_error(stderr, status); /* print error message */
                    /*
                     * fitclass (0=good galaxy fit)  
                     */
                    fitclass[i] = -1;
                    fits_write_col(ofptr[ii], TINT, 11, row, 1, 1, &fitclass[i], &status);

                    if (ii == 0)
                        nodata[0]++;
                }
            }
            /*
             * unlock fits file 
             */
            pthread_mutex_unlock(&fitsfilelock);
        } else {

            /*
             * free memory for main images if no longer needed for a future loop or if
             * we need to make room for the models 
             */
            if (nmax >= nobj || recalculate_models == 1) {
	      //printf(" freeing image memory \n");
                for(nt = 0; nt < NUM_IMAGE_THREAD; nt++) {
		  /*
                    for(iw = 0; iw < 6; iw++) {
                        if (iwork[nt][iw] != NULL) {
                            free(iwork[nt][iw]);
                            iwork[nt][iw] = NULL;
                        }
                    }
                    for(iw = 0; iw < 4; iw++) {
                        if (swork[nt][iw] != NULL) {
                            free(swork[nt][iw]);
                            swork[nt][iw] = NULL;
                        }
                    }
		  */
                    if (apix[nt] != NULL) {
                        free(apix[nt]);
                        apix[nt] = NULL;
                    }
                    //if (apix[nt]==NULL) printf(" apix[ %d ] freed \n",nt);
                    if (badpix[nt] != NULL) {
                        free(badpix[nt]);
                        badpix[nt] = NULL;
                    }
                    //if (badpix[nt]==NULL) printf(" badpix[ %d ] freed \n",nt);
                    if (SUBTRACT_MEDIAN == 1)
                        if (sortarray[nt] != NULL) {
                            free(sortarray[nt]);
                            sortarray[nt] = NULL;
                        }
                    imagesize[nt] = 0;  // reset size of images to zero
                    allocatedimagesize[nt] = 0;
                }
                memi = 0.;      // reset allocated memory counter to zero
            }


            /*
             * If the following has not previously been done, 
             * go through all input chips and exposures and extract key information.
	     * Then find the one with the sharpest PSF
             * and use this both in detectobject for smoothing the data and, if modeloversampling 
             * is specified, as the model PSF for the aliasing correction in make2Dgalaxy 
             */

            if (meanmoments[0] <= 0.) 
	      {
                minmoment = 1000.;
                for(j = 0; j < nimages; j++) 
		  {
                    if (no_psf[j] == 0) 
		      {
                        // identify the chip
                        if (chipnumber[j] <= 0 || nxchip <= 0) 
			  {
                            fflush(stdout);
                            fprintf(stderr,
                                    " error in identifying chip for image %d \n",
                                    j + 1);
                            exit(EXIT_FAILURE);
                        }
                        ichip = chipnumber[j] - 1;
                        ychip = ichip / nxchip;
                        xchip = ichip - ychip * nxchip;
			/*
			if (VERBOSE==1)
			  printf(" evaluating PSF for %d %d %d \n",ichip,xchip,ychip);
			*/
                        if (GLOBAL_PSF == 0) {
                            /*
                             * define local position on this chip at the centre 
                             */
                            xval = 0.;
                            yval = 0.;
                            for(pixel = 0; pixel < (pwidth * pheight);
                                pixel++) {
                                reconstruct(xval, yval, forder, crossterm,
                                            acoeffs[j][pixel],
                                            &psf[0][pixel]);
                            }
                        } else {
                            xval =
                                ((xchip + 0.5) * xchipsampling) / hxsize[j] -
                                1.;
                            yval = (ychip + 0.5) * ychipsampling;
                            /*
                             * assume megacam geometry 
                             */
                            if (ychip > 0)
                                yval += big_gap;
                            if (ychip > 2)
                                yval += big_gap;
                            yval = yval / hysize[j] - 1.;
                            for(pixel = 0; pixel < (pwidth * pheight);
                                pixel++) {
                                globalreconstruct(xval, yval, forder,
                                                  crossterm, chipvariation,
                                                  chiporder, ichip,
                                                  (int) NCHIPS,
                                                  acoeffs[j][pixel],
                                                  &psf[0][pixel]);
                            }
                        }

                        /*
                         * measure the psf ellipticity and centroid 
                         */
                        psfmoments(psf[0], pheight, pwidth, psfe, centroid,
                                   meanmoments);
                        if (meanmoments[1] < meanmoments[0])
                            meanmoments[0] = meanmoments[1];
                        if (meanmoments[0] < minmoment)
                            minmoment = meanmoments[0];
                    }
                }

                // replace PSF moments by minimum value
                meanmoments[0] = meanmoments[1] = minmoment;
                meanmoments[2] = 0.;
                if (minmoment > 0.) {
		  moffatfwhm = 2.*sqrt(pow(2.,1./moffatbeta)-1.)*sqrt(2.*(moffatbeta-2.)*minmoment);
		  printf(" minimum PSF FWHM %f pixels, assuming Moffat exponent=%3.1f \n",
			 moffatfwhm,
			 moffatbeta);
		  fflush(stdout);
                } else {
                    fflush(stdout);
                    fprintf(stderr,
                            " error in PSF moments: PSF size<0, 2nd moment = %f \n",
                            minmoment);
                    exit(EXIT_FAILURE);
                }
            }

            /*
	      Detect background objects and remove them, test for blended/disturbed galaxies
             */
            i = 0;
            ntestobj = 0;
            for(nt = 0; nt < NUM_THREAD; nt++) 
	      {
                threadarg[nt].objectnum = i;
                threadarg[nt].threadnum = nt;
                thread_return =
                    pthread_create(&threads[nt], &attr, detectobjloop,
                                   (void *) &threadarg[nt]);
                if (thread_return) 
		  {
                    printf(" error %d from pthread_create %d \n",
                           thread_return, nt);
                    printf(" %s \n", strerror(thread_return));
                    exit(EXIT_FAILURE);
		  }
                i++;
            }

            for(nt = 0; nt < NUM_THREAD; nt++) {
                thread_return = pthread_join(threads[nt], &tstatus);
                if (thread_return != 0 && thread_return != ESRCH) {
                    printf(" error %d from pthread_join %d \n", thread_return,
                           nt);
                    printf(" %s \n", strerror(thread_return));
                    exit(EXIT_FAILURE);
                }
                //    printf (" joined thread %d status %ld \n",nt,(long)tstatus);
            }


            /*
             * write test images to fits files 
             */
            int anaxis = 2;
            long fpixel[3] = { 1, 1, 1 }, lrow;
            long anaxes[3];     /*  axes of image up to 3D */
            anaxes[0] = pwidth;
            anaxes[1] = pheight;
            int bitpix = -32;
            int testsize = pwidth * pheight;
            fitsfile *tfptr;
            char *pstr;
            int status = 0;
            /*
             * create a unique filename for the postage stamps 
             */
            bzero(rootname, 300);
            /*
             * strcpy(rootname,"meanpostagestamp");
             * strcpy(stampname,rootname);
             * strcat(stampname,".fits");
             * i=0;
             * // if this file already exists make a new name
             * while (access(stampname,F_OK) == 0)
             * {
             * i++;
             * bzero(stampname,300);
             * strcpy(stampname,rootname);
             * pstr = stampname + strlen(stampname); 
             * sprintf(pstr, ".%d.fits", i);
             * }
             * printf(" writing mean postage stamps to file %s \n",stampname);
             * // create the file and write the postage stamps array 
             * fits_create_file(&tfptr, stampname, &status); 
             * fits_create_img(tfptr, bitpix, anaxis, anaxes, &status);
             * if (status) {
             * printf(" error writing postagestamp test pixel data %s \n",stampname);
             * fits_report_error(stderr, status); 
             * }
             * if (fits_write_pix(tfptr, TDOUBLE, fpixel, testsize, meantestout, &status) )
             * {
             * printf(" error writing postagestamp test pixel data %s \n",stampname);
             * fits_report_error(stderr, status); 
             * }
             * fits_close_file(tfptr, &status);
             * if (status) {
             * printf(" error writing postagestamp test pixel data %s \n",stampname);
             * fits_report_error(stderr, status); 
             * }
             * status=0;
             * for (i=0; i<testsize; i++) meantestout[i]=0.;
             */

            // if specified write out individual stamps

/* table to identify each object */
            int testfields = 4; /* number of table columns in table */
            char testextname[] = "object ID";   /* extension name */
            char *testtype[] = { "image", "catnum", "x", "y" }; /* names of columns */
	    char *testform[4];            /*  data types of columns  */
	    for(i = 0; i < 4; i++)
	      testform[i] = (char *) calloc(8, sizeof(char));
            char *testunit[] = { "", "", "", "" };      /* units */
	    // fill up data types of columns in output table of test stamps
	    sprintf(testform[0], "%s", ostring_tform); // overwrite first entry with actual tform size
	    strcpy(testform[1],"I6");
	    strcpy(testform[2],"F8.1");
	    strcpy(testform[3],"F8.1");

            if (ntestobj > 0) {
                if (ntestobj > NTEST_LIMIT)
                    ntestobj = NTEST_LIMIT;
                anaxis = 3;
                anaxes[0] = pwidth;
                anaxes[1] = pheight;
                anaxes[2] = ntestobj;
                testsize = pwidth * pheight * ntestobj;
                status = 0;
                /*
                 * create a unique filename for the postage stamps 
                 */
                bzero(rootname, 300);
                strcpy(rootname, "postagestamps");
                strcpy(stampname, rootname);
                strcat(stampname, ".fits");
                i = 0;
                while (access(stampname, F_OK) == 0) {
                    i++;
                    bzero(stampname, 300);
                    strcpy(stampname, rootname);
                    pstr = stampname + strlen(stampname);
                    sprintf(pstr, ".%d.fits", i);
                }
                printf(" writing %d postage stamps to file %s \n", ntestobj,
                       stampname);
                /*
                 * create the file and write the postage stamps array 
                 */
                fits_create_file(&tfptr, stampname, &status);
                fits_create_img(tfptr, bitpix, anaxis, anaxes, &status);
                if (status) {
                    printf
                        (" error writing postagestamp test pixel data %s \n",
                         stampname);
                    fits_report_error(stderr, status);  /* print error message */
                }
                if (fits_write_pix
                    (tfptr, TDOUBLE, fpixel, testsize, otestout, &status)) {
                    printf
                        (" error writing postagestamp test pixel data %s \n",
                         stampname);
                    fits_report_error(stderr, status);  /* print error message */
                }
                fits_create_tbl(tfptr, ASCII_TBL, ntestobj, testfields,
                                testtype, testform, testunit, testextname,
                                &status);
                if (status) {
                    fits_report_error(stderr, status);  /* print error message */
                    printf(" error writing table into %s \n", stampname);
                }
                for(i = 0; i < ntestobj; i++) {
                    lrow = i + 1;
                    if (testimage[i] >= 0) {
                        len = strlen(image_file[testimage[i]]);
                        if (len >= maximagefilelen) len = maximagefilelen-1;
                        strncpy(ostring[0], image_file[testimage[i]], len);
                        fits_write_col(tfptr, TSTRING, 1, lrow, 1, 1, ostring,
                                       &status);
                        fits_write_col(tfptr, TFLOAT, 3, lrow, 1, 1,
                                       &objx[testimage[i]][testobj[i]],
                                       &status);
                        fits_write_col(tfptr, TFLOAT, 4, lrow, 1, 1,
                                       &objy[testimage[i]][testobj[i]],
                                       &status);
                    }
                    fits_write_col(tfptr, TINT, 2, lrow, 1, 1, &testobj[i],
                                   &status);
                }
                fits_close_file(tfptr, &status);
                if (status) {
                    printf
                        (" error writing postagestamp test pixel data %s \n",
                         stampname);
                    fits_report_error(stderr, status);  /* print error message */
                }
		for (i=0; i<testsize; i++) otestout[i]=0.;
                //      free(otestout);
                //      free(testimage);
                //      free(testobj);
                status = 0;
            }

            /*
             * allocate memory for models 
             */
            if (modelft == NULL) {
	      modelft = (float***)ml_calloc((numR*nume), sizeof(float**), &memm, "modelft");
                for(i = 0; i < numR * nume; i++) {
		  modelft[i] = (float**)ml_calloc(2, sizeof(float*), &memm, "modelft[]");
                    for(j = 0; j < 2; j++) {
		      modelft[i][j] = (float*)ml_calloc(modelsize, sizeof(float), &memm, "modelft[][]");
                    }
                }

                printf
                    (" making models with %d Ro steps and %d ellipticity steps \n",
                     numR, nume);
                if (VERBOSE == 1) {
                    printf
                        (" memory allocated for models              %6d MB \n",
                         (int) (modelmemory / 1024. / 1024.));
                    printf
                        (" input image memory allocated             %6d MB \n",
                         (int) (memi / 1024. / 1024.));
                    printf
                        (" miscellaneous memory allocated           %6d MB \n",
                         (int) (meme / 1024. / 1024.));
                }
                fflush(stdout);

                // just make sure we're not exceeding the memory available (should never happen)
                swapamount = 200.;      // allow a bit of swap space in case we're only just over the limit
                if ((datamemory + meme + memi + modelmemory) / 1024. / 1024. >
                    MEMORY_LIMIT + swapamount) {
                    printf(" memory limit exceeded \n");
                    fflush(stdout);
                    fflush(stderr);
                    exit(EXIT_FAILURE);
                }

                /*
                 * make star (nRo=0) and galaxy (nRo>0) models  
                 */

		// correct moments to Moffat scale factor
		mm[0] = 2.*(moffatbeta-2.)*meanmoments[0];
		mm[1] = 2.*(moffatbeta-2.)*meanmoments[1];
		// correct PSF moments for pixel convolution
		//mm[0] -= 2.*log(pi/2.)/pi/pi;
		//mm[1] -= 2.*log(pi/2.)/pi/pi;
		if (mm[0]<0.) mm[0]=0.;
		if (mm[1]<0.) mm[1]=0.;
		if (VERBOSE==1)
		  {
		    printf (" corrected Moffat moments %f %f \n",mm[0],mm[1]);
		    printf (" making models \n");
		  }
		fflush(stdout);

		for (nt=0; nt<NUM_THREAD; nt++)
		  {
		    // printf (" nRo %d thread %d \n",nRo,nt);
		    threadarg[nt].objectnum = numR;
		    threadarg[nt].threadnum = nt;
		    thread_return = pthread_create(&threads[nt], &attr, model_loop, (void *)&threadarg[nt]);
		    //  printf (" thread return %d from %d \n",thread_return,nt);
		    if (thread_return)
		      {
			printf(" error %d from pthread_create %d \n",thread_return,nt);
			printf(" %s \n",strerror(thread_return));
			exit(EXIT_FAILURE);
		      }
		  }
		// wait for threads to finish
		for (nt=0; nt<NUM_THREAD; nt++)
		  {
		    thread_return = pthread_join(threads[nt], &tstatus);
		    // printf (" join return %d from %d \n",thread_return,nt);
		    if (thread_return !=0 && thread_return != ESRCH)
		      {
			printf(" error %d from pthread_join %d \n",thread_return,nt);
			printf(" %s \n",strerror(thread_return));
			exit(EXIT_FAILURE);
		      }
		    // printf (" joined thread %d status %ld \n",nt,(long)tstatus);
		  }

                // write out models to modelfile if specified
                if (WRITE_MODELS == 1 && modelfile != NULL) {
                    if (access(modelfile, F_OK) == 0) {
                        printf(" *** modelfile %s exists: removing \n",
                               modelfile);
                        remove(modelfile);
                    }
                    // create the file and write the postage stamps array 
                    fits_create_file(&mfptr, modelfile, &status);
                    mnaxis = 3;
		    // either write out real-space
                    //manaxes[0] = pwidth;
		    // or Fourier-space models
                    manaxes[0] = halfpwidth;
                    manaxes[1] = pheight;
                    manaxes[2] = 1000;
                    status = 0;
                    fits_create_img(mfptr, mbitpix, mnaxis, manaxes, &status);
                    if (status) {
		      fflush(stdout);
		      fprintf(stderr," error creating model file %s \n", modelfile);
                        fits_report_error(stderr, status);      // print error message 
                        exit(EXIT_FAILURE);
                    }
                    mfpixel[2] = 0;
                    for(i = 0; i < 2; i++)      // disk and bulge models
		      {
                        for(nRo = 0; nRo < numR; nRo+=10)     // range of scalelengths
			  {
                            for(ne = 0; ne < nume; ne += 8)     // some of the ellipticities
			      {
                                modelnum = nRo * nume + ne;
				// either FT the Fourier components and write out models
				/* FFT to create model
                                for(iy = 0; iy < halfpwidth * pheight; iy++)
                                    C[0][iy] =
                                        modelft[modelnum][i][iy] + I*0.;
                                fftw_execute(pinv[0][0]);
                                psfmoments(c[0][0], pheight, pwidth, psfe,
                                           centroid, moments);
				printf
                                    ("model ellipticity %d %f %f %f %f %f \n",
                                     i, Ro[nRo], e1[ne], e2[ne], psfe[0],
                                     psfe[1]);
                                mfpixel[2]++;
                                mfpixel[0] = mfpixel[1] = 1;
                                if (mfpixel[2] <= 1000) 
				  {
				    for (y=0; y<pheight; y++)
				      {
					yy = y+pheight/2;
					if (yy>=pheight) yy-=pheight;
					for (x=0; x<pwidth; x++)
					  {
					    xx = x+pwidth/2;
					    if (xx>=pwidth) xx-=pwidth;
					    ipixel = x+y*pwidth;
					    opixel = xx+yy*pwidth;
					    dmodel[0][opixel] = c[0][0][ipixel];
					  }
				      }
				    if (fits_write_pix
                                        (mfptr, TDOUBLE, mfpixel,
                                         pwidth * pheight, dmodel[0],
                                         &status)) {
                                        printf
                                            (" error writing model data to fits cube %s \n",
                                             modelfile);
                                        fits_report_error(stderr, status);      // print error message 
                                        exit(EXIT_FAILURE);
                                    }
				*/
				// or write out Fourier components directly
                                mfpixel[2]++;
                                mfpixel[0] = mfpixel[1] = 1;
                                if (mfpixel[2] <= 1000) 
				  {
				    if (fits_write_pix
                                        (mfptr, TFLOAT, mfpixel,
                                         halfpwidth * pheight, modelft[modelnum][i],
                                         &status)) {
                                        printf
                                            (" error writing model data to fits cube %s \n",
                                             modelfile);
                                        fits_report_error(stderr, status);      // print error message 
                                        exit(EXIT_FAILURE);
                                    }
				  }
			      }
			  }
		      }
                    fits_close_file(mfptr, &status);
                    if (status) {
                        printf(" error closing model fits cube %s \n",
                               modelfile);
                        fits_report_error(stderr, status);      // print error message 
                        exit(EXIT_FAILURE);
                    }
                    // disable the modelfile variable so the file isn't overwritten
                    modelfile = NULL;
                }

            }

            printf
                (" measuring shapes for galaxies, catalogue numbers %d <= n <= %d \n",
                 nmin + 1, nmax);
            fflush(stdout);

            /*
             * go through and measure their shapes 
             */
            nmtestobj = 0;
            i = 0;
	    for(nt = 0; nt < NUM_THREAD; nt++) {
            //for(nt = 0; nt < 1; nt++) {
                threadarg[nt].objectnum = i;
                threadarg[nt].threadnum = nt;
                thread_return =
                    pthread_create(&threads[nt], &attr, objectloop,
                                   (void *) &threadarg[nt]);
                if (thread_return) {
                    printf(" error %d from pthread_create %d \n",
                           thread_return, nt);
                    printf(" %s \n", strerror(thread_return));
                    exit(EXIT_FAILURE);
                }
                i++;
            }

            for(nt = 0; nt < NUM_THREAD; nt++) {
            //for(nt = 0; nt < 1; nt++) {
                thread_return = pthread_join(threads[nt], &tstatus);
                if (thread_return != 0 && thread_return != ESRCH) {
                    printf(" error %d from pthread_join %d \n", thread_return,
                           nt);
                    printf(" %s \n", strerror(thread_return));
                    exit(EXIT_FAILURE);
                }
                //        printf (" joined thread %d status %ld \n",nt,(long)tstatus);
            }


            // if specified write out individual stamps
            if (ntestobj > 0) {
                if (ntestobj > NTEST_LIMIT)
                    ntestobj = NTEST_LIMIT;
                anaxis = 3;
                anaxes[0] = pwidth;
                anaxes[1] = pheight;
                anaxes[2] = ntestobj;
                testsize = pwidth * pheight * ntestobj;
                status = 0;
                /*
                 * create a unique filename for the postage stamps 
                 */
                bzero(rootname, 300);
                strcpy(rootname, "modelstamps");
                strcpy(stampname, rootname);
                strcat(stampname, ".fits");
                i = 0;
                while (access(stampname, F_OK) == 0) {
                    i++;
                    bzero(stampname, 300);
                    strcpy(stampname, rootname);
                    pstr = stampname + strlen(stampname);
                    sprintf(pstr, ".%d.fits", i);
                }
                printf(" writing %d model postage stamps to file %s \n",
                       ntestobj, stampname);
                /*
                 * create the file and write the postage stamps array 
                 */
                fits_create_file(&tfptr, stampname, &status);
                fits_create_img(tfptr, bitpix, anaxis, anaxes, &status);
                if (status) {
                    printf
                        (" error writing model postagestamp test pixel data %s \n",
                         stampname);
                    fits_report_error(stderr, status);  /* print error message */
                }
                if (fits_write_pix
                    (tfptr, TDOUBLE, fpixel, testsize, otestout, &status)) {
                    printf
                        (" error writing model postagestamp test pixel data %s \n",
                         stampname);
                    fits_report_error(stderr, status);  /* print error message */
                }
                fits_create_tbl(tfptr, ASCII_TBL, ntestobj, testfields,
                                testtype, testform, testunit, testextname,
                                &status);
                if (status) {
                    fits_report_error(stderr, status);  /* print error message */
                    printf(" error writing model stamp table into %s \n",
                           stampname);
                }
                for(i = 0; i < ntestobj; i++) {
                    lrow = i + 1;
                    if (testimage[i] >= 0) {
                        len = strlen(image_file[testimage[i]]);
                        if (len >= maximagefilelen) len = maximagefilelen-1;
                        strncpy(ostring[0], image_file[testimage[i]], len);
                        fits_write_col(tfptr, TSTRING, 1, lrow, 1, 1, ostring,
                                       &status);
                        fits_write_col(tfptr, TFLOAT, 3, lrow, 1, 1,
                                       &objx[testimage[i]][testobj[i]],
                                       &status);
                        fits_write_col(tfptr, TFLOAT, 4, lrow, 1, 1,
                                       &objy[testimage[i]][testobj[i]],
                                       &status);
                    }
                    fits_write_col(tfptr, TINT, 2, lrow, 1, 1, &testobj[i],
                                   &status);
                }
                fits_close_file(tfptr, &status);
                if (status) {
                    printf
                        (" error writing model postagestamp pixel data %s \n",
                         stampname);
                    fits_report_error(stderr, status);  /* print error message */
                }
                //free(otestout);
                //free(testimage);
                //free(testobj);
                status = 0;
            }

            /*
             * free memory for this set of postage stamps 
             */
            for(i = nmin; i < nmax; i++) {
                for(j = 0; j < nmaximages; j++) {
                    if (D[i][j] != NULL) {
                        fftw_free(D[i][j]);
                        D[i][j] = NULL;
                        datamemory -=
                            (float) halfpwidth *pheight *
                            sizeof(fftw_complex);
                    }
                    if (Dreal[i][j] != NULL) {
                        free(Dreal[i][j]);
                        Dreal[i][j] = NULL;
                        datamemory -=
                            (float) pwidth *pheight * sizeof(double);
                    }
                }
                fftw_free(D[i]);
                D[i] = NULL;
                free(Dreal[i]);
                Dreal[i] = NULL;
                datamemory -= (float) sizeof(fftw_complex *);
                datamemory -= (float) sizeof(double *);
                free(datasq[i]);
                datasq[i] = NULL;
                datamemory -= (float) nmaximages *sizeof(double);
            }
            // printf(" postage stamp memory reset to %f MB \n",(datamemory/1024./1024.));

            /*
             * delete models if we need to make room for the input images in the
             * next iteration (the ways it's currently set up, this deletion only happens
             * if there is only one pass through the data or if this is the final pass,
             * we could change that in future though.) 
             */
            if (recalculate_models == 1 || nmax >= nobj) {
                for(i = 0; i < numR * nume; i++) {
                    for(j = 0; j < 2; j++) {
                        free(modelft[i][j]);
                        modelft[i][j] = NULL;
                    }
                    free(modelft[i]);
                    modelft[i] = NULL;
                }
                free(modelft);
                modelft = NULL;
                // if (modelft==NULL) printf(" modelft freed \n");
                memm = 0.;      // reset memory counter
            }

        }

        fflush(stdout);

        /*
         * next batch of objects to be analysed 
         */
        nmin = nmax;
        nselected = 0;
        while (nselected < number_available && nmax < nobj) {
          if (catmag[nmax] >= blim && catmag[nmax] <= flim)
	    nselected++;
	  else
	    toutsidemag++;
	  nmax++;
        }
        if (nmax > nobj)
            nmax = nobj;
    }

    /*
     * all main loops now finished 
     */

    /*
     * set flag for the following section to
     * write out chisq surfaces for each object to fits file 
     */

    if (WRITE_CHISQ_SURFACES == 1) {
        nselected = 0;
        for(i = 0; i < nobj; i++) {
            if (galselected[i] == 1) {
                for(ic = 0; ic < (pwidth * pheight); ic++) {
                    bestchisq[ic + nselected * pwidth * pheight] =
                        bestchisq[ic + i * pwidth * pheight];
                }
                nselected++;
                // printf (" selected %d %f %f \n",nselected,spos[i][0],spos[i][1]);
            }
        }
        char *stampname;
        stampname = (char *) calloc(500, sizeof(char));
        int anaxis = 3;
        long fpixel[3] = { 1, 1, 1 }, sanaxes[3];
        int bitpix = -32;
        status = 0;
        int testsize = pwidth * pheight * nselected;
        fitsfile *tfptr;

        sanaxes[0] = pwidth;
        sanaxes[1] = pheight;
        sanaxes[2] = nselected;

        strcat(stampname, "chisq.fits");
        if (access(stampname, F_OK) == 0) {
            printf(" *** postage stamps file exists: removing \n");
            remove(stampname);
        }
        // create the file and write the postage stamps array 
        fits_create_file(&tfptr, stampname, &status);
        fits_create_img(tfptr, bitpix, anaxis, sanaxes, &status);
        if (status) {
            printf(" error writing postagestamp test pixel data %s \n",
                   stampname);
            fits_report_error(stderr, status);  // print error message 
        }
        if (fits_write_pix
            (tfptr, TDOUBLE, fpixel, testsize, bestchisq, &status)) {
            printf(" error writing postagestamp test pixel data %s \n",
                   stampname);
            fits_report_error(stderr, status);  // print error message 
        }
        fits_close_file(tfptr, &status);
        if (status) {
            printf(" error writing postagestamp test pixel data %s \n",
                   stampname);
            fits_report_error(stderr, status);  // print error message 
        }
    }

    /*
     * aggregate counters 
     */

    for(nt = 0; nt < NUM_THREAD; nt++) {
        tnodata += nodata[nt];
	toofew += toofewexposures[nt];
	tnone += noexposures[nt];
        tbadfit += badfit[nt];
        tnotdetected += notdetected[nt];
        tclosefit += closefit[nt];
        tstarfit += starfit[nt];
        tgoodfit += goodfit[nt];
        tchisqcut += chisqcut[nt];
	tblend += numblend[nt];
	toobig += numtoobig[nt];
    }

    /*
     * DONT compress the fits heap - can cause the program to crash
     * fits_compress_heap (ofptr, &status);
     * if (status) {
     * fits_report_error(stderr, status); 
     * }
     */

    /*
     * estimate appropriate magnitude cutoff for star-galaxy classification 
     */
    nn = 0;
    for(i = 0; i < nobj; i++) {
        if (fitclass[i] == 0 && fprob[i] > 0.55 && fprob[i] < 0.65) {
            smag[nn] = catmag[i];
            nn++;
        }
    }
    if (nn > 10) {
        qsort(smag, nn, sizeof(float), compare);
        // choose cutoff as being 30-percentile of magnitude for this range of fprob
        fmag = smag[nn*3/10];
    } else {
        // default value if only a few objects in catalogue
        fmag = 23.;
    }
    printf(" magnitude cutoff for star-galaxy classification %f \n", fmag);
    /*
     * go through objects, test the stargalaxy probability and reset the values in
     * the output fits table if appropriate 
     */
    tswap = 0;
    for(i = 0; i < nobj; i++) {
        if (fitclass[i] == 0) {
            /*
             * set magnitude-dependent threshold
             * as linear relation with magnitude, with fixed slope 0.1
             * and reaching values fprob=0.5 at mag=fmag 
             */
            fthresh = 0.5 - 0.1 * (catmag[i] - fmag);
            if (fthresh > 0.95)
                fthresh = 0.95;
            if (fprob[i] < fthresh && rmar[i]<=0.5) {
                fitclass[i] = 1;
                row = i + 1;
                fits_write_col(ofptr[0], TINT, 11, row, 1, 1, &fitclass[i],
                               &status);
                tgoodfit--;
                tstarfit++;
                tswap++;
            }
        }
    }

    printf(" %d candidate galaxies reclassified as stars \n", tswap);

    /*
     * close FITS output file and check status  
     */
    for(ii = 0; ii < NITER; ii++) {
        fits_close_file(ofptr[ii], &status);
        if (status) {
            fits_report_error(stderr, status);  /*  print error message  */
        }
    }


    if (WRITE_SUMMED_LIKELIHOODS == 1) {
        /*
         * write out posterior distributions to separate fits tables (in magnitude slices) 
         */

        /*
         * strip off .fits extension on main output table filename if supplied, create
         * new table filename, and open this file 
         */
        spfile = (char *) calloc(300, sizeof(char));

        for(magbin = 0; magbin < nmagbins; magbin++) {

            len = strlen(argv[2]);
            if (len <= 0) {
                printf
                    (" error reading second argument from command line when writing summed likelihoods\n");
                continue;
            }
            if (strncmp(argv[2] + len - 5, ".fits", 5) == 0
                || strncmp(argv[2] + len - 5, ".FITS", 5) == 0) {
                len = len - 5;
            }
            strncpy(spfile, argv[2], len);
            sprintf(&spfile[len], "_magbin%d", magbin);
            strncat(spfile, ".sp.fits", 8);
            remove(spfile);     // clobber any existing file of this name
            fits_create_file(&pfptr, spfile, &status);
            if (status) {
	      fflush(stdout);
                fprintf(stderr,
                        " error creating output FITS table, %s not created \n",
                        spfile);
                fits_report_error(stderr, status);      /*  print error message  */
            } else {
                /*
                 * create table for r values 
                 */
                fits_create_tbl(pfptr, BINARY_TBL, numR - 1, rfields, rtype,
                                rform, runit, r_extname, &status);

                for(i = 1; i < numR; i++) {
                    row = i;
                    fits_write_col(pfptr, TDOUBLE, 1, row, 1, 1, &Ro[i],
                                   &status);
                }

                if (status) {
                    fprintf(stderr,
                            " error writing table defining r values \n");
                    fits_report_error(stderr, status);  /*  print error message  */
                    exit(EXIT_FAILURE);
                }

                /*
                 * write magnitude limits 
                 */
                if (magbin == 0) {
                    lowerbin = 0.;
                } else {
                    lowerbin = maglimits[magbin - 1];
                }
                if (fits_update_key
                    (pfptr, TFLOAT, "MAGLOW", &lowerbin, "maglimit",
                     &status)) {
                    fits_report_error(stderr, status);  /*  print error message  */
                }
                if (fits_update_key
                    (pfptr, TFLOAT, "MAGHIGH", &maglimits[magbin], "maglimit",
                     &status)) {
                    fits_report_error(stderr, status);  /*  print error message  */
                }

                /*
                 * work out median magnitude in this bin and write value into table 
                 */
                if (nmagarray[magbin] > 0) {
                    qsort(magarray[magbin], nmagarray[magbin], sizeof(float),
                          compare);
                    medianmag = magarray[magbin][nmagarray[magbin] / 2];
                } else {
                    medianmag = 0;
                }
                if (fits_update_key
                    (pfptr, TFLOAT, "MEDMAG", &medianmag, "medianmag",
                     &status)) {
                    fits_report_error(stderr, status);  /*  print error message  */
                }

                /*
                 * within the fitsfile, write out a separate table of summed likelihood for each sampling 
                 */
                sampling = 1;
                for(is = 0; is < nsampling; is++) {
                    /*
                     * count how many rows are required for the table at this sampling 
                     */
                    nrows = 0;
                    for(ie1 = -(edim / sampling); ie1 <= (edim / sampling);
                        ie1++) {
                        for(ie2 = -(edim / sampling);
                            ie2 <= (edim / sampling); ie2++) {
                            ii = ie1 * sampling;
                            jj = ie2 * sampling;
                            ne = elookup[edim + ii][edim + jj];
                            if (ne >= 0) {
                                nrows++;
                            }
                        }
                    }
                    /*
                     * create the table for this sampling.  The fourth column is a variable-length
                     * column holding a vector, each element of the vector is the log(posterior)
                     * value for a different value of Ro 
                     */
                    fits_create_tbl(pfptr, BINARY_TBL, nrows, pfields, ptype,
                                    pform, punit, p_extname, &status);
                    /*
                     * write PCOUNT keyword 
                     */
                    pcount = 0;
                    if (fits_update_key
                        (pfptr, TLONG, "PCOUNT", &pcount, "heapsize",
                         &status)) {
                        fits_report_error(stderr, status);      /*  print error message  */
                    }


                    /*
                     * go through the ellipticity values that are used at this sampling, and write to fits table 
                     */
                    row = 0;
                    for(ie1 = -(edim / sampling); ie1 <= (edim / sampling);
                        ie1++) {
                        for(ie2 = -(edim / sampling);
                            ie2 <= (edim / sampling); ie2++) {
                            ii = ie1 * sampling;
                            jj = ie2 * sampling;
                            ne = elookup[edim + ii][edim + jj];
                            if (ne >= 0) {
                                row++;
                                fits_write_col(pfptr, TDOUBLE, 1, row, 1, 1,
                                               &e1[ne], &status);
                                fits_write_col(pfptr, TDOUBLE, 2, row, 1, 1,
                                               &e2[ne], &status);
                                /*
                                 * for this ellipticity value create and write a vector, one element for each Ro value 
                                 */
                                for(nRo = 1; nRo < numR; nRo++) {
                                    modelnum = nRo * nume + ne;
                                    tsumlikel[magbin][nRo] = 0.;
                                    /*
                                     * add up the results from each different thread 
                                     */
                                    for(nt = 0; nt < NUM_THREAD; nt++)
                                        tsumlikel[magbin][nRo] +=
                                            sumlikel[nt][magbin][is]
                                            [modelnum];
                                }
                                fits_write_col(pfptr, TDOUBLE, 3, row, 1,
                                               (numR - 1), tsumlikel[magbin],
                                               &status);
                                if (status) {
                                    fprintf(stderr,
                                            " error writing table of summed posterior values \n");
                                    fits_report_error(stderr, status);  /*  print error message  */
                                    exit(EXIT_FAILURE);
                                }
                            }
                        }
                    }
                    // printf (" %d rows written to %s for sampling %d \n",row,spfile,is);
                    sampling = sampling * 2;
                }
                fits_close_file(pfptr, &status);
                if (status) {
                    fits_report_error(stderr, status);  /*  print error message  */
                }
            }
        }
    }

    /*
     * report numbers of good/bad postage stamps analysed 
     */
    for(nt = 1; nt < NUM_THREAD; nt++) {
        numbadpsf[0] += numbadpsf[nt];
        numgoodpsf[0] += numgoodpsf[nt];
        numcosmicreject[0] += numcosmicreject[nt];
        for(j = 0; j < nimages; j++) {
            badid[0][j] += badid[nt][j];
            ellipticalpsf[0][j] += ellipticalpsf[nt][j];
            goodid[0][j] += goodid[nt][j];
        }
    }
    printf(" total of %d postage stamps analysed \n", numgoodpsf[0]);
    printf(" total of %d postage stamps rejected with bad PSF \n",
           numbadpsf[0]);
    // printf(" total of %d postage stamps rejected by cosmic-ray detector \n",numcosmicreject[0]);

    if (numbadpsf[0] > 0) {
        for(j = 0; j < nimages; j++) {
            if (badid[0][j] > 0)
                printf(" image %s : %d bad PSFs, %d good PSFs\n",
                       image_file[j], badid[0][j], goodid[0][j]);
            if (ellipticalpsf[0][j] > 0)
                printf(" image %s : %d elliptical PSFs |e|>%f \n",
                       image_file[j], ellipticalpsf[0][j], (float) psfelimit);
        }
        printf(" \n");
    }

    if (numbadpsf[0] > 0.1 * numgoodpsf[0]) {
        printf(" SEVERE WARNING: too many bad PSFs \n\n");
        printf
            ("  if due to bad-psf flag, indicates likely error in PSF creation\n");
        printf("  if due to elliptical PSFs, indicates likely poor data\n");
    }

    /*
     * report main stats to stdout 
     */
    t3 = time(NULL);
    printf(" galaxy model-fitting time was %g secs \n", difftime(t3, t2));
    nanalysed = tbadfit + tchisqcut + tstarfit + tgoodfit + tnotdetected;
    if (nanalysed > 0)
      printf(" galaxy model-fitting time was %g secs per fitted galaxy\n",
           difftime(t3, t2) / nanalysed);
    printf(" number not analysed because not selected, no valid data/psf, or blended = %8d \n", tnodata);
    if (flim < 1000.) 
      {
	printf("        of which %d were outside magnitude range %f < m < %f \n", toutsidemag, blim, flim);	
	printf("                 %d had 0 valid exposures\n", tnone);
      }
    else
      {
	printf("        of which %d had 0 valid exposures\n", tnone);
      }
    if (minexposurenumber>1)
      printf("                 %d had > 0 but < %d exposures\n", toofew, minexposurenumber); 
    printf("                 %d were blended \n",tblend);
    printf("                 %d were too big for the postage stamp \n",toobig);
    
    printf(" Of those analysed:\n");
    printf("    number with no valid likelihood values = %8d \n", tbadfit);
    printf("    number not detected                    = %8d \n", tnotdetected);
    printf("    number failing chi-squared cut =       = %8d \n", tchisqcut);
    printf("    number with stellar fits =             = %8d \n", tstarfit);
    printf("    number of good galaxy fits =           = %8d \n", tgoodfit);
    printf("    total number analysed =                = %8d out of total input %8d \n",
	   nanalysed, tnodata + nanalysed);

    /*
     * report on statistics of individual fields 
     */

    nfield = 0;
    meanp = 0.;
    for(j = 0; j < nimages; j++) {
        tot = npass[j] + nfail[j];
        if (tot > 0) {
            meanp += (double) npass[j] / (double) tot;
            nfield++;
        }
    }
    if (nfield > 0) {
        meanp = meanp / (double) nfield;
        printf("\n STATISTICS OF FITS IN INDIVIDUAL IMAGES \n");
        printf
            ("exposure chip  #stars  pass  fail   tot    prob      <PSF-gal>    +/-     image name\n");
        for(j = 0; j < nimages; j++) {
            exclude = 0;
            if (chipnumber[j] > 0 && chipnumber[j] <= NCHIPS) {
                printf("  %s %3d %5d  ", exposurename[j], chipnumber[j],
                       numstars[j][chipnumber[j] - 1]);
            } else {
                printf("  %s %3d        ", exposurename[j], chipnumber[j]);
            }
            tot = npass[j] + nfail[j];
            rprob = 0.;
            if (tot > 0) {
                rprob = gsl_cdf_binomial_P(npass[j], meanp, tot);
            }
            printf(" %5d %5d %5d %8.6lf ", npass[j], nfail[j], tot, rprob);
            if (tot > 0 && rprob * nimages < 0.1) {
                exclude = 1;
                printf("**");
            } else {
                printf("  ");
            }
            if (psfgaln[j] > 1.) {
                psfgal[j] = psfgal[j] / psfgaln[j];
                psfgalerr =
                    sqrt((psfgalsq[j] / (psfgaln[j] - 1.) -
                          psfgaln[j] * psfgal[j] * psfgal[j] / (psfgaln[j] -
                                                                1.)) /
                         psfgaln[j]);
            } else {
                psfgal[j] = 0.;
                psfgalerr = 0.;
            }
            printf(" %10.6lf %10.6lf ", psfgal[j], psfgalerr);
            if (fabs(psfgal[j]) > 3. * psfgalerr) {
                printf("**");
                exclude = 1;
            } else {
                printf("  ");
            }
            //if (exclude == 1)
                printf(" %s", image_file[j]);
		printf("\n");
        }
    }


    /*
     ***************************************************************** */

    /*
     * Destroy fftw plans 
     * for (j=0; j<nmaximages; j++)
     * {
     * fftw_destroy_plan(p[j]);
     * }
     * for (ii=0; ii<nobj; ii++)
     * {
     * for (i=0; i<nmaximages; i++)
     * {
     * fftw_destroy_plan(q[ii][i]);
     * }
     * }
     * fftw_destroy_plan(padinv);
     * fftw_destroy_plan(pmodel);
     */

    pthread_mutex_destroy(&fitsfilelock);
    pthread_mutex_destroy(&shiftsfilelock);
    pthread_mutex_destroy(&noiserefvallock);
    pthread_mutex_destroy(&nimlock);
    pthread_mutex_destroy(&testlock);
    pthread_mutex_destroy(&memdlock);
    pthread_exit(NULL);

}


void *
imageloop(void *threadargs)
{

    /*
     * thread function for extracting postage stamps from each image
     * and storing their transforms
     */

  int i, ii, j, jj, nt;
  // int nobjects;
    int x, y, ix, iy, psfnum, ngoodpix, thisnim, sumpix;
    int numpsfstars;
    double meanval, mval, edistvals[4];

    /*
     * extract thread number from argument 
     */
    struct threadindex *this_thread;
    this_thread = (struct threadindex *) threadargs;
    nt = this_thread->threadnum;        // thread number
    i = this_thread->objectnum; // image number

    /*
     * check the stack size 
     */
    pthread_attr_getstacksize(&attr, &stacksize);
    if (stacksize < mystacksize) {
        printf(" thread %d unexpected stack size %li \n", nt,
               (long) stacksize);
        exit(EXIT_FAILURE);
    }

    /*
     * set the memory counter 
     */
    memd[nt] = 0.;

    /*
     * set the lower intenesity limit to be search for objects - don't let this
     * go too far into the noise 
     
    intensity_limit[nt] = 2. * noise[i];
    */

    /*
     * optionally subtract assumed constant median background, not needed
     * if a background has already been removed from the input images 
     */
    if (satlev[i]<=0.)
      {
	fflush(stdout);
	fprintf(stderr," error in specified saturation level %f for image %s\n",satlev[i],image_file[i]);
	exit(EXIT_FAILURE);
      }
    maxlevel[nt] = satlev[i] / 2.;

    if (SUBTRACT_MEDIAN == 1) {
        mediansub(apix[nt], badpix[nt], dim[i], maxlevel[nt], sortarray[nt]);
    }

    /*
     * identify objects within this image - this information is used to flag out background
     * objects when fitting to each galaxy 
     */
    //    nobjects = varylpthresholdf3(nt, i);

    /*
     * check that a sensible return came back.  If this is set to negative
     * the inputs found within varylpthresholdf2 must have been wrong,
     * but that shouldn;t happen given the checks already carried out.
     * the most likely cause of a problem is that the stack size is 
     * not big enough 
     */
    /*
    if (nobjects < 0) {
        printf(" error retruned from varylpthresholdf3 \n");
        printf(" possible violation of stack size limit \n");
        printf(" thread %d image %d file %s \n", nt, i, imagename[i]);
        printf(" values %f %d %f \n", apix[nt][0], iwork[nt][0][0], noise[i]);
        exit(EXIT_FAILURE);
    }
    */
    // printf (" %d objects identified within image \n",nobjects);

    /*
     * printf output list of identified objects with sizes and peak fluxes
     * 
     * int thiscolour;
     * 
     * numpix = (int*)calloc(nobjects,sizeof(int));
     * imax = (float*)calloc(nobjects,sizeof(float));
     * 
     * for (pixel=0; pixel<dim[i][0]*dim[i][1]; pixel++)
     * {
     * thiscolour = region[pixel];
     * if (thiscolour>0)
     * {
     * numpix[thiscolour]++;
     * if (apix[pixel]>imax[thiscolour]) imax[thiscolour]=apix[pixel];
     * }
     * }
     * 
     * for (k=0; k<nobjects; k++)
     * {
     * printf(" obects in image %d %d %f %d \n",i+1,k+1,imax[k],numpix[k]);
     * }
     * 
     * free(imax);
     * free(numpix);
     */


    /*
     * now work through and extract the data postage stamps 
     */
    for(ii = nmin; ii < nmax; ii++) {
        /*
         * check that this object is on this image, that it's at least half a postage-stamp
         * from its edges, and that it hasn't already been extracted.  Also check whether in this
         * pass we want all postage stamps per image or whether we just want one, as defined
         * by the exit_after_one_extracted flag 
         */
        if (offscale[nt][ii] == 0 && 
	    objx[i][ii] > (float) (pwidth / 2) && 
	    objx[i][ii] < (float) (dim[i][0] - pwidth / 2) 
	    && objy[i][ii] > (float) (pheight / 2) 
	    && objy[i][ii] < (float) (dim[i][1] - pheight / 2) 
	    && (
		(exit_after_one_extracted == 1 && nim[ii] < 1) ||       // no stamps yet
		 exit_after_one_extracted == 0 ||        // get all stamps 
		(exit_after_one_extracted == -1 && nim[ii] > 0 && extractedobject[i][ii] < 0) // at least one stamp
		))
	  {
            /*
             * check whether the PSF had enough stars at this point on the chip, don't
             * extract the galaxy if it did not.  For compatibility with old style
             * PSF files, don't require this information to be present, however.
             * (not relevant for global PSF files, so maxboxno=0 for these) 
             */
            numpsfstars = 0;
            if (boxsize[i] > 0 && maxboxno[i] > 0) {
                ix = ((int) (objx[i][ii] + 0.5) - 1) / boxsize[i];
                iy = ((int) (objy[i][ii] + 0.5) - 1) / boxsize[i];
                psfnum = iy * xboxnum[i] + ix;
                if (psfnum > maxboxno[i] || ix > xboxnum[i]
                    || iy > yboxnum[i]) {
                    fprintf(stderr,
                            "  error matching object to PSF box, likely due to wrong PSF file \n");
                    exit(EXIT_FAILURE);
                }
                numpsfstars = listnum[i][psfnum];
            }
            if (maxboxno[i] <= 0 || numpsfstars >= PSF_STAR_LIMIT) {
	      if (satlev[i]<=0.)
		{
		  fflush(stdout);
		  fprintf(stderr," error in specified saturation level %f for image %s\n",satlev[i],image_file[i]);
		  exit(EXIT_FAILURE);
		}
	      maxlevel[nt] = satlev[i] / 2.;
	      if (USE_SWARP == 0)
		  {
                    ngoodpix = extractpostagestamp(apix[nt], badpix[nt], dim[i],
                                            dpix[nt], dbadpix[nt], temp[nt],
                                            badtemp[nt], objx[i][ii],
                                            objy[i][ii], poserror,
                                            ximageoffset[0], yimageoffset[0],
                                            pwidth, pheight, noise[i],
                                            maxlevel[nt]);
		    // set the scale and distortion parameters to default values
		    edistvals[0]=edistvals[3]=180.*3600./pi/defaultmeanscalefactor;
		    edistvals[1]=edistvals[2]=0.;
		  }
                else 
		  {
                    // this version of swarpextract doesn't flag background objects
                    // choose whether to correct distortion or not
                    if (CORRECT_DISTORTION == 1) 
		      {
                        ngoodpix = tbswarpextract_noflag
			  (wcs_raw[i], apix[nt], badpix[nt], dim[i],
			   dpix[nt], dbadpix[nt], objx[i][ii],
			   objy[i][ii], poserror, pwidth, pheight,
			   ikernel[nt], noise[i], 
			   &scalefactor[i], maxlevel[nt], rawpos[nt],
			   wcspos[nt], wcsneg[nt], wcscentre[nt], kern[nt]);
                        // printf(" thread %d image %d object %d ngoodpix %d \n",nt,i,ii,ngoodpix); fflush(stdout);
			// set the scale and distortion parameters
			edistvals[0]=edistvals[3]=scalefactor[i];
			edistvals[1]=edistvals[2]=0.;
		      } 
		    else
		      {
			ngoodpix = tbswarpextract_distortion_measure
			  (wcs_raw[i], apix[nt], badpix[nt], dim[i],
			   dpix[nt], dbadpix[nt], objx[i][ii],
			   objy[i][ii], poserror, pwidth, pheight,
			   noise[i], maxlevel[nt],
			   edistvals, wcscentre[nt]);
			//if (ii==91025) printf(" object %d image %d ngoodpix %d \n",ii,i,ngoodpix);
			if (CORRECT_DISTORTION == 0)
			  {
			    // if no distortion correction specified,
			    // reset the scale and distortion parameters
			    edistvals[0]=edistvals[3]=scalefactor[i];
			    edistvals[1]=edistvals[2]=0.;
			  }
		      }
		  }
	    }
	    else 
	      {
                ngoodpix = 0;
	      }
	    
            /*
             * only proceed if some valid pixels have been found 
             */
            if (ngoodpix > 0) {
                /*
                 * divide the extracted data by the reference noise  
                 * (first image chosen for convenience: the aim here is just 
                 * to get values of order unity in the data) 
                 */
                /*
                 * also find the maximum and mean data values 
                 */
                if (noiserefval <= 0.) {
                    fprintf(stderr, " reference noise value not set \n");
                    exit(EXIT_FAILURE);
                }
                mval = 0.;      /* max val for object ii image i */
                meanval = 0.;
                sumpix = 0;
                for(y = 0; y < pheight; y++) {
                    for(x = 0; x < pwidth; x++) {
                        jj = y * pwidth + x;
                        dpix[nt][jj] = dpix[nt][jj] / noiserefval;
                        if (dbadpix[nt][jj] > 0.) {
                            sumpix++;
                            meanval += dpix[nt][jj];
                            if (dpix[nt][jj] > mval) {
                                mval = dpix[nt][jj];
                            }
                        }
                    }
                }
                meanval = meanval / (double) sumpix;

                /*
                 * only proceed if the maximum value is above the currently-specified snlimit 
                 * or if other postage stamps have already been selected for this object 
                 * or if we've already said we want all postage stamps 
                 */
                if (mval >= snlimit || nim[ii] > 0
                    || exit_after_one_extracted == 0) {

                    /*
                     * get a unique array element number for this image for this object 
                     */
                    pthread_mutex_lock(&nimlock);
                    thisnim = nim[ii];
                    nim[ii]++;
                    pthread_mutex_unlock(&nimlock);

		    // store distortion and scale parameters
		    for (j=0; j<4; j++)
		      edist[ii][thisnim][j] = edistvals[j];

                    /*
                     * check haven't exceeded number of allowed postage stamps for this object 
                     */
                    if (thisnim >= nmaximages) {
                        printf
                            (" nim %d >= max %d, object %d image %d ngoodpix %d\n",
                             thisnim, nmaximages, ii, i, ngoodpix);
                        printf(" WCS %lf %lf \n pixel coords \n ", wcsx[ii],
                               wcsy[ii]);
                        for(j = 0; j < nimages; j++) {
                            if (objx[j][ii] > 0.) {
                                printf(" %f %f %d %d\n", objx[j][ii],
                                       objy[j][ii], extractedobject[j][ii],
                                       numgoodpix[ii][extractedobject[j][ii]]);
                            }
                        }
                        exit(EXIT_FAILURE);
                    }

                    extractedobject[i][ii] = thisnim;   /* identifies valid images later */
                    numgoodpix[ii][thisnim] = ngoodpix; /* number of good pixels */

		    //if (ii==91025) printf(" image %d extracted %d \n",i,extractedobject[i][ii]);

                    /*
                     * make sure there's some memory available 
                     */
                    if (Dreal[ii][thisnim] == NULL) {
                        Dreal[ii][thisnim] =
                            (double *) calloc((pwidth * pheight),
                                              sizeof(double));
                        memd[nt] += (float) pwidth *pheight * sizeof(double);
                        if (Dreal[ii][thisnim] == NULL) {
                            fflush(stdout);
                            fprintf(stderr,
                                    " failed to allocate memory for data cube \n");
                            exit(EXIT_FAILURE);
                        }
                    }

                    /*
                     * load the data into the big array 
                     */
                    for(jj = 0; jj < (pwidth * pheight); jj++) {
                        Dreal[ii][thisnim][jj] = dpix[nt][jj];
                    }

                }
            }
        }
    }

    /*
     * add the amount of memory allocated in this thread to the total 
     */
    pthread_mutex_lock(&memdlock);
    datamemory += memd[nt];
    if ((int) ((datamemory+meme+memi)/1024./1024.) > (MEMORY_LIMIT+swapamount)) {
        printf(" data needed for postage stamps exceeds specified limit \n");
        printf(" postage stamp memory allocated = %d MB \n",
               (int) (datamemory / 1024. / 1024.));
        printf(" input image memory allocated =   %d MB \n",
               (int) (memi / 1024. / 1024.));
        printf(" other memory allocated =         %d MB \n",
               (int) (meme / 1024. / 1024.));
        printf(" MEMORY_LIMIT = %d MB \n", (int) MEMORY_LIMIT);
        exit(EXIT_FAILURE);
    }
    pthread_mutex_unlock(&memdlock);

    // printf(" thread %d image %d finishing \n",nt,i);

    pthread_exit(NULL);
}


void *
detectobjloop(void *threadargs)
{
    int i, j, ii, jj, nt, nimcheck;
    int x, y, dstatus, pixel;

    /*
     * extract thread number from argument 
     */
    struct threadindex *this_thread;
    this_thread = (struct threadindex *) threadargs;
    nt = this_thread->threadnum;

    /*
     * loop through the objects 
     */

    //printf(" starting detectobjloop thread %d \n",nt);

    for(i = nt + nmin; i < nmax; i += NUM_THREAD) 
      {
        //printf(" detectobjectloop thread %d object %d \n",nt,i);
	
	fitclass[i] = -1;  // default "no data" fit class flag
	
        nimcheck = 0;
	for(j = 0; j < nimages; j++) {
	  jj = extractedobject[j][i];
	  if (jj >= 0) {
	    //printf(" %d %d \n",j,jj);
	    nimcheck++;
	  }
	}

        /*
         * create a stack of images for this object and detect background objects.
         * flag background object pixels.  then FFT, delete old data cube, store FFT cube 
         */

        //printf(" starting detectobject %d %d \n",i,nimcheck); fflush(stdout);

        if (nimcheck > 0) {
            // find objects and flag pixels
            //printf (" starting detectobject %d \n",i);fflush(stdout);
            dstatus = detectobject(nt, i, Dreal[i]);

            //printf(" object %d dstatus %d \n",i,dstatus);fflush(stdout);

            /*
             * calculate data variance, used in likelihood calculation 
             */
            for(j = 0; j < nimages; j++) {
                jj = extractedobject[j][i];
                if (jj >= 0) {
                    datasq[i][jj] = 0.;
                    for(pixel = 0; pixel < pwidth * pheight; pixel++)
                        datasq[i][jj] +=
                            Dreal[i][jj][pixel] * Dreal[i][jj][pixel] / fsize;
                }
            }

            // printf (" object %d dstatus %d \n",i,dstatus);fflush(stdout);
            /*
             * for (j=0; j<nimages; j++)
             * {
             * jj = extractedobject[j][i];
             * if (jj>=0) 
             * {
             * printf(" %d %d ",jj,numgoodpix[i][jj]);
             * }
             * }
             * printf("\n");
             */

            /*
             * optional write postage stamp into 3D array to be output later 
             * be careful here because other threads also write into
             * these arrays 
             */
	    int oj, xx, yy;
            if (ntestobj < NTEST_LIMIT) {
	      pthread_mutex_lock(&testlock);
		for (j=0; j<nimages; j++)
                  {
		    jj = extractedobject[j][i];
		    if (jj>=0) 
		      {      
			if (ntestobj<NTEST_LIMIT)
			  {
			    for (y=0; y<pheight; y++)
			      {
				for (x=0; x<pwidth; x++)
				  {
				    ii = x + y * pwidth;
				    xx = x-pwidth/2;
				    yy = y-pheight/2;
				    if (xx<0) xx+=pwidth;
				    if (yy<0) yy+=pheight;
				    oj = xx + yy*pwidth;
				    otestout[ntestobj*pwidth*pheight+oj] = Dreal[i][jj][ii];
				  }
			      }
			    testimage[ntestobj]=j;
			    testobj[ntestobj]=i;
			    ntestobj++;
			  }
		      }
                  }
		// put the mean sn frame for this object onto the end of the current stack
                if (ntestobj <= NTEST_LIMIT) {
                    for(y = 0; y < pheight; y++) {
                        for(x = 0; x < pwidth; x++) {
                            ii = x + y * pwidth;
                            otestout[ntestobj * pwidth * pheight + ii] =
                                sn[nt][ii];
                        }
                    }
                    testimage[ntestobj] = -1;
                    testobj[ntestobj] = i;
                    ntestobj++;
		}
		// and finally the colour array
                if (ntestobj <= NTEST_LIMIT) {
                    for(y = 0; y < pheight; y++) {
                        for(x = 0; x < pwidth; x++) {
                            ii = x + y * pwidth;
                            otestout[ntestobj * pwidth * pheight + ii] =
                                colour[nt][ii];
                        }
                    }
                    testimage[ntestobj] = -1;
                    testobj[ntestobj] = i;
                    ntestobj++;
		} 
		pthread_mutex_unlock(&testlock);
	    }

	    // count number of blended objects - these
	    // will have a negative lensfit flag equal to -4-dstatus
	    fitclass[i] = 0;
	    if (dstatus>0 && dstatus<=4) 
	      {
		numblend[nt]++;
		fitclass[i] = -4-dstatus;
	      }
	    // count number of objects too large for postage stamp - these
	    // will have a negative lensfit flag equal to -4-dstatus = -9
	    if (dstatus==5) 
	      {
		numtoobig[nt]++;
		fitclass[i] = -4-dstatus;
	      }
            // if detectobject returned not OK, and if deblending_rejection is set,
            // set the flags to no valid images and free the memory
            if ((dstatus != 0 && DEBLENDING_REJECTION == 1) || dstatus==4) {
		// exclude these objects
		nimcheck = 0;
		nim[i] = 0;
		for(j = 0; j < nimages; j++) {
		  jj = extractedobject[j][i];
		  if (jj >= 0) {
		    numgoodpix[i][jj] = 0;
		    free(Dreal[i][jj]);
		    Dreal[i][jj] = NULL;
		    memd[nt] -= (float) pwidth *pheight * sizeof(double);
		    extractedobject[j][i] = -1;
		  }
		}
            }
        }
        // printf(" thread %d object %d finished \n",nt,i);
      }

    pthread_exit(NULL);
}


void *
objectloop(void *threadargs)
{
  int i, nt, more, new; 
    int ii, j, jj, jim, x, y, xx, yy, xs, maxchisqpos;
    int nRo;
    int close, pixel, modelnum, ichip, xchip, ychip, nchips, nret;
    int bestne, oldbestne, bestnRo, initnRo, ne, nne, newrstep, rstep, nstep, Ploop;
    int initsampling, sampling, oldsampling, nlist, nexpand, numwanted, np, nmore, nmorelimit, ndf;
    int nimcheck, thisnim, iter, magbin, e_iter, e_iter_limit;
    int initrstep = 4;
    int peakpos;
    int ic, len;
    long row, lnmaximages=1;

    nchips = (int) NCHIPS;

    double dell[2], dcen[2];
    double maxrfitvals, tmag, aval, fval;
    double distsq;
    double bulgeflux, diskflux, bulgefraction, totalflux;
    double profile_sn, profile_sn_num, profile_sn_denom;
    double rprob = 0.;
    double maxlikel, maxposterior, zerolikel, maxchisq;
    double Lmaxlikel;

    double dist, xval, yval, normvalue, meane1, meane2;
    double chisquared, reducedchisq, bestsize;
    double psfe[2], centroid[2], pmoments[3], meanpsfe[2], meanstrehl, psfemod;
    double de[2], dshift[2];  
    double starflux, bestpos[2], starbestpos[2];
    double Lthreshold, Pthreshold, val, likelval, priorval;
    double emod, sump, sumprior, beta, mval, pval, pvalmax, posterior;
    double eeprior;
    double minimumvalue, maximumvalue;
    double rndf, rchisq, imchisq, imndf;
    double cross0, cross1, mcross0, mcross1, mcross2, rechisq, denom, sumysq,
        sumy0, sumy1, amp0, amp1;
    double tsumysq, tsumy0, tsumy1, trechisq;
    double Rarcsec;
    double sumw, meanscalefactor, tscalefactor;

    /*
     * shut up compiler warnings 
     */
    bestne = bestsize = 0;
    nimcheck = 0;
    starbestpos[0] = starbestpos[1] = 0.;
    bestpos[0] = bestpos[1] = 0.;

    /*
     * extract object and thread number from argument 
     */
    struct threadindex *this_thread;
    this_thread = (struct threadindex *) threadargs;
    nt = this_thread->threadnum;

    /*
     * numerical integration function kernels and thread-number as its
     * parameter
     */
    int exception;

    /* allocate workspace for GSL matrix inversion */
    int ns = 3;
    gsl_eigen_work[nt] = (gsl_eigen_symmv_workspace*)gsl_eigen_symmv_alloc(ns);
    umatrix[nt] = (gsl_matrix*)gsl_matrix_alloc(ns,ns);
    evec[nt] = (gsl_matrix*)gsl_matrix_alloc(ns,ns);
    bvec[nt] = (gsl_vector*)gsl_vector_alloc(ns);
    eval[nt] = (gsl_vector*)gsl_vector_alloc(ns);
    yvec[nt] = (gsl_vector*)gsl_vector_alloc(ns);

    /*
     * loop through objects, skipping according to the number of threads so that
     * each thread does a unique object 
     */
    for(i = (nmin + nt); i < nmax; i+= NUM_THREAD) {
      //for(i = (nmin + nt); i < nmax; i++) {

      // set current object: this is only used for diagnostic tests if printlikel is set
      // to an object number
      currentobject[nt] = i;

      // initialise variables
        noiseperpixel[i] = 0.;
	nlist = 0;
	sampling = 0;
	meane1 = meane2 = 0.;

        /*
         * set the output magnitude bin for this object, used for summing posterior distributions 
         */
        magbin = 0;
        while (catmag[i] > maglimits[magbin] && magbin < (nmagbins - 1)) {
            magbin++;
        }

        // do the FFT stuff
        // printf(" starting FFTs, object %d thread %d \n",i,nt);fflush(stdout);
        nim[i] = 0;
        for(j = 0; j < nimages; j++) {
            jj = extractedobject[j][i];
            if (jj >= 0) {
                // load data into dpix for FFT
                for(ii = 0; ii < pwidth * pheight; ii++)
                    dpix[nt][ii] = Dreal[i][jj][ii];
		// measure moments
		psfmoments(dpix[nt], pheight, pwidth, dell, dcen, dmoments[i][jj]);
                // FFT from dpix into DFT
                //printf("fft start %d %d %d \n",i,j,jj);fflush(stdout);
                fftw_execute(q[nt]);
                //printf("fft done\n");fflush(stdout);
                /*
                 * make sure there's some memory available to store the FFT 
                 */
                if (D[i][jj] == NULL) {
                    D[i][jj] =
                        (fftw_complex *) fftw_malloc((halfpwidth * pheight) *
                                                     sizeof(fftw_complex));
                    memd[nt] +=
                        (float) halfpwidth *pheight * sizeof(fftw_complex);
                    if (D[i][jj] == NULL) {
                        fflush(stdout);
                        fprintf(stderr,
                                " failed to allocate memory for FFT of data \n");
                        exit(EXIT_FAILURE);
                    }
                }
                // downweight high frequencies in the data (modelft has already been weighted)
                // note sumdata then is not strictly correct 
                // load into permanent array
                for(y = 0; y < pheight / 2; y++) {
                    for(x = 0; x < halfpwidth; x++) {
                        ii = x + y * halfpwidth;
                        D[i][jj][ii] = DFT[nt][ii];
                    }
                }
                for(y = pheight / 2; y < pheight; y++) {
                    yy = y - pheight;
                    for(x = 0; x < halfpwidth; x++) {
                        ii = x + y * halfpwidth;
                        D[i][jj][ii] = DFT[nt][ii];
                    }
                }
                /*
                 * load the FFT result into the big array 
                 * for (ii=0; ii<(halfpwidth*pheight); ii++)
                 * {
                 * D[i][jj][ii] = DFT[nt][ii];
                 * }
                 */
                nim[i]++;
                /*
                 * free data postage stamp, not needed now it's been transformed
                 * printf("freeing memory\n");fflush(stdout);
                 * free(Dreal[i][jj]);
                 * printf("done %d %d %d \n",i,j,jj);fflush(stdout);
                 * printf(" %d %d %d %f \n",i,j,jj,creal(D[i][jj][0]));  
                 * fflush(stdout);
                 */
            }
        }
    
        //if (i==91025) printf("ffts all done, object %d %d images \n",i,nim[i]);fflush(stdout);

	iter = 0;

            maxposterior = NOT_MEASURED;
            chisquared = 0.;
            reducedchisq = 0.;
            bulgeflux = 0.;
            diskflux = 0.;
            starflux = 0.;
            bestsize = 0.;
            rchisq = 0.;
            rprob = 0.;

            meanpsfe[0] = 0.;
            meanpsfe[1] = 0.;
            meanstrehl = 0.;
	    meanscalefactor=0.;
	    sumw=0.;

            dist = M_SQRT2 * (float) pwidth / 2.;
            distsq = dist * dist;

            de[0] = 0.;
            de[1] = 0.;

	    for (ne=0; ne<(nume*numR); ne++)
	      {
		modelflux[nt][ne][0] = 0.;
		modelflux[nt][ne][1] = 0.;
		mshift[nt][ne][0] = mshift[nt][ne][1] = 0.;
	      }

            if (nim[i] > 0) {
                close = 0;
                nimcheck = 0;

                /*
                 * now work out the PSF and include the shifts, both coordinate shifts
                 * for differences between systems on the different images and the
                 * subpixel shifts caused by pixelisation 
                 */

                for(j = 0; j < nimages; j++) {
                    jim = extractedobject[j][i];
                    if (jim >= 0) {
                        if (GLOBAL_PSF == 0) {
                            /*
                             * define local position on this chip in range -1 < val < 1 
                             */
                            xval = (objx[j][i] - hxsize[j]) / hxsize[j];
                            yval = (objy[j][i] - hysize[j]) / hysize[j];
                            for(pixel = 0; pixel < (pwidth * pheight);
                                pixel++) {
                                reconstruct(xval, yval, forder, crossterm,
                                            acoeffs[j][pixel],
                                            &psf[nt][pixel]);
                            }
                        } else {
                            /*
                             * define global x,y position in range -1 < val < 1 
                             */
                            if (chipnumber[j] <= 0 || nxchip <= 0) {
                                fprintf(stderr,
                                        " error in identifying chip for image %d \n",
                                        j + 1);
                                exit(EXIT_FAILURE);
                            }
                            ichip = chipnumber[j] - 1;
                            ychip = ichip / nxchip;
                            xchip = ichip - ychip * nxchip;
                            xval =
                                (objx[j][i] +
                                 xchip * xchipsampling) / hxsize[j] - 1.;
                            yval = objy[j][i] + ychip * ychipsampling;
                            /*
                             * assume megacam geometry 
                             */
                            if (ychip > 0)
                                yval += big_gap;
                            if (ychip > 2)
                                yval += big_gap;
                            yval = yval / hysize[j] - 1.;
                            for(pixel = 0; pixel < (pwidth * pheight);
                                pixel++) {
                                globalreconstruct(xval, yval, forder,
                                                  crossterm, chipvariation,
                                                  chiporder, ichip, nchips,
                                                  acoeffs[j][pixel],
                                                  &psf[nt][pixel]);
                            }
			    globalreconstruct(xval, yval, sorder,
					      scrossterm, schipvariation,
					      schiporder, ichip, nchips,
					      xcoeffs[j], &shift[nt][0]);
			    globalreconstruct(xval, yval, sorder,
					      scrossterm, schipvariation,
					      schiporder, ichip, nchips,
					      ycoeffs[j], &shift[nt][1]);
                        }

                        /*
                         * measure the psf ellipticity and centroid 
                         */
                        psfmoments(psf[nt], pheight, pwidth,
                                   psfevals[nt][jim], centroid, pmoments);
                        psfe[0] = psfevals[nt][jim][0];
                        psfe[1] = psfevals[nt][jim][1];
                        psfemod = sqrt(psfe[0] * psfe[0] + psfe[1] * psfe[1]);

                        /*
                         * normalise each - measure normalisation only within 8 pixels radius 
                         * consistent with makepsfsurface.  Also find the values of the maximum
                         * and minimum psf pixel values and the location of the maximum 
                         */
                        normvalue = 0.;
                        maximumvalue = 0.;
                        minimumvalue = 0.;
                        peakpos = 0;
			xs = (int)(psfposerror[j]+0.99);
                        for(yy = -xs; yy <= xs; yy++) 
			  {
			    y = yy >= 0 ? yy : yy + pheight;
                            for(xx = -xs; xx <= xs; xx++) 
			      {
                                if (xx * xx + yy * yy <= psfposerror[j]*psfposerror[j]) 
				  {
                                    x = xx >= 0 ? xx : xx + pwidth;
                                    pixel = x + y * pwidth;
                                    val = psf[nt][pixel];
                                    normvalue += val;
                                    if (val > maximumvalue) 
				      {
                                        maximumvalue = val;
                                        peakpos = x + y * pwidth;
				      }
                                    if (val < minimumvalue)
				      minimumvalue = val;
				  }
			      }
			  }

                        /*
                         * location of maximum 
                         */
                        y = peakpos / pwidth;
                        x = peakpos - y * pwidth;
                        if (y >= pheight / 2)
                            y -= pheight;       // recentre relative to origin
                        if (x >= pwidth / 2)
                            x -= pwidth;

                        /*
                         * check the normalisation of the input PSF is sensible.  
                         * Also check whether the peak position is off the centre, or if there
                         * is a distinct secondary maximum, or if the PSF exceeds the specified
                         * ellipticity limit, or if there is a large negative minimum value,
                         * or if the PSF shift is too large.
                         * Disqualify any that fail these criteria.
                         * Keep a count of how many are disqualified 
                         */

                        if (
			    // normvalue < 0.97 || normvalue > 1.03 || 
			    psfemod > psfelimit
                            || x > 1 || x < -1 || y > 1 || y < -1 
			    || minimumvalue < -0.1 * maximumvalue)
                            // || (shift[nt][0]*shift[nt][0]+shift[nt][1]*shift[nt][1]) > 0.2*0.2 )
                        {
			  // printf(" bad psf %f %f %d %d %f %f \n",normvalue,psfemod,x,y,minimumvalue,maximumvalue);
                            numbadpsf[nt]++;    // number of bad PSFs this thread
                            badid[nt][j]++;     // number of bad PSFs, this image this thread
                            if (psfemod > psfelimit)
                                ellipticalpsf[nt][j]++; // number of too-elliptical PSFs, this image this thread
                            printf("bad PSF %s %d %f %f %f %f \n",image_file[j],i,xval,yval,normvalue,psf[nt][0]);fflush(stdout);
                            extractedobject[j][i] = -1;
                            numgoodpix[i][jim] = 0;
                            free(Dreal[i][jim]);
                            Dreal[i][jim] = NULL;
                            memd[nt] -=
                                (float) pwidth *pheight * sizeof(double);
                        } else {
                            numgoodpsf[nt]++;
                            goodid[nt][j]++;
                            /*
                             * adjust PSF by the small normalisation correction 
                             */
			    /*
                            for(y = 0; y < pheight; y++) {
                                for(x = 0; x < pwidth; x++) {
                                    pixel = x + y * pwidth;
                                    psf[nt][pixel] =
                                        psf[nt][pixel] / normvalue;
                                }
                            }
			    */

                            /*
                             * keep a note of the mean PSF ellipticity averaged over the multiple
                             * images, for each object, and output this at the end 
                             */
			    /*
                            meanpsfe[0] += weight[j]*psfe[0];
                            meanpsfe[1] += weight[j]*psfe[1];
                            meanstrehl += weight[j]*psf[nt][0];
			    */
                            meanpsfe[0] += psfe[0];
                            meanpsfe[1] += psfe[1];
                            meanstrehl += psf[nt][0];
			    sumw += weight[j];

                            /*
                             * create Fourier transforms of each PSF.  
                             * These will then be stored in
                             * the arrays B as defined in the plan above  
                             */
                            fftw_execute(p[nt][nimcheck]);

                            //printf("PSF fft done \n");fflush(stdout);

			    if (PRINT_SHIFTS == 1) 
			      {
				pthread_mutex_lock(&shiftsfilelock);
				fprintf(shiftsfile,
					" %6d %10.5lf %10.5lf %s %2d %s %2d %5.2lf %5.2lf \n",
					i, wcsx[i], wcsy[i],
					exposurename[j], chipnumber[j],
					exposurename[j], chipnumber[j],
					-shift[nt][0], -shift[nt][1]);
				// fflush(shiftsfile);
				pthread_mutex_unlock(&shiftsfilelock);
			      }
			    /* If flag is set, 
			     correct for pixelisation and PSF centroid shift 
			     otherwise
			     just correct for pixelisation shift
			     */
			    if (APPLY_GLOBALSHIFTS == 1)
			      {
				// add pixelisation and centroid to existing shift
				shift[nt][0] +=
				  objx[j][i] - (int) (objx[j][i] + 0.5) -
				  centroid[0];
				shift[nt][1] +=
				  objy[j][i] - (int) (objy[j][i] + 0.5) -
				  centroid[1];
			      }
			    else
			      {
				// ignore globalshift and just calculate pixelisation shift
				shift[nt][0] =
				  objx[j][i] - (int) (objx[j][i] + 0.5);
				shift[nt][1] =
				  objy[j][i] - (int) (objy[j][i] + 0.5);
			      }
                            
                            /*
                             * if this flag is negative, do not apply any pixel shifts 
                             */
                            if (SUBPIXEL_SHIFT >= 0) {
                                if (SUBPIXEL_SHIFT != 1) {
                                    /*
                                     * if this switch is zero, don't allow subpixel shifts 
                                     */
                                    shift[nt][0] =
                                        (double) ((int) (shift[nt][0] + 10.5)
                                                  - 10);
                                    shift[nt][1] =
                                        (double) ((int) (shift[nt][1] + 10.5)
                                                  - 10);
                                }
                                /*
                                 * shift the PSF 
                                 */
                                shiftft(pheight, pwidth, B[nt][nimcheck],
                                        shift[nt]);
                            }

                            /*
                             * set the image weight 
                             */
                            nimweight[nt][nimcheck] = weight[j];

                            /*
                             * calculate the weighted noise per pixel 
                             */
                            if (noise[j] > 0.) {
                                noiseperpixel[i] +=
                                    1. / (noise[j] * noise[j]);
                            } else {
                                fprintf(stderr,
                                        " erroneous noise value <=0 image %d \n",
                                        j + 1);
                                exit(EXIT_FAILURE);
                            }

                            /*
                             * make sure we choose the right data postage stamp that goes with this PSF
                             * (because of the multiple threads we can't assume that the postage stamps
                             * have been filled-up in the same order as the images are stored).
                             * Do this by setting a new pointer to the appropriate postage stamp
                             * and also storing the appropriate datasq value in a new array 
                             */
                            Dp[nt][nimcheck] = D[i][extractedobject[j][i]];
			    // set pointer to distortion parameters (note the actual values will be changed later)
			    tdist[nt][nimcheck] = edist[i][extractedobject[j][i]];
			    // data-squared value for likelihood calculation
                            datasqp[nt][nimcheck] =
                                datasq[i][extractedobject[j][i]];
                            // set up a check array as this has got a bit complex
                            checkimage[nt][nimcheck] = j;

                            /*
                             * increment number of successful images for this object 
                             */
                            nimcheck++;

                        }
                    }
                }

                //if (i==91025) printf(" PSFs calculated, object %d nimcheck %d \n",i,nimcheck);fflush(stdout);

		int skip_fitting;
		skip_fitting=0;

		if (skip_fitting==1)
		  {
		    // exit the loop early for testing
		    for (j=0; j<nimages; j++)
		      {
			jj = extractedobject[j][i];
			if (jj>=0)
			  {
			    // free this image now it's no longer needed
			    free(Dreal[i][jj]);
			    Dreal[i][jj] = NULL;
			    // extractedobject[j][i]=-1;
			    memd[nt] -= (float) pwidth *pheight * sizeof(double);
			  }
		      }
		    nim[i]=nimcheck=0;
		  }

                /*
                 * because of the possible exclusion of objects by the cosmic ray threshold,
                 * it may be that nimcheck is less than nim[i].  It shouldn't be more though 
                 */
                if (nimcheck > nim[i]) {
                    printf
                        (" number of extracted images do not agree for object %d \n",
                         i);
                    exit(EXIT_FAILURE);
                }

		if (nimcheck==0) noexposures[nt]++;

		if (nimcheck>0 && sumw>0.) 
		  {       
		    /*
		    meanpsfe[0] /= sumw;
		    meanpsfe[1] /= sumw;
		    meanstrehl /= sumw;
		    */
		    meanpsfe[0] /= (double)nimcheck;
		    meanpsfe[1] /= (double)nimcheck;
		    meanstrehl /= (double)nimcheck;

		    // find the largest scale factor in pixel/radian
		    meanscalefactor = 0.;
		    for (jj=0; jj<nimcheck; jj++)
		      {
			tscalefactor = sqrt((tdist[nt][jj][0]+tdist[nt][jj][3])*(tdist[nt][jj][0]+tdist[nt][jj][3])+
					    (tdist[nt][jj][2]-tdist[nt][jj][1])*(tdist[nt][jj][2]-tdist[nt][jj][1]))/2.;
			if (tscalefactor > meanscalefactor) meanscalefactor = tscalefactor;
		      }
		    // scale distortion matrix by this factor
		    for (jj=0; jj<nimcheck; jj++)
		      {
			for (ii=0; ii<4; ii++)
			  {
			    tdist[nt][jj][ii] /= meanscalefactor;
			  }
			/*
			tscalefactor = sqrt((tdist[nt][jj][0]+tdist[nt][jj][3])*(tdist[nt][jj][0]+tdist[nt][jj][3])+
					    (tdist[nt][jj][2]-tdist[nt][jj][1])*(tdist[nt][jj][2]-tdist[nt][jj][1]))/2.;
			costheta = (tdist[nt][jj][0]+tdist[nt][jj][3])/2./tscalefactor;
			sintheta = (tdist[nt][jj][2]-tdist[nt][jj][1])/2./tscalefactor;
			// rotation-corrected shear
			ap = (tdist[nt][jj][0]-tdist[nt][jj][3])*costheta - (tdist[nt][jj][1]+tdist[nt][jj][2])*sintheta ;
			bp = (tdist[nt][jj][0]-tdist[nt][jj][3])*sintheta + (tdist[nt][jj][1]+tdist[nt][jj][2])*costheta ;
			ap = ap/tscalefactor/2.;
			bp = bp/tscalefactor/2.;
			printf("%d %d %f %f %f %f %f\n",i,jj,tscalefactor,costheta,sintheta,ap,bp);
			*/
		      }
		    /* printf("\n"); */
		    // convert scalefactor to arcsec/pixel
		    if (meanscalefactor > 0.)
		      {
			meanscalefactor = 1./meanscalefactor; // convert to radian/pixel
			meanscalefactor *= 180.*3600./pi;   // convert to arcsec/pixel
			//printf(" object %d scalefactor %lf \n",i,meanscalefactor);
		      }
		    else
		      {
			fflush(stdout);
			fprintf(stderr,"error: pixel scalefactor = %lf \n",meanscalefactor);
			exit(EXIT_FAILURE);
		      }
		  }
		else
		  {
		    meanpsfe[0] = 0.;
		    meanpsfe[1] = 0.;
		    meanstrehl = 0.;
		    if (defaultmeanscalefactor <= 0.)
		      {
			fflush(stdout);
			fprintf(stderr,"error: default scale factor = %lf\n",defaultmeanscalefactor);
			exit(EXIT_FAILURE);
		      }
		    meanscalefactor = defaultmeanscalefactor;
		  }

		/*
		 * create the prior distribution for this object 
		 */
		sump = sumprior = 0.;

		/*
		if (nt==0)
		  {
		    printf(" test prior functions: \n");
		    for (emod=0.; emod<efunc_emax; emod += 0.1)
		      {
			eeprior = (1.-bulgepopfrac)*exp(efunc(emod)) + bulgepopfrac*exp(bulgefunc(emod));
			printf("emod %f  prior %f %f %f \n",emod,efunc(emod),bulgefunc(emod),eeprior);
		      }
		  }
		*/

		for(ne = 0; ne < nume; ne++) {
		  emod = sqrt(e1[ne] * e1[ne] + e2[ne] * e2[ne]);
		  eeprior = (1.-bulgepopfrac)*exp(efunc(emod)) + bulgepopfrac*exp(bulgefunc(emod));
		  sumprior += eeprior;
		  eprior[nt][ne] = log(eeprior);
		}	
		/* 
		 * normalise - the r-prior is already normalised assuming integration over the
		 * range of r.  The efunc ellipticity prior is not precisely normalised, so here find the
		 * sum over all ellipicity points and renormalise the total prior
		 */
		if (sumprior > 0.) {
		  sumprior = log(sumprior);
		} else {
		  fprintf(stderr, " error normalising prior \n");
		  exit(EXIT_FAILURE);
		}
		for(ne = 0; ne < nume; ne++) {
		  eprior[nt][ne] -= sumprior;
		}
		for(nRo = 1; nRo < numR; nRo++) {
		  // NB assumes this prior defined IN ARCSEC not pixels, and all models have same scalelength prior
		  // NB priors are stored as log 
		  Rarcsec = Ro[nRo]*meanscalefactor;
		  rprior[nt][nRo] = rfunc(Rarcsec, catmag[i]);
		}

                /*
                 * find the maximum likelihood for this object if it
                 * has been extracted with a psf found
		 * and if it has enough exposures
                 */
                if (nimcheck >= minexposurenumber) {

		    ncall[nt] = 0;
		    nmarfail[nt] = 0;

                    /*
                     * start by fitting an unresolved (r=0)(stellar) model  
                     */
                    modelnum = nRo = ne = 0;       /* doesn't matter which ellipticity we choose as long as r=0 */
                    //printf(" star fit object %d nimcheck %d \n",i,nimcheck); fflush(stdout);
                    zerolikel = likelihood(nt, nimcheck, nRo, ne, modelft[modelnum][0], modelft[modelnum][1]);
                    // printf(" star fit OK %d %lf \n",i,zerolikel); fflush(stdout);

		    // if null fit was returned from star fit, apply default minimum likelihood value
		    if (zerolikel <= UNSATISFACTORY_VALUE)
		      {
			zerolikel = -0.5*sumdata[nt];
			printf(" star log(likelihood) reset to %g object %d\n",zerolikel,i+1);
		      }

		    maxchisq = NOT_MEASURED;
                    maxchisqpos = 0;
                    for(ic = 0; ic < (pwidth * pheight); ic++) {
                        if (chisq[nt][ic] > maxchisq) {
                            maxchisq = chisq[nt][ic];
                            maxchisqpos = ic;
                        }
                    }
                    if (WRITE_CHISQ_SURFACES == 1) {
                        for(ic = 0; ic < (pwidth * pheight); ic++) {
                            bestchisq[ic + i * pwidth * pheight] =
                                chisq[nt][ic];
                        }
                        galselected[i] = 1;
                        spos[i][0] = objx[0][i];
                        spos[i][1] = objy[0][i];
                    }

                    bulgeflux = starflux = modelflux[nt][0][1];
                    diskflux = modelflux[nt][0][0];
                    bestsize = 0.;      // best-fitting scalelength
                    rmar[i] = 0.;  // marginalised scalelength
                    starbestpos[0] = bestpos[0] = mshift[nt][modelnum][0];
                    starbestpos[1] = bestpos[1] = mshift[nt][modelnum][1];
                    maxlikel = NOT_MEASURED;
		    peaklikel[nt] = NOT_MEASURED;

                    //printf("start %f %f %f %d\n",bulgeflux,diskflux,bestsize,bestne);

                    /*
                     * now fit galaxy models 
                     */

                    if (zerolikel > UNSATISFACTORY_VALUE) {
		      /*
		       * set initial values for likelihood arrays.  This value indicates
		       * no calculations have yet been made for this ne value.  A value of NOT_MEASURED
		       * indicates that this parameter has not been investigated yet. A value
		       * of UNSATISFACTORY_VALUE indicates that calculations have been made but no satisfactory likelihood
		       * maximum was found.  Any other value indicates some success  
		       */
		      for (ne=0;ne<(nume*numR);ne++) 
			{
			  likel[nt][ne]=NOT_MEASURED;
			}
		      for (ne=0; ne<nume; ne++) marP[nt][ne]= NOT_MEASURED;
		      maxlikel = NOT_MEASURED;
		      
		      /* start with coarse grid search, approx sampled at coarse_e_sampling, 
			 must be a power of two factor of basic grid */
		      sampling = (int)(.001+log(coarse_e_sampling/e_interval)/log(2.));
		      sampling = (int)(.001+pow(2.,(double)sampling));
		      if (sampling < 1) sampling = 1;
		      initsampling = sampling;

		      // set starting ellipticity at zero
		      bestne = numzero;
		      // define the set of values to be measured 
		      for(ne = 0; ne < nume; ne++) {
			wanted[nt][ne] = 0;
			new_wanted[nt][ne] = 0;
		      }
		      wanted[nt][bestne] = 1;
		    
		      // set starting galaxy scalelength from median of prior distribution
		      tmag = catmag[i] - refmag;
		      // median galaxy size at this magnitude in pixels
		      aval = exp(afit[0] + afit[1]*tmag)/meanscalefactor;
		      bestnRo = 0;
		      while (bestnRo < numR && Ro[bestnRo] < aval)
			bestnRo++;

		      initnRo = bestnRo;

		      if (i==0 || (i==0 && nmax==1)) {
		      printf(" object %d magnitude %f initial scalelength %d %f \n",i+1,catmag[i],bestnRo,Ro[bestnRo]);
		      fflush(stdout);
		      }

		      /* so now we have a single ellipticity value to be tested, together with
			 an estimate of the best scalelength.  Go through a coarse grid in
			 ellipticity and scalelength and expand the ellipticity array until
			 it seems we encompass the range needed */
		      
		      // set default "not fitted" values		      
		      for (ne=0; ne<nume; ne++)
			{
			  fittednRo[nt][ne] = fittedrstep[nt][ne] = -1;
			}
		      maxrposterior[nt] = NOT_MEASURED;
		    
		      /* start at the starting position, measure grid points around that, and 
			 try stepping to a new maximum.  Also adjust the grid
			 sampling to match the width of the distribution */

		      // make two loops, the first one to find the maximum in posterior, log(P)
		      // the second one to then find the maximum in log(L) given the points
		      // that define the maximum posterior (hopefully preferentially selects
		      // the peak favoured by the prior in cases of multimodal likelihood surfaces)

		      for (Ploop=0; Ploop<2; Ploop++) {

			e_iter = 0; // number of inner loop iterations
			e_iter_limit = 100;  // safeguard limit on number of iterations
			oldsampling = initsampling;

			// convert maximum r posterior to maximum r likelihood
			if (Ploop==1) 
			  {
			    oldsampling = 4;
			    if (oldsampling > initsampling) oldsampling = initsampling;
			    maxrposterior[nt] -= eprior[nt][bestne];
			  }

			// increase the sampling precision to zoom in on the likelihood peak
			for (sampling=oldsampling; sampling>=1; sampling /= 2) {

			  maxrfitvals = NOT_MEASURED;
			  oldbestne = nume+1;
			  // inner loop to iterate to best position in ellipticity at this sampling
			  while (bestne != oldbestne && e_iter < e_iter_limit) {
			    
			    oldbestne = bestne;

			    // expand the set of wanted points
			    nexpand=0; np = 1;
			    while (nexpand < 5 && np>0) {
			      np = expand_wanted(nt, sampling, sampling);
			      nexpand += np;
			    }
			    //printf(" thread %d object %d iter %d %d, %d new points in expanded array\n",
			    //	   nt, i+1, Ploop, e_iter, nexpand);
			    //fflush(stdout);

			    // loop through ellipticity grid to measure likelihoods
			    for(ne = 0; ne < nume; ne++) {
			      if (wanted[nt][ne] == 1) {
				if (fittednRo[nt][ne] > -1)
				  {
				    bestnRo = fittednRo[nt][ne];
				  }
				else
				  {
				    bestnRo = initnRo;
				  }
				// if this point has been done before, then just repeat the calls
				// as before - it won't take much time as the likelihood function
				// values will be remembered inside findmaxr
				if (fittedrstep[nt][ne] > -1)
				  {
				    rstep = fittedrstep[nt][ne];
				    nret = findmaxr (Ploop, nt, nimcheck, bestnRo, ne, rstep, rfitvals[nt][ne]);
				    if (nret >= 2)
				      {
					fflush(stdout);
					fprintf(stderr," error from recall of findmaxr, nret = %d object %d\n",nret,i+1);
					//exit(EXIT_FAILURE);
				      }
				    if (i==0 || (i==0 && nmax==1)) {
				    printf("already fitted object %d iter %d %d ne %d rstep %d bestnRo %d nret %d\n",
				    	   i+1, Ploop, e_iter, ne, rstep, bestnRo, nret);
				    fflush(stdout);
				    }
				  }
				else
				  {
				    // otherwise iterate to refine the step interval in r
				    rstep = 2*initrstep;
				    newrstep = initrstep;
				    nstep = 0;
				    if (i==0 || (i==0 && nmax==1)) {
				    printf("new input object %d iter %d %d ne %d rstep %d bestnRo %d \n",
				    	   i+1, Ploop, e_iter, ne, newrstep, bestnRo);
				    fflush(stdout); 
				    }
				    while (newrstep != rstep && nstep < 8)
				      {
					nstep++;
					rstep = newrstep;
					nret = findmaxr (Ploop, nt, nimcheck, bestnRo, ne, rstep, rfitvals[nt][ne]);
					// if successful, try to improve the rstep interval and update best position
					if (nret<2)
					  {
					    // update step interval
					    if (nret==0)
					      newrstep = 1 + 
						(int)((sqrt(rfitvals[nt][ne][0]+rfitvals[nt][ne][2])-sqrt(rfitvals[nt][ne][0]))/Rinterval);
					    // find closest grid point below the current best-fit
					    bestnRo = numR-1;
					    while ( Ro[bestnRo] > rfitvals[nt][ne][0] && bestnRo>1)
					      {
						bestnRo--;
					      }
					    // store scalelength at maximum and the rstep parameter
					    // for use in the marginalisation stage
					    fittednRo[nt][ne] = bestnRo;
					    fittedrstep[nt][ne] = rstep;
					    // remember the max discrete posterior value to be used when marginalising
					    if (rfitvals[nt][ne][4] > maxrposterior[nt])
					      {
						maxrposterior[nt] = rfitvals[nt][ne][4];
					      }
					  }
				      }
				    if (i==0 || (i==0 && nmax==1)) {
				    printf("new fitting object %d iter %d %d ne %d rstep %d bestnRo %d last nret %d\n",
				    	   i+1, Ploop, e_iter, ne, rstep, bestnRo, nret);
				    fflush(stdout); 
				    }
				  }
				
				// find the maximum
				if (nret<2)
				  {
				    if (rfitvals[nt][ne][1] > maxrfitvals)
				      {
					maxrfitvals = rfitvals[nt][ne][1];
					bestne = ne;
				      }
				    if (rfitvals[nt][ne][4] > maxrfitvals)
				      {
					maxrfitvals = rfitvals[nt][ne][4];
					bestne = ne;
				      }
				  }
			      }
			    }

			    // propagate scalelength values across ellipticity array
			    // these values will get replaced as the iterations proceed
			    propagate_scalelengths(nt);
			    
			    //printf(" thread %d object %d loop %d iteration %d sampling %d max %g at best e %f %f \n",
			    //nt, i+1, Ploop, e_iter, sampling, maxrfitvals, e1[bestne], e2[bestne]);
			    //fflush(stdout);

			    // reset the wanted point to a single maximum
			    for (ne=0; ne<nume; ne++) wanted[nt][ne] = 0;
			    wanted[nt][bestne] = 1;
			  
			    e_iter++;
			    // next inner loop, tests if the position of the maximum has changed
			  }

			}

			if (e_iter >= e_iter_limit)
			  {
			    printf(" warning: object %d iteration limit exceeded when finding maximum, loop %d\n",
				   i+1, Ploop);
			    fflush(stdout);
			  }
			
		      }

		      //if (VERBOSE==1)
		      printf(" object %d maximum found after %d calls \n",i+1, ncall[nt]);

		      //fflush(stdout);

		      /* The above values were not marginalised over scalelength. Now
			 go through the grid at this sampling and build up a surface of
			 likelihood values, down to some threshold below the maximum.
			 At each point in
			 ellipticity space, we will fit a spline to the posterior as
			 a function of galaxy scalelength, and use that to marginalise
			 over scalelength */

		      // speed up the process by propagating the current set of bestnRo values
		      // across the ellipticity array, to act as starting points for the
		      // marginalisation
		      propagate_scalelengths(nt);

		      exception = 0;
		      maxlikel = maxposterior = NOT_MEASURED;
		      for (ne=0; ne<nume; ne++) marP[nt][ne] = NOT_MEASURED;
		      nmorelimit = 100;

		      // iterate to keep expanding the sampled array until both posterior
		      // and likelihood fall below threshold
		      nmore = 0;
		      more = 1;
		      oldsampling = sampling = initsampling;
		      while (more==1 && nmore < nmorelimit && maxrfitvals > NOT_MEASURED)
			{
			  more = 0;
			  
			  // remember the current set of wanted samples
			  for (ne=0; ne<nume; ne++) old_wanted[nt][ne] = wanted[nt][ne];

			  // expand the set of wanted points
			  nexpand=0; np = 1;
			  while (nexpand < 5 && np>0) {
			    np = expand_wanted(nt, sampling, oldsampling);
			    nexpand += np;
			  }
			  oldsampling = sampling;
			  if (currentobject[nt]==printlikel) {
			  printf(" pass %d object %d %d points added to array\n",nmore, i+1, nexpand);
			  for (ne=0; ne<nume; ne++)
			    {
			      if (wanted[nt][ne]==1)
				printf(" %f",e1[ne]);
			    }
			  printf("\n");
			  for (ne=0; ne<nume; ne++)
			    {
			      if (wanted[nt][ne]==1)
				printf(" %f",e2[ne]);
			    }
			  printf("\n");
			  for (ne=0; ne<nume; ne++)
			    {
			      if (wanted[nt][ne]==1)
				printf(" %f",marP[nt][ne]);
			    }
			  printf("\n");
			  fflush(stdout);
			  }
			  
			  // loop through this set of points and measure marginalised likelihood
			  new = 0;
			  for (ne=0; ne<nume; ne++)
			    {
			      if (wanted[nt][ne] == 1) 
				{
				  // marginalise over scalelength at this ellipticity
				  // if this sample has not been attempted before, try now
				  // or if it was attempted and failed on the first pass
				  if (marP[nt][ne] == NOT_MEASURED)
				    {
				      bestnRo = fittednRo[nt][ne];
				      if (bestnRo < 0)
					{
					  // failsafe condition (should not occur)
					  bestnRo = initnRo;
					}
				      rstep = fittedrstep[nt][ne];
				      if (rstep<1)
					{
					  // if the r distribution has not been probed before, do it now
					  rstep = 2*initrstep;
					  newrstep = initrstep;
					  nstep = 0;
					  while (newrstep != rstep && nstep < 8)
					    {
					      Ploop = 1; 
					      nstep++;
					      rstep = newrstep;
					      nret = findmaxr (Ploop, nt, nimcheck, bestnRo, ne, rstep, rfitvals[nt][ne]);
					      // if successful, try to improve the rstep interval and update best position
					      if (nret<2)
						{
						  // update step interval
						  if (nret==0)
						    newrstep = 1 + 
						      (int)((sqrt(rfitvals[nt][ne][0]+rfitvals[nt][ne][2])-sqrt(rfitvals[nt][ne][0]))/Rinterval);
						  // find closest grid point below the current best-fit
						  bestnRo = numR-1;
						  while ( Ro[bestnRo] > rfitvals[nt][ne][0] && bestnRo>1)
						    {
						      bestnRo--;
						    }
						  // store scalelength at maximum and the rstep parameter
						  // for use in the marginalisation stage
						  fittednRo[nt][ne] = bestnRo;
						  fittedrstep[nt][ne] = rstep;
						  // remember the max discrete posterior value to be used when marginalising
						  if (rfitvals[nt][ne][4] > maxrposterior[nt])
						    {
						      maxrposterior[nt] = rfitvals[nt][ne][4];
						    }
						}

					    }
					  if (currentobject[nt]==printlikel) {printf(" new %f %f nret %d bestnRo %d rstep %d \n",e1[ne],e2[ne],nret,bestnRo,rstep);}
					}
				      else
					{
					  if (currentobject[nt]==printlikel) {printf(" already %f %f bestnRo %d rstep %d \n",e1[ne],e2[ne],bestnRo,rstep);}
					}
				      if (rstep > 0)
					{
					  // marginalise.  Marginalised values are returned in marP[nt][ne]
					  // the exception count keeps track of the number of integration errors
					  exception += marginaliser(nt, i, nimcheck, bestnRo, rstep, ne, zerolikel);
					  new++;
					  if (currentobject[nt]==printlikel) {printf(" marginaliser %f %f marP %f \n",e1[ne],e2[ne],marP[nt][ne]);}
					}
				    }
				  // if there is a valid return, remember it
				  if (marP[nt][ne] > NOT_MEASURED)
				    {
				      priorval = eprior[nt][ne];
				      posterior = marP[nt][ne] + priorval;
				      likelval = marP[nt][ne];
				      if (likelval > maxlikel) maxlikel = likelval;
				      if (posterior > maxposterior) maxposterior = posterior;
				    }
				  // otherwise flag it as "tried but not successful"
				  // unless this was the first pass, in which case leave
				  // it as "not tried" in case propagate_scalelengths
				  // needs to be done
				  else 
				    {
				      if (sampling < initsampling)
					marP[nt][ne] = NOT_MEASURED;
				    }
				}
			    }
			  
			  if (currentobject[nt]==printlikel) {
			  printf(" pass %d object %d %d points tested\n",nmore, i+1, nexpand);
			  for (ne=0; ne<nume; ne++)
			    {
			      if (wanted[nt][ne]==1)
				printf(" %f",e1[ne]);
			    }
			  printf("\n");
			  for (ne=0; ne<nume; ne++)
			    {
			      if (wanted[nt][ne]==1)
				printf(" %f",e2[ne]);
			    }
			  printf("\n");
			  for (ne=0; ne<nume; ne++)
			    {
			      if (wanted[nt][ne]==1)
				printf(" %f",marP[nt][ne]);
			    }
			  printf("\n");
			  fflush(stdout);
			  }

			  //printf("thread %d object %d %d new points tried\n",nt,i+1,new);
			  //fflush(stdout);

			  // set likelihood thresholds at Lcut, Pcut
			  Lthreshold = maxlikel + log(Lcut);
			  Pthreshold = maxposterior + log(Pcut);
			  // go through and keep any points above either threshold
			  numwanted = 0;
			  for (ne=0; ne<nume; ne++)
			    {
			      wanted[nt][ne] = 0;
			      likelval = marP[nt][ne];
			      if (likelval > NOT_MEASURED)
				{
				  posterior = likelval + eprior[nt][ne];
				  if (likelval > Lthreshold || posterior > Pthreshold)
				    {
				      wanted[nt][ne]=1;
				      numwanted++;
				    }
				}
			    }
			  
			  // check to see whether new points have been added, stop
			  // iterations if not
			  for (ne=0; ne<nume; ne++)
			    {
			      if (old_wanted[nt][ne]==0 && wanted[nt][ne]==1 )
				{
				  //printf(" thread %d object %d added %d\n",nt,i+1,ne);
				  // array has changed: set iterations flag
				  more = 1;
				}
			    }
			  //printf(" thread %d object %d iteration calls %d\n",nt,i+1,ncall[nt]);		  
			  //fflush(stdout);

			  // if we are just at the end of the first coarse sampling pass,
			  // propagate the best-fit restep and bestnRo values across the array to fill in any holes
			  // this should speed up the marginalisation part for subsequent passes
			  if (sampling==initsampling && more==0)
			    propagate_rstep_values(nt);

			  // test if enough points have been added, change the sampling and
			  // continue iterating if not
			  if (more==0)
			    {
			      if (numwanted < minsamplepoints && sampling > 1)
				{
				  sampling /= 2;
				  more = 1;
				}
			    }

			  nmore++;
			  // next iteration if more=1
			}

		      // check number of iterations
		      if (nmore >= nmorelimit)
			{
			  fflush(stdout);
			  fprintf(stderr, " iteration limit exceeded thread %d object %d\n",nt,i+1);
			  exit(EXIT_FAILURE);
			}

		      if (exception > 0)
			printf(" object %d had %d integration errors \n",i+1, exception);
		      
		      if (VERBOSE==1)
			{
			  printf(" object %d %d marginalisation iterations %d sampled points\n",i+1,nmore,numwanted);
			  printf(" object %d sampling %d total calls %d \n",i+1,sampling,ncall[nt]);
			}

		      fflush(stdout);

		      // strip out unwanted marP values
		      for (ii = 0; ii < nume; ii++)
			{
			  if (wanted[nt][ii] == 0)
			    marP[nt][ii] = NOT_MEASURED;
			}
		      
		      /*
		       * test whether star fits are preferred over
		       * galaxy fits if either their peak likelihood
		       * is higher or if the ratio of
		       * log(likelihood) exceeds an F-test value
		       * that takes into account the number of
		       * degrees of freedom of the star and galaxy
		       * models
		       */

		      // pick up the highest individual likelihood (set in function likelihood)
		      Lmaxlikel = peaklikel[nt];
		      
		      // star galaxy statistic 
		      ndf = 0; 		      // number of data points 
		      for(jj = 0; jj < nimcheck; jj++) {
			ndf += numgoodpix[i][jj];
		      }
		      fval = 0.;
		      fprob[i] = 0.;
		      if (ndf > 7 && zerolikel > NOT_MEASURED
			  && Lmaxlikel > NOT_MEASURED && zerolikel != 0.) {
			fval = Lmaxlikel * (ndf - 3) / zerolikel / (ndf - 7);
			if (fval > 0.)
			  fprob[i] = gsl_cdf_fdist_Q(fval,(double) (ndf - 7),(double) (ndf - 3));
		      }

		      /*
		       * make an initial star/galaxy
		       * classification if the star model fits
		       * better.  this will be enhanced at the
		       * end using fprob when all galaxies have
		       * been measured
		       */
		      if (zerolikel + 0.5 * sumdata[nt] > 7.035
			  && zerolikel > NOT_MEASURED
			  && zerolikel > Lmaxlikel) {
			if (fitclass[i] == 0)
			  {
			    starfit[nt]++;
			    fitclass[i] = 1;
			  }
			Lmaxlikel = zerolikel;
		      }
		      /*
		       * otherwise if a useful fit was
		       * found... (95 probability for 7 dof)
		       */
		      else if (Lmaxlikel + 0.5 * sumdata[nt] > 7.035) {
			/*
			 * contruct summed normalised
			 * posterior distribution in size and
			 * calculate means and sensitivity
			 * terms
			 */

			// marginalised scalelength 
			sump = 0.;
			rmar[i] = 0.;
			for(ne = 0; ne < nume; ne++)
			  {
			    if (marP[nt][ne] > NOT_MEASURED)
			      {
				rmar[i] += rmarvals[nt][ne] * exp(marP[nt][ne] - maxposterior + eprior[nt][ne]);
				sump += exp(marP[nt][ne] - maxposterior + eprior[nt][ne]);
			      }
			  }
			if (sump > 0.)
			  rmar[i] /= sump;
			else
			  rmar[i] = 0.;
		      
			// normalise the posterior probability surface  
			beta = 0.;
			for(ne = 0; ne < nume; ne++)
			  {
			    if (marP[nt][ne] > NOT_MEASURED) {
			      // subtract the maximum value to keep numbers within sensible range 
			      marP[nt][ne] -= maxlikel;
			      beta += exp(marP[nt][ne]) * pow((e_interval*sampling),2);
			    }
			  }
			if (beta > 0.)
			  {
			    beta = log(beta);
			    if (fitclass[i] == 0)
			      goodfit[nt]++;

			    // find maxima
			    maxposterior = maxlikel = NOT_MEASURED;
			    for(ne = 0; ne < nume; ne++) {
			      if (marP[nt][ne] > NOT_MEASURED) {
				marP[nt][ne] -= beta;
				if (marP[nt][ne] > maxlikel) maxlikel = marP[nt][ne];
				posterior = marP[nt][ne] + eprior[nt][ne];
				if (posterior > maxposterior) maxposterior = posterior;
			      } 
			    }
			    // create table specifying which e values have been measured 
			    nlist = 0;
			    for(ne = 0; ne < nume; ne++) {
			      // only keep points that are more than 10^-5 of peak if fine mesh
			      if (marP[nt][ne] > NOT_MEASURED)
				{
				  posterior = marP[nt][ne] + eprior[nt][ne];
				  if (sampling >= initsampling ||
				      posterior > maxposterior - 11.51 ||
				      marP[nt][ne] > maxlikel - 11.51) {
				    etable[nt][nlist] = ne;
				    ltable[nt][nlist] = (float) marP[nt][ne];
				    nlist++;
				  }
				}
			    }
			  }
			else
			  {
			    fflush(stdout);
			    fprintf(stderr," error normalising marP, beta = %g \n",beta);
			    fprintf(stderr," object %d\n",i+1);
			    if (fitclass[i] >= -4)
			      fitclass[i] = -3;
			  }

		      if (VERBOSE==1)
			printf("object %d has %d samples in output list \n",i+1,nlist);

		      fflush(stdout);		      

		      // make an approximate marginalisation over ellipticity and scalelength
		      // to find marginalised bulge and disk fluxes
		      maxposterior = NOT_MEASURED;
		      if (nlist>0)
			{
			  for (nne=0; nne < nlist; nne++)
			    {
			      ne = etable[nt][nne];
			      if (ne >= 0 && ne < nume)
				{
				  for (nRo=0; nRo<numR; nRo++)
				    {
				      modelnum = nRo*nume + ne;
				      if (likel[nt][modelnum] > NOT_MEASURED)
					{
					  posterior = likel[nt][modelnum] + rprior[nt][nRo] + eprior[nt][ne];
					  if (posterior > maxposterior)
					    {
					      maxposterior = posterior;
					      bestsize = Ro[nRo];
					      bestne = ne;
					      bestpos[0] = mshift[nt][modelnum][0];
					      bestpos[1] = mshift[nt][modelnum][1];
					    }
					}
				    }
				}
			    }
			  for (nRo=0; nRo<numR; nRo++) rposterior[nt][nRo] = 0.;
			  if (maxposterior > NOT_MEASURED)
			    {
			      diskflux = bulgeflux = sumw = dshift[0] = dshift[1] = 0.;
			      for (nne=0; nne < nlist; nne++)
				{
				  ne = etable[nt][nne];
				  if (ne>=0 && ne < nume)
				    {
				      for (nRo=0; nRo<numR; nRo++)
					{
					  modelnum = nRo*nume + ne;
					  if (likel[nt][modelnum] > NOT_MEASURED)
					    {
					      posterior = likel[nt][modelnum] + rprior[nt][nRo] + eprior[nt][ne];
					      mval = exp(posterior-maxposterior);
					      bulgeflux += mval*modelflux[nt][modelnum][1];
					      diskflux += mval*modelflux[nt][modelnum][0];
					      dshift[0] += mval*mshift[nt][modelnum][0];
					      dshift[1] += mval*mshift[nt][modelnum][1];
					      sumw += mval;
					    }
					  // also co-add the posterior distributions in r
					  if (nRo>0)
					    rposterior[nt][nRo] += exp(interp_rval[nt][modelnum]-maxrposterior[nt]);
					}
				    }
				}
			    }
			  else
			    {
			      fflush(stdout);
			      fprintf(stderr," error, failed to find maximum when marginalising bulge flux\n");
			      exit(EXIT_FAILURE);
			    }
			  if (sumw > 0.)
			    {
			      bulgeflux /= sumw;
			      diskflux /= sumw;
			      dshift[0] /= sumw;
			      dshift[1] /= sumw;
			    }
			  else
			    {
			      fflush(stdout);
			      fprintf(stderr," error, no valid sum when marginalising bulge flux\n");
			      exit(EXIT_FAILURE);
			    }

			  
			  printf(" object %d fitted positions %f %f %f %f\n",
				 i+1,bestpos[0],bestpos[1],dshift[0],dshift[1]);
			  fflush(stdout);
			  		      
			  // disqualify galaxies whose marginalised centroid is outside poserror
			  // (indicates contamination by background objects)
			  if (dshift[0]*dshift[0]+dshift[1]*dshift[1]>poserror*poserror ||
			      bestpos[0]*bestpos[0]+bestpos[1]*bestpos[1]>poserror*poserror
			      ) {
			    if (fitclass[i] == 0) goodfit[nt]--;
			    fitclass[i] = -7;
			    badfit[nt]++;
			  } 

			  // normalise the r posterior distribution
			  beta = 0.;
			  for (nRo=1; nRo<numR; nRo++)
			    {
			      beta += rposterior[nt][nRo];
			    }
			  if (beta>0.)
			    {
			      for (nRo=1; nRo<numR; nRo++)
				{
				  rposterior[nt][nRo] /= beta;
				}
			    }
			} else {
			// no valid marginalised likelihood measurements found
			if (fitclass[i]>-1)
			  {
			    fitclass[i] = -3;
			    badfit[nt]++;
			  }
		      }
		      } else {
			// log(L) too low to indicate detection of an object
			if (fitclass[i]>-1)
			  {
			    notdetected[nt]++;
			    fitclass[i] = -3;
			  }
		      }
		    } else {
		      // no valid fit was found for point source (zerolikel < NOT_MEASURED)  
		      if (fitclass[i]>-1)
			{
			  badfit[nt]++;
			  fitclass[i] = -3;
			}
                    }
                } else {
		  // insufficient valid image data extracted 
		      if (fitclass[i]>=-1)
			{
			  nodata[nt]++;
			  fitclass[i] = -1;
			}
                }
            } else {
	      // insufficient useful images found for this galaxy 
	      if (fitclass[i]>=-1)
		{
		  nodata[nt]++;
		  fitclass[i] = -1;
		}
            }

	    if (nimcheck>0 && nimcheck<minexposurenumber) toofewexposures[nt]++;

	    // occasionally all nume values are used - implies bad shape of likelihood surface, disqualify
	    if (nlist >= nume) {
	      printf(" disqualifying likelihood surface for object %d\n",i+1); fflush(stdout);
	      fflush(stdout);
	      nlist = 0;
	      if (fitclass[i]==0)
		goodfit[nt]--;
	      badfit[nt]++;
	      fitclass[i] = -3;
	    }
    
	    // make sure bad fits have zero scalelength
            // if (fitclass[i] != 0 && fitclass[i] > -4) rmar[i] = 0.;

	    // set the output row number in the FITS table
            row = i + 1;

            /*
             * work out chi-squared and reduced chi-squared of the best-fitting model.  
             * Flag badly-fitting galaxies based on reduced chi-squared 
             */

            bulgefraction = 0.;
            totalflux = 0.;
            if (maxposterior > NOT_MEASURED) {
                totalflux = bulgeflux + diskflux;
                if ( (fitclass[i] == 0 || fitclass[i]<-4) && totalflux > 0.)
                    bulgefraction = bulgeflux / totalflux;
                totalflux = totalflux * noiserefval;    /* calibration back to counts per image */
                chisquared = -2. * maxposterior;

                /*
                 * number of degrees of freedom, use count of good pixels 
                 */
                ndf = -6;
                for(jj = 0; jj < nimcheck; jj++) {
                    ndf += numgoodpix[i][jj];
                }

                if (ndf > 100)  // enough valid pixels conributing to chisq?
                {
                    reducedchisq = chisquared / (float) (ndf);
                    if (reducedchisq > 1.4)     // reduced chisq too big?
                    {
                        if (fitclass[i] >= 0)   // if valid fit, disqualify
                        {
                            goodfit[nt]--;
                            chisqcut[nt]++;
                            fitclass[i] = -4;
                        }
                    }
                }
                if (ndf <= 100 && fitclass[i] == 0) {
                    // if not enough pixels, disqualify
                    reducedchisq = 0.;
                    goodfit[nt]--;
                    chisqcut[nt]++;
                    fitclass[i] = -4;
                }
            } else {
                // if no valid likelihood measurement made
                chisquared = 0.;
                reducedchisq = 0.;
            }

            if (fitclass[i] < 0 && fitclass[i] >= -2) {
                // if bad likelihood or bad data/psf reset chisquared to zero
                chisquared = 0.;
                reducedchisq = 0.;
            }

            /*
             * if valid galaxy or star fit as been found, create the best-fitting model, fit it
             * to the data and measure chi-squared within the region where the model is significant 
	     */ 
            if (fitclass[i] >= 0) {
                //printf("making model, object %d \n",i); fflush(stdout);
                if (fitclass[i] == 1) {
                    // if star, use best-fitting star values
                    modelnum = 0;
		    nRo=0;
		    bestne=0;
                    diskflux = starflux;
                    bulgeflux = 0.;
                    bestpos[0] = starbestpos[0];
                    bestpos[1] = starbestpos[1];
                } else {
                    // otherwise use best-fitting galaxy parameters
                    nRo = 0;
                    while (Ro[nRo] < bestsize)
                        nRo++;
                    modelnum = nRo * nume + bestne;
                }
	    
		thisnim = 0;    // index counter for valid images (must be the same as used in the likelihood loop above)
                rndf = -6;      // set number of degrees of freedom to negative number of free parameters
                pvalmax = 0.;   // maximum deviation between model and data
                rchisq = rechisq = 0.;
                rprob = 0.;
                cross0 = cross1 = mcross0 = mcross1 = mcross2 = 0.;
                sumysq = sumy0 = sumy1 = 0.;
                tsumysq = tsumy0 = tsumy1 = 0.;
                for(pixel = 0; pixel < pwidth * pheight; pixel++)
                    sn[nt][pixel] = 0.;;
                // printf("calculating chi-squared, object %d \n",i); fflush(stdout);
                for(j = 0; j < nimages; j++) {
                    jj = extractedobject[j][i];
                    if (jj >= 0) {
                        /*
                         * because the images were read in with multiple threads, the images for each
                         * object may not be stored sequentially.  Check that we're accessing the image
                         * we think we should! If we get this wrong, the PSFs and data cubes will be mismatched 
                         */
                        if (checkimage[nt][thisnim] != j) {
                            fflush(stdout);
                            fprintf(stderr, "error matching images \n");
                            fprintf(stderr, "  object, image %d %d %d %d \n",
                                    i, j, jj, checkimage[nt][thisnim]);
                            exit(EXIT_FAILURE);
                        }
                        // shift PSF according to best-fit position from likelihood
                        // note that PSFs are stored in the original image order, whereas the data stamps may not be
                        shiftft(pheight, pwidth, B[nt][thisnim], bestpos);
                        // fourier convolve model with PSF and inverse transform it
                        convolvemodel(pinv[nt], B[nt][thisnim],
                                      modelft[modelnum], pheight, pwidth,
                                      C[nt]);
                        // crossproducts for amplitude remeasurement
                        for(y = 0; y < pheight; y++) {
                            for(x = 0; x < pwidth; x++) {
                                pixel = x + y * pwidth;
                                mcross0 +=
                                    c[nt][0][pixel] * c[nt][0][pixel] *
                                    weight[j];
                                mcross1 +=
                                    c[nt][1][pixel] * c[nt][1][pixel] *
                                    weight[j];
                                mcross2 +=
                                    c[nt][0][pixel] * c[nt][1][pixel] *
                                    weight[j];
                                cross0 +=
                                    Dreal[i][jj][pixel] * c[nt][0][pixel] *
                                    weight[j];
                                cross1 +=
                                    Dreal[i][jj][pixel] * c[nt][1][pixel] *
                                    weight[j];
                                tsumysq +=
                                    Dreal[i][jj][pixel] *
                                    Dreal[i][jj][pixel] * weight[j];
                                tsumy0 +=
                                    Dreal[i][jj][pixel] * c[nt][0][pixel] *
                                    weight[j];
                                tsumy1 +=
                                    Dreal[i][jj][pixel] * c[nt][1][pixel] *
                                    weight[j];
                            }
                        }
                        // next image/psf index number
                        thisnim++;
                        if (thisnim > nimcheck) {
                            fflush(stdout);
                            fprintf(stderr,
                                    " error counting images when making best-fit models, object %d image %d %d %d %d \n",
                                    i, j, jj, thisnim, nimcheck);
                            exit(EXIT_FAILURE);
                        }
                    }
                }

                // check amplitudes and recalculate chisq as in likelihood
                // first check model two-component cross-correlation
                if (mcross2 > 0.) {
                    mcross0 = mcross0 / mcross2;
                    mcross1 = mcross1 / mcross2;
                    denom = mcross0 * mcross1 - 1.;
                    cross0 = cross0 / mcross2;
                    cross1 = cross1 / mcross2;
                } else {
                    // probably star model stored in component [1], component [0] is empty
                    if (mcross0 <= 0.) {
                        mcross0 = 0.;
                        mcross2 = 1.;   // set this to avoid problems later
                        denom = 0.;
                        if (mcross1 <= 0.) {
                            fflush(stdout);
                            fprintf(stderr,
                                    " remake model error at object %d, all cross-components zero or negative \n",i+1);
                            exit(EXIT_FAILURE);
                        }
                    }
                    // otherwise model error
                    else {
                        fflush(stdout);
                        fprintf(stderr,
                                " remake model error at object %d, zero cross-component \n",i+1);
                        exit(EXIT_FAILURE);
                    }
                }
                if (fabs(denom) > 0.01) {
                    amp0 = (mcross1 * cross0 - cross1) / denom;
                    amp1 = (mcross0 * cross1 - cross0) / denom;
                    //printf(" direct amps %f %f %f %f \n",amp0,amp1,cross0/mcross0,cross1/mcross1);
                    if (amp0 < 0.) {
                        amp0 = 0.;
                        amp1 = 0.;
                        if (mcross1 > 0.)
                            amp1 = cross1 / mcross1;
                        if (amp1 < 0.)
                            amp1 = 0.;
                    }
                    if (amp1 < 0.) {
                        amp0 = 0.;
                        amp1 = 0.;
                        if (mcross0 > 0.)
                            amp0 = cross0 / mcross0;
                        if (amp0 < 0.)
                            amp0 = 0.;
                    }
                } else {
                    amp0 = 0.;
                    amp1 = 0.;
                    // set single-component model amplitudes
                    if (mcross0 > 0.)
                        amp0 = cross0 / mcross0;
                    if (mcross1 > 0.)
                        amp1 = cross1 / mcross1;
                    // choose best-fit single model
                    if (amp0 * cross0 > amp1 * cross1)
                        amp1 = 0.;
                    else
                        amp0 = 0.;
                    if (amp0 < 0.)
                        amp0 = 0.;
                    if (amp1 < 0.)
                        amp1 = 0.;
                }
                // reset bulge/disk flux values
                //bulgeflux = amp1;
                //diskflux = amp0;
                // reset output values (total flux and bulgefraction)
                totalflux = bulgeflux + diskflux;
                if (fitclass[i] == 0 && totalflux > 0.)
                    bulgefraction = bulgeflux / totalflux;
                totalflux = totalflux * noiserefval;    /* calibration back to counts per image */


                // go through again and use the component amplitudes to calculate chi-squared in central region
                thisnim = 0;
		profile_sn_num = profile_sn_denom = 0.;
		for(j = 0; j < nimages; j++) {
                    jj = extractedobject[j][i];
                    if (jj >= 0) {
                        /*
                         * because the images were read in with multiple threads, the images for each
                         * object may not be stored sequentially.  Check that we're accessing the image
                         * we think we should! If we get this wrong, the PSFs and data cubes will be mismatched 
                         */
                        if (checkimage[nt][thisnim] != j) {
                            fflush(stdout);
                            fprintf(stderr, "error matching images \n");
                            fprintf(stderr, "  object, image %d %d %d %d \n",
                                    i, j, jj, checkimage[nt][thisnim]);
                            exit(EXIT_FAILURE);
                        }
                        /*
                         * PSF has already been shifted to best
                         * position (just above). Note that PSFs are
                         * stored in the original image order, whereas
                         * the data stamps may not be fourier convolve
                         * model with PSF and inverse transform it 
                         */
                        convolvemodel(pinv[nt], B[nt][thisnim],
                                      modelft[modelnum], pheight, pwidth,
                                      C[nt]);
                        // calculate chi-squared in area where model is significant
                        imchisq = 0.;
                        imndf = 0;
                        for(y = 0; y < pheight; y++) {
                            for(x = 0; x < pwidth; x++) {
                                pixel = x + y * pwidth;
                                // make galaxy model 
                                mval =
                                    bulgeflux * c[nt][1][pixel] +
                                    diskflux * c[nt][0][pixel];
				// accumulate summations for profile-weighted S/N ratio
				// (ignore "systematic" option)
				profile_sn_num += weight[j]*mval*Dreal[i][jj][pixel];
				profile_sn_denom += weight[j]*mval*mval;
                                /*
                                 * difference from data and accumulate chi-squared from pixels within useful region
                                 * where the useful region is if this contribution to chi-squared, summed over all
                                 * images, would be greater than 1 compared with no model.
                                 * Add onto the variance some allowed component of systematic error defined
                                 * as a fraction of the model 
                                 */
                                pval = (Dreal[i][jj][pixel] - mval) / 
				  sqrt(1./weight[j] + systematic*systematic*mval*mval);
                                //sn[nt][pixel] += pval*fabs(pval); // accumulate contributions to chi-squared (with sign)
                                sn[nt][pixel] += weight[j] * mval / nimcheck;   // accumulate summed model values
                                if (weight[j] * mval * mval * nimcheck >= 1.) {
                                    if (fabs(pval) > fabs(pvalmax))
                                        pvalmax = pval;
                                    rchisq += pval * pval;
                                    rndf++;
                                    imchisq += pval * pval;
                                    imndf++;
                                    // check sums
                                    sumysq +=
                                        Dreal[i][jj][pixel] *
                                        Dreal[i][jj][pixel] / (1. /
                                                               weight[j] +
                                                               systematic *
                                                               systematic *
                                                               mval * mval);
                                    sumy0 +=
                                        Dreal[i][jj][pixel] *
                                        c[nt][0][pixel] / (1. / weight[j] +
                                                           systematic *
                                                           systematic * mval *
                                                           mval);
                                    sumy1 +=
                                        Dreal[i][jj][pixel] *
                                        c[nt][1][pixel] / (1. / weight[j] +
                                                           systematic *
                                                           systematic * mval *
                                                           mval);
                                }

                            }
                        }
                        // test the contribution to chi-squared from this image
                        if (imndf > 0.) {
                            rprob = gsl_cdf_chisq_Q(imchisq, imndf);
                            if (rprob < 0.01)
                                nfail[j]++;
                            else
                                npass[j]++;
                        }
                        // free this image now it's no longer needed
                        free(Dreal[i][jj]);
                        Dreal[i][jj] = NULL;
                        // extractedobject[j][i]=-1;
                        memd[nt] -= (float) pwidth *pheight * sizeof(double);
                        // next image/psf index number
                        thisnim++;
                        if (thisnim > nimcheck) {
                            fflush(stdout);
                            fprintf(stderr,
                                    " error counting images when making best-fit models, object %d image %d %d %d %d \n",
                                    i, j, jj, thisnim, nimcheck);
                            exit(EXIT_FAILURE);
                        }
                    }
                }

		// calculate pofile-weighted S/N ratio
		if (profile_sn_denom > 0.)
		  profile_sn = profile_sn_num/sqrt(profile_sn_denom);
		else
		  profile_sn = 0.;

                // recalculate chi-squared values
                rechisq = sumysq - (amp0 * sumy0 + amp1 * sumy1);
                trechisq = tsumysq - (amp0 * tsumy0 + amp1 * tsumy1);

                // write out summed model in same order as postagestamps.fits
                if (nmtestobj < NTEST_LIMIT && nmtestobj < ntestobj) {
                    pthread_mutex_lock(&testlock);
                    if (nmtestobj < NTEST_LIMIT && nmtestobj < ntestobj) {
		      for (thisnim=0; thisnim<ntestobj; thisnim++)
			{
			  if (i == testobj[thisnim])
			    {
			      nmtestobj++;
			      for(y = 0; y < pheight; y++) {
				yy = y + pheight / 2;
				if (yy >= pheight)
				  yy -= pheight;
				for(x = 0; x < pwidth; x++) {
				  // swap quadrants
				  xx = x + pwidth / 2;
				  if (xx >= pwidth)
                                    xx -= pwidth;
				  pixel = x + y * pwidth;
				  ii = xx + yy * pwidth;
				  otestout[thisnim * pwidth * pheight + ii] =
                                    sn[nt][pixel];
				}
			      }
			      testimage[thisnim] = -1;
			      break;
			    }
			}
		    }
                    pthread_mutex_unlock(&testlock);
                }
                // check the chi-squared value from the above test and reject object if it fails
                if (rndf > 0) {
                    rprob = gsl_cdf_chisq_Q(rchisq, rndf);
		    /*
                    if (NTEST_LIMIT > 0) {
                        printf
                            ("chisq test: object %d %f %f %f %lf %f %f %f %f %f \n",
                             i, catmag[i], rndf, rchisq, rprob, pvalmax,
                             bulgeflux, diskflux, rechisq, trechisq);
                        fflush(stdout);
                    }
		    */
                    // if not a good fit at 5 percent level, disqualify this object if specified
                    // if largest pixel deviation is more than 4-sigma, reject
                    if (rprob < 0.05 || fabs(pvalmax) > 4.) {
		      // if blending rejection is turned on, assume that we're measuring shear
		      // and do not reject bad chisq galaxies, otherwise filter these out
		      if (DEBLENDING_REJECTION == 0 && REJECT_BAD == 1) {
			if (fitclass[i]==0) {
			  goodfit[nt]--;
			  chisqcut[nt]++;
			  fitclass[i] = -4;
			}
		      }
		      // always filter out star fits if the fit is bad
		      if (fitclass[i]==1) {
			  starfit[nt]--;
			  chisqcut[nt]++;
			  fitclass[i] = -4;
			}		
		    }
                } else {
		  /*
                    if (NTEST_LIMIT > 0)
                        printf("chisq test: object %d %f %f \n", i, catmag[i],
                               rndf);
                    fflush(stdout);
		  */
                }

            }

            /*
             * if valid noise per pixel has been accumulated finish the calculation 
             */
            if (noiseperpixel[i] > 0.) {
                noiseperpixel[i] = sqrt(1. / noiseperpixel[i]);
            } else {
                if (fitclass[i] >= 0) {
                    printf
                        (" error, zero noise found yet object %d has been fitted \n",
                         i);
                    exit(EXIT_FAILURE);
                }
            }

	    /*
             * lock fits file and psfgal array
             */
            pthread_mutex_lock(&fitsfilelock);

	    // measure and accumulate galaxy-PSF cross-correlation for each chip
	    if (fitclass[i] >= 0)
	      {
                for(j = 0; j < nimages; j++) {
		  jj = extractedobject[j][i];
		  if (jj >= 0) {
		    cross0 =
		      meane1 * psfevals[nt][jj][0] +
		      meane2 * psfevals[nt][jj][1];
		    //printf("psf %f %f %f %f %f \n",meane1,meane2,psfevals[nt][jj][0],psfevals[nt][jj][1],cross0);
		    psfgal[j] += cross0;
		    psfgalsq[j] += cross0 * cross0;
		    psfgaln[j]++;
		  }
                }
	      }

            // printf(" writing object %d \n",i); fflush(stdout);
            /*
             * write out to FITS file  
             */
	    /* catalogue id */
	    fits_write_col (ofptr[iter], TINT, 1, row, 1, 1, &catid[i], &status);
	    if (status) fits_report_error(stderr, status); /* print error message */
            /*
             * galaxy position (WCS coords from catalogue) 
             */
            fits_write_col(ofptr[iter], TDOUBLE, 2, row, 1, 1, &wcsx[i],
                           &status);
            fits_write_col(ofptr[iter], TDOUBLE, 3, row, 1, 1, &wcsy[i],
                           &status);
	    /* catalogue magnitude */
	    fits_write_col (ofptr[iter], TFLOAT, 4, row, 1, 1, &catmag[i], &status);
	    if (status) fits_report_error(stderr, status); /* print error message */
            /*
             * input image names and chip numbers used for this object, plus PSF ellipticities 
             */
            nimcheck = 0;
            lnmaximages = (long) nmaximages;
            for(j = 0; j < nmaximages; j++) {
                bzero(ostring[j], maximagefilelen);
                ochipnum[j] = -99;
                opsf0[j] = 0.;
                opsf1[j] = 0.;
            }
            for(j = 0; j < nimages; j++) {
                jj = extractedobject[j][i];
                if (jj >= 0) {
                    if (nimcheck < nmaximages) {
                        len = strlen(image_file[j]);
                        if (len >= maximagefilelen) len = maximagefilelen-1;
                        strncpy(ostring[nimcheck], image_file[j], len);
                        ochipnum[nimcheck] = chipnumber[j];
                        opsf0[nimcheck] = psfevals[nt][jj][0];
                        opsf1[nimcheck] = psfevals[nt][jj][1];
                        nimcheck++;
                    } else {
                        fflush(stdout);
                        fprintf(stderr,
                                " error write exposure info into fits table: too many exposures object %ld \n",
                                row);
                        exit(EXIT_FAILURE);
                    }
                }
            }
            fits_write_col(ofptr[iter], TSTRING, 5, row, 1, lnmaximages,
                           ostring, &status);
            fits_write_col(ofptr[iter], TINT, 6, row, 1, lnmaximages,
                           ochipnum, &status);
            fits_write_col(ofptr[iter], TDOUBLE, 7, row, 1, lnmaximages,
                           opsf0, &status);
            fits_write_col(ofptr[iter], TDOUBLE, 8, row, 1, lnmaximages,
                           opsf1, &status);
            /*
             * mean PSF ellipticity (2-component vector) 
             */
            fits_write_col(ofptr[iter], TDOUBLE, 9, row, 1, 2, meanpsfe,
                           &status);
            /*
             * mean PSF Strehl ratio 
             */
            fits_write_col(ofptr[iter], TDOUBLE, 10, row, 1, 1, &meanstrehl,
                           &status);
            /*
             * fitclass (0=good galaxy fit)  
             */
            fits_write_col(ofptr[iter], TINT, 11, row, 1, 1, &fitclass[i],
                           &status);
            /*
             * galaxy parameters: size, bulgefraction, total flux 
             */
            fits_write_col(ofptr[iter], TDOUBLE, 12, row, 1, 1, &rmar[i],
                           &status);
            fits_write_col(ofptr[iter], TDOUBLE, 13, row, 1, 1,
                           &bulgefraction, &status);
            fits_write_col(ofptr[iter], TDOUBLE, 14, row, 1, 1, &totalflux,
                           &status);
            /*
             * data-weighted S/N ratio returned from detectobject (NB this estimate is biased at low S/N)
             */
            fits_write_col(ofptr[iter], TDOUBLE, 15, row, 1, 1, &snratio[i],
                           &status);
            /*
             * profile-weighted S/N ratio
             */
            fits_write_col(ofptr[iter], TDOUBLE, 16, row, 1, 1, &profile_sn,
                           &status);
            /*
             * sampling of ellipticity grid  
             */
            fits_write_col(ofptr[iter], TINT, 17, row, 1, 1, &sampling,
                           &status);
            /*
             * this next column was sensitivity in previous versions (a two component vector)  
	     * now replace it with fprob and rprob
	     */
	    de[0] = fprob[i];
	    de[1] = rprob;
            fits_write_col(ofptr[iter], TDOUBLE, 18, row, 1, 2, de, &status);
            /*
             * list of e values (nlist values)  
             */
            if (nlist > 0) {
                fits_write_col(ofptr[iter], TINT, 19, row, 1, nlist,
                               etable[nt], &status);
                /*
                 * sampled probability surface (nlist values)  
                 */
                fits_write_col(ofptr[iter], TFLOAT, 20, row, 1, nlist,
                               ltable[nt], &status);
            }
            /*
             * accumulate array for median magnitude values in each mag bin 
             */
            /*
             * this array is accessed by all threads but should be threadsafe as inside mutex lock 
             */
            if (fitclass[i] == 0) {
                magarray[magbin][nmagarray[magbin]] = catmag[i];
                nmagarray[magbin]++;
            }

            /*
             * unlock fits file 
             */
            // printf(" object %d written, thread %d \n",i,nt); fflush(stdout);
            pthread_mutex_unlock(&fitsfilelock);

    }

    pthread_exit((void *) 0);

}


void *model_loop(void *threadargs)
{
  int ne, modelnum, nRo, num, nt;

  /* extract object and thread number from argument */
  struct threadindex *this_thread;
  this_thread = (struct threadindex *)threadargs;
  num = this_thread->objectnum;
  nt = this_thread->threadnum;

  for (nRo=nt; nRo<numR; nRo+=NUM_THREAD)
    {
      for (ne=0; ne<nume; ne++)
	{
	  modelnum = (nRo*nume + ne);
	  if (MODELS_3D == 1)
	    {
	      make3Dgalaxymodel (nt, modelft[modelnum], e1[ne], e2[ne], Ro[nRo]);
	    }
	  else
	    {
	      make2Dgalaxymodel(nt, modelft[modelnum], 
				     e1[ne], e2[ne], Ro[nRo]);
	    }
	}
    }

  pthread_exit((void*) 0);
      
}


int readludocat_dec2010(char *catname, int nexposures, int nchips, int startobj,
             int endobj, int startexp, int endexp, double *wx, double *wy,
             float **objx, float **objy, float *mag, int *id)
{
    FILE *catdata;
    float *xx, *yy;
    double wcsx, wcsy;
    float magsex;
    int *chip, image, i, sexid;
    char string[2000];
    int n, nn, nwantedexps;
    char delims[] = " \t";
    char *item = NULL;

    catdata = fopen(catname, "r");
    if (catdata == NULL) {
        printf(" failed to open file %s \n", catname);
        exit(EXIT_FAILURE);
    }

    n = 0;
    nn = 0;

    if (WCS != 1) {
        nwantedexps = endexp - startexp + 1;
        printf(" reading %d exposures \n", nwantedexps);

        if (nwantedexps <= 0 || startexp <= 0 || endexp > nexposures) {
            fprintf(stderr,
                    "error in specification of exposures in catalogue routine readnludo");
            fprintf(stderr, " exposures requested %d - %d \n", startexp,
                    endexp);
            exit(EXIT_FAILURE);
        }

        chip = (int *) calloc(nexposures, sizeof(int));
        xx = (float *) calloc(nexposures, sizeof(float));
        yy = (float *) calloc(nexposures, sizeof(float));

        if (chip == NULL || xx == NULL || yy == NULL) {
            printf(" memory allocation error in readnludocat \n");
            exit(EXIT_FAILURE);
        }
    }

    while (fgets(string, 2000, catdata) != NULL) {
        if (strncmp(string, "#", 1) != 0) {
            /*
             * read basic info, wcs coords, size, mag 
             */
            item = strtok(string, delims);
            if (item != NULL) {
                wcsx = atof(item);
            } else {
                fprintf(stderr, " error reading from catalogue \n");
                exit(EXIT_FAILURE);
            }
            item = strtok(NULL, delims);
            if (item != NULL) {
                wcsy = atof(item);
            } else {
                fprintf(stderr, " error reading from catalogue \n");
                exit(EXIT_FAILURE);
            }
            item = strtok(NULL, delims);
            if (item != NULL) {
                magsex = (float) atof(item);
            } else {
                magsex = 23.1;
            }                   // set an arbitrary sextractor magnitude - this IS used for the prior
            item = strtok(NULL, delims);
            if (item != NULL) {
                sexid = (int) atoi(item);
            } else {
	      sexid = n+1;
            }                   // get the ID number, not used by lensfit 

            /*
             * if we need the chip x,y positions, read these now 
             */
            if (WCS != 1) {
                /*
                 * read chip number and x,y positions for each exposure 
                 */
                for(i = 0; i < nexposures; i++) {
                    item = strtok(NULL, delims);
                    chip[i] = atoi(item);
                    item = strtok(NULL, delims);
                    xx[i] = atof(item);
                    item = strtok(NULL, delims);
                    yy[i] = atof(item);
                }
                if (item == NULL) {
                    fprintf(stderr, " end of line when reading catalogue \n");
                    exit(EXIT_FAILURE);
                }
            }

            n++;

            if (n >= startobj && n <= endobj) {
                wx[nn] = wcsx;
                wy[nn] = wcsy;
                mag[nn] = magsex;
		id[nn] = sexid;
                if (WCS != 1) {
                    for(i = 0; i < (nchips * nwantedexps); i++) {
                        objx[i][nn] = -999.;
                        objy[i][nn] = -999.;
                    }
                    for(i = 0; i < nwantedexps; i++) {
                        if (chip[i + startexp - 1] > 0
                            && chip[i + startexp - 1] <= nchips) {
                            image =
                                (chip[i + startexp - 1] - 1) * nwantedexps +
                                i;
                            objx[image][nn] = xx[i + startexp - 1];
                            objy[image][nn] = yy[i + startexp - 1];
                        }
                    }
                }
                nn++;
            }
        }
    }

    fclose(catdata);

    if (WCS != 1) {
        free(chip);
        free(xx);
        free(yy);
    }

    return nn;

}



double
likelihood(int nt, int nim, int nRo, int ne, float *ftd, float *ftb)
{
    double maxval, area;
    double realpart, impart, realpart1, impart1;
    double realdatapart, imagdatapart, sumC, likel, bulgelikel;
    double rsq, range, rangesq, xd, yd;
    double xmin, xmax, ymax, pedval, bulgepedval;
    double hsize, x0, y0, newmaxval;
    double amp[2], maxamp[2];
    double kx, ky, smaxval;
    double denom, crossdenom;
    double crossproduct[3];
    double arg1, arg2, arg3, r0, erfarg1, erfarg2, erfval, fprior;
    double bfpriornorm, logbfpriornorm;
    double maxlikel, flux, totalflux, fluxvar, fluxerr;
    double marbt, marbt0, expval, fluxmar, fluxmarbt, sumfluxmar;
    double error, complikel[2], dlikel;
    double bulgeprior, emod; 
    float *ft[2];
    int modelnum;
    int x1,y1,x2,y2,ipixel11,ipixel12,ipixel21,ipixel22,ipixel,opixel;
    int i, j, x, y, xx, yy, ix, iy, yx, mt, mtstart, istep;
    int newixmax, newiymax, ixmax, iymax, nfit, likelorder, crossterm, likelncoeffs;
    int nobjectpixels, more, pixel, newmaximum, dx;
    gsl_sf_result xc, yc;
    gsl_function marFlux;
    marFlux.function = &marflux;
    marFlux.params = &nt;
    int gsl_status;

    // record number of times the function has been called in this thread
    ncall[nt]++;

    // point to disk and bulge models
    ft[0] = ftd;
    ft[1] = ftb;

    /*
     * the likelihood from this code will be marginalised over
     * position assuming a top-hat prior of rads equal to the detection
     * limit of the galaxy
     * 
     * If there are neighbouring objects in the same extracted data
     * region, this significantly biases the position and value of
     * the likelihood peak, and hence it is important both to test
     * the position of the peak (to check it's consistent with being
     * associated only with the object being fitted) and to measure
     * its parameters robustly in a way that avoids contamination
     * from any other object(s).
     * 
     * Hence a likelihood peak will be sought only within a radius
     * range from the centre.  This range will be set to three times
     * the value of poserror, and if the peak is at larger radius 
     * the likelihood will be set to the default negative value
     * 
     * this version jointly fits two components bulge + disk and 
     * marginalises over the bulge fraction assuming a two component 
     * prior bulge fraction prior.  It also marginalises over flux
     * asuming a power-law prior in total flux
     */

    modelnum = nRo*nume + ne;
    mshift[nt][modelnum][0] = mshift[nt][modelnum][1] = 0.;

    // return if no images sent to this function
    if (nim <= 0) {
      if (currentobject[nt]==printlikel) printf(" likel: no images\n");
        likel = UNSATISFACTORY_VALUE;
        return likel;
    }

    /*
     * if the maximum of the cross-correlation is outside 
     * range of the nominal position at (0,0) this fit is rejected 
     */
    range = poserror;
    rangesq = range * range;

    /* apply the camera distortion to the Fourier-space models */
    // first expand the bulge and disk model arrays into a full set of positive and
    // negative frequencies (on input only half the elements are passed because the
    // model FT is an even function).  The expanded array duplicates the Nyquist frequencies.

    if (CORRECT_DISTORTION == 2)
      {

	for (mt=0; mt<2; mt++)
	  {
	    for (y=0; y<=halfpheight; y++)
	      {
		for (x=0; x<halfpwidth; x++)
		  {
		    ipixel = x + y*halfpwidth;
		    opixel = x + pwidth/2 + (halfpheight+y)*expandedwidth;
		    expandedft[nt][mt][opixel] = (double)ft[mt][ipixel];
		    opixel = (pwidth/2 - x) + (halfpheight-y)*expandedwidth;
		    expandedft[nt][mt][opixel] = (double)ft[mt][ipixel];
		  }
	      }
	    for (y=halfpheight; y<pheight; y++)
	      {
		for (x=0; x<halfpwidth; x++)
		  {
		    ipixel = x + y*halfpwidth;
		    opixel = x + pwidth/2 + (y-halfpheight)*expandedwidth;
		    expandedft[nt][mt][opixel] = (double)ft[mt][ipixel];
		    opixel = (pwidth/2 - x) + (halfpheight+pheight-y)*expandedwidth;
		    expandedft[nt][mt][opixel] = (double)ft[mt][ipixel];
		  }
	      }
	  }
	
	// transform & interpolate for each input image, with its own distortion
	for (i=0; i<nim; i++)
	  {
	    // for each model type (disk or bulge)
	    for (mt=0; mt<2; mt++)
	      {
		// interpolate, positive frequencies
		for (y=0; y<halfpheight; y++)
		  {
		    for (x=0; x<halfpwidth; x++)
		      {
			// apply transform remembering to transpose distortion matrix
			xd = tdist[nt][i][0]*x + tdist[nt][i][2]*y;
			yd = tdist[nt][i][1]*x + tdist[nt][i][3]*y;
			// find neighbouring integer grid points in expandedft array
			x1 = (int)(halfpwidth+xd)-1;
			x2 = x1+1;
			// check against hard array boundaries and reset if necessary
			while (x2 >= expandedwidth || x1 >= expandedwidth)
			  {
			    x2--;
			    x1--;
			  }
			while (x2 < 0 || x1 < 0)
			  {
			    x2++;
			    x1++;
			  }
			y1 = (int)(halfpheight+yd);
			y2 = y1+1;
			while (y2 >= expandedheight || y1 >= expandedheight)
			  {
			    y2--;
			    y1--;
			  }
			while (y2 < 0 || y1 < 0)
			  {
			    y2++;
			    y1++;
			  }
			// find these locations in the 2D arrays
			ipixel11 = x1 + y1*expandedwidth;
			ipixel12 = x1 + y2*expandedwidth;
			ipixel21 = x2 + y1*expandedwidth;
			ipixel22 = x2 + y2*expandedwidth;
			opixel = x+y*halfpwidth;
			// bilinear interpolate
			interpft[nt][i][mt][opixel] = 
			  (halfpheight+yd-y1)*(
					       (xd-x1+halfpwidth-1)*expandedft[nt][mt][ipixel22] + 
					       (x2-xd-halfpwidth+1)*expandedft[nt][mt][ipixel12]) +  
			  (y2-yd-halfpheight)*(
					       (xd-x1+halfpwidth-1)*expandedft[nt][mt][ipixel21] + 
					       (x2-xd-halfpwidth+1)*expandedft[nt][mt][ipixel11]);
		      }
		  }
		// interpolate, negative frequencies
		for (y=halfpheight; y<pheight; y++)
		  {
		    for (x=0; x<halfpwidth; x++)
		      {
			// apply transform remembering to transpose distortion matrix && convert y axis
			xd = tdist[nt][i][0]*x + tdist[nt][i][2]*(y-pheight);
			yd = tdist[nt][i][1]*x + tdist[nt][i][3]*(y-pheight);
			// find neighbouring integer grid points in expandedft array
			x1 = (int)(halfpwidth+xd)-1;
			x2 = x1+1;
			// check against hard array boundaries and reset if necessary
			while (x2 >= expandedwidth || x1 >= expandedwidth)
			  {
			    x2--;
			    x1--;
			  }
			while (x2 < 0 || x1 < 0)
			  {
			    x2++;
			    x1++;
			  }
			y1 = (int)(halfpheight+yd);
			y2 = y1+1;
			while (y2 >= expandedheight || y1 >= expandedheight)
			  {
			    y2--;
			    y1--;
			  }
			while (y2 < 0 || y1 < 0)
			  {
			    y2++;
			    y1++;
			  }
			// find these locations in the expandedft array
			ipixel11 = x1 + y1*expandedwidth;
			ipixel12 = x1 + y2*expandedwidth;
			ipixel21 = x2 + y1*expandedwidth;
			ipixel22 = x2 + y2*expandedwidth;
			opixel = x+y*halfpwidth;
			// bilinear interpolate allowing extrapolation if needed
			interpft[nt][i][mt][opixel] = 
			  (halfpheight+yd-y1)*(
					       (xd-x1+halfpwidth-1)*expandedft[nt][mt][ipixel22] + 
					       (x2-xd-halfpwidth+1)*expandedft[nt][mt][ipixel12]) +  
			  (y2-yd-halfpheight)*(
					       (xd-x1+halfpwidth-1)*expandedft[nt][mt][ipixel21] + 
					       (x2-xd-halfpwidth+1)*expandedft[nt][mt][ipixel11]);
		      }
		  }
	      }
	  }
      } else {
      // if models are not to be distortion corrected, copy model FT unchanged into the interpft array

      for (i=0; i<nim; i++)
	{
	  // for each model type (disk or bulge)
	  for (mt=0; mt<2; mt++)
	    {
	      for (y=0; y<pheight; y++)
		{
		  for (x=0; x<halfpwidth; x++)
		    {
		      opixel = y*halfpwidth + x;
		      interpft[nt][i][mt][opixel] = (double)ft[mt][opixel];
		    }
		}
	    }
	}
    }

    /*
     * calculate the cross-correlation of the PSF-convolved models 
     */

    for(i = 0; i < 3; i++) 
      {
        crossproduct[i] = 0.;
      }
    sumdata[nt] = 0.;

    for(i = 0; i < nim; i++) 
      {
	// create sum of data squared
        sumdata[nt] += nimweight[nt][i] * datasqp[nt][i] * fsize;
        // work out crossproduct[2] if galaxy models (nRo > 0)
	if (nRo > 0)
	  {
	    for(y = 0; y < pheight; y++) {
	      x = 0;
	      yx = y * halfpwidth + x;
	      realpart = interpft[nt][i][0][yx] * creal(B[nt][i][yx]) / fsize;
	      impart = interpft[nt][i][0][yx] * cimag(B[nt][i][yx]) / fsize;
	      realpart1 = interpft[nt][i][1][yx] * creal(B[nt][i][yx]) / fsize;
	      impart1 = interpft[nt][i][1][yx] * cimag(B[nt][i][yx]) / fsize;
	      // excluding the zero-frequency component would be equivalent to
	      // allowing an unknown constant background offset, and then choosing
	      // the maximum-likelihood value for the background.  At present
	      // the zero-frequency is included, thereby assuming the 
	      // background is known precisely
	      //
	      //if (y>0)  /* exclude zero-freq component */
	      //{
	      crossproduct[2] +=
                nimweight[nt][i] * (realpart * realpart1 + impart * impart1);
	      //}
	      
	      x = halfpwidth - 1;
	      yx = y * halfpwidth + x;
	      realpart = interpft[nt][i][0][yx] * creal(B[nt][i][yx]) / fsize;
	      impart = interpft[nt][i][0][yx] * cimag(B[nt][i][yx]) / fsize;
	      realpart1 = interpft[nt][i][1][yx] * creal(B[nt][i][yx]) / fsize;
	      impart1 = interpft[nt][i][1][yx] * cimag(B[nt][i][yx]) / fsize;
	      crossproduct[2] +=
                nimweight[nt][i] * (realpart * realpart1 + impart * impart1);
	      
	      for(x = 1; x < (halfpwidth - 1); x++) {
                yx = y * halfpwidth + x;
		/* imaginary part of model is zero */
                realpart = interpft[nt][i][0][yx] * creal(B[nt][i][yx]) / fsize; 
                impart = interpft[nt][i][0][yx] * cimag(B[nt][i][yx]) / fsize;
                realpart1 = interpft[nt][i][1][yx] * creal(B[nt][i][yx]) / fsize;
                impart1 = interpft[nt][i][1][yx] * cimag(B[nt][i][yx]) / fsize;
                crossproduct[2] +=
		  2. * nimweight[nt][i] * (realpart * realpart1 +
					   impart * impart1);
	      }
	    }
	  }
      }

    crossproduct[2] = crossproduct[2] * fsize;

    /*
     * now calculate the relevant data-model crosscorrelation and model autocorrelations 
     */
    mtstart = 0;
    if (nRo==0) 
      {
	// if a star model, component [0] is empty, component [1] holds the star model
	mtstart=1;
	for (y=0; y<pheight; y++)
	  {
	    for (x=0; x<halfpwidth; x++)
	      {
		yx = x + y*halfpwidth;
		CC[nt][0][yx] = C[nt][0][yx] = 0.+0.*I;
	      }
	  }
	for (y=0; y<pheight; y++)
	  {
	    for (x=0; x<pwidth; x++)
	      {
		yx = x + y*pwidth;
		c[nt][0][yx] = 0.;
	      }
	  }
      }

    for(mt = mtstart; mt < 2; mt++) {
        sumC = 0.;
        C[nt][mt][0] = 0. + 0. * I;

        i = 0;

        for(y = 0; y < pheight; y++) {
            x = 0;
            yx = y * halfpwidth + x;
            realpart = interpft[nt][i][mt][yx] * creal(B[nt][i][yx]) / fsize;
            /*
             * imaginary part of model is zero 
             */
            impart = interpft[nt][i][mt][yx] * cimag(B[nt][i][yx]) / fsize;
            realdatapart = creal(Dp[nt][i][yx]);
            imagdatapart = cimag(Dp[nt][i][yx]);
            //if (y>0)     /* exclude zero-freq component */
            //{
            sumC +=
                nimweight[nt][i] * (realpart * realpart + impart * impart);
            C[nt][mt][yx] =
                (nimweight[nt][i] *
                 (realpart * realdatapart + impart * imagdatapart)) +
                (nimweight[nt][i] *
                 (realpart * imagdatapart - impart * realdatapart)) * I;
            //}

            x = halfpwidth - 1;
            yx = y * halfpwidth + x;
            realpart = interpft[nt][i][mt][yx] * creal(B[nt][i][yx]) / fsize;
            impart = interpft[nt][i][mt][yx] * cimag(B[nt][i][yx]) / fsize;
            sumC +=
                nimweight[nt][i] * (realpart * realpart + impart * impart);
            realdatapart = creal(Dp[nt][i][yx]);
            imagdatapart = cimag(Dp[nt][i][yx]);
            C[nt][mt][yx] =
                (nimweight[nt][i] *
                 (realpart * realdatapart + impart * imagdatapart)) +
                (nimweight[nt][i] *
                 (realpart * imagdatapart - impart * realdatapart)) * I;

            for(x = 1; x < (halfpwidth - 1); x++) {
                yx = y * halfpwidth + x;
                realpart = interpft[nt][i][mt][yx] * creal(B[nt][i][yx]) / fsize;       
		/* imaginary part of model is zero */
                impart = interpft[nt][i][mt][yx] * cimag(B[nt][i][yx]) / fsize;
                sumC +=
                    2. * nimweight[nt][i] * (realpart * realpart +
                                             impart * impart);
                realdatapart = creal(Dp[nt][i][yx]);
                imagdatapart = cimag(Dp[nt][i][yx]);
                C[nt][mt][yx] =
                    (nimweight[nt][i] *
                     (realpart * realdatapart + impart * imagdatapart)) +
                    (nimweight[nt][i] *
                     (realpart * imagdatapart - impart * realdatapart)) * I;
            }
        }

        if (nim > 1) {
            for(i = 1; i < nim; i++) {
                for(y = 0; y < pheight; y++) {
                    x = 0;
                    yx = y * halfpwidth + x;
                    realpart = interpft[nt][i][mt][yx] * creal(B[nt][i][yx]) / fsize;
                    /* imaginary part of model is zero */
                    impart = interpft[nt][i][mt][yx] * cimag(B[nt][i][yx]) / fsize;
                    realdatapart = creal(Dp[nt][i][yx]);
                    imagdatapart = cimag(Dp[nt][i][yx]);
                    //if (y>0)     /* exclude zero-freq component */
                    //{
                    sumC +=
                        nimweight[nt][i] * (realpart * realpart +
                                            impart * impart);
                    C[nt][mt][yx] +=
                        (nimweight[nt][i] *
                         (realpart * realdatapart + impart * imagdatapart)) +
                        (nimweight[nt][i] *
                         (realpart * imagdatapart -
                          impart * realdatapart)) * I;
                    //}

                    x = halfpwidth - 1;
                    yx = y * halfpwidth + x;
                    realpart = interpft[nt][i][mt][yx] * creal(B[nt][i][yx]) / fsize;
                    impart = interpft[nt][i][mt][yx] * cimag(B[nt][i][yx]) / fsize;
                    sumC +=
                        nimweight[nt][i] * (realpart * realpart +
                                            impart * impart);
                    realdatapart = creal(Dp[nt][i][yx]);
                    imagdatapart = cimag(Dp[nt][i][yx]);
                    C[nt][mt][yx] +=
                        (nimweight[nt][i] *
                         (realpart * realdatapart + impart * imagdatapart)) +
                        (nimweight[nt][i] *
                         (realpart * imagdatapart -
                          impart * realdatapart)) * I;

                    for(x = 1; x < (halfpwidth - 1); x++) {
                        yx = y * halfpwidth + x;
                        realpart = interpft[nt][i][mt][yx] * creal(B[nt][i][yx]) / fsize;       
			/* imaginary part of model is zero */
                        impart =
                            interpft[nt][i][mt][yx] * cimag(B[nt][i][yx]) / fsize;
                        sumC +=
                            2. * nimweight[nt][i] * (realpart * realpart +
                                                     impart * impart);
                        realdatapart = creal(Dp[nt][i][yx]);
                        imagdatapart = cimag(Dp[nt][i][yx]);
                        C[nt][mt][yx] +=
                            (nimweight[nt][i] *
                             (realpart * realdatapart +
                              impart * imagdatapart)) +
                            (nimweight[nt][i] *
                             (realpart * imagdatapart -
                              impart * realdatapart)) * I;
                    }
                }
            }
        }

        crossproduct[mt] = sumC * fsize;

	/* take the inverse c2r transform of this FT array to create the real-space cross-correlation
	   array.  For some reason this fftw transform does not preserve the input values 
	   (although the r2c transform does), so we must store the values separately. */
	for (y=0; y<pheight; y++)
	  {
	    for (x=0; x<halfpwidth; x++)
	      {
		yx = x + y*halfpwidth;
		CC[nt][mt][yx] = C[nt][mt][yx];
	      }
	  }

	fftw_execute(pinv[nt][mt]);

    }

    /*
     * printf (" vals %f %f %f %f %f ",
     * crossproduct[0],crossproduct[1],crossproduct[2],
     * c[nt][0][0],c[nt][1][0]); 
     */

    /*
     * now combine cross-correlations to get best fit 
     */

    maxval = UNSATISFACTORY_VALUE;
    ixmax = 0;
    iymax = 0;

    if (nRo > 0 && crossproduct[2] > 0.) {
        crossproduct[0] = crossproduct[0] / crossproduct[2];
        crossproduct[1] = crossproduct[1] / crossproduct[2];
        crossdenom = crossproduct[0] * crossproduct[1] - 1.;
    } else {
        // probably star model stored in component [1], component [0] is empty
        if (nRo == 0) {
            crossproduct[0] = 0.;
            crossproduct[2] = 1.;       // set this to avoid problems later
            crossdenom = 0.;
            if (crossproduct[1] <= 0.) {
                fflush(stdout);
                fprintf(stderr,
                        " model error, all cross-components zero or negative \n");
                exit(EXIT_FAILURE);
            }
        }
        // otherwise model error
        else {
            fflush(stdout);
            fprintf(stderr, " model error, zero cross-component \n");
            exit(EXIT_FAILURE);
        }
    }

    // printf(" crossproducts %d %d %f %f %f %f \n",nt,nRo,crossproduct[0],crossproduct[1],crossproduct[2],fsize);

    for(y = 0; y < pheight; y++) {
        for(x = 0; x < pwidth; x++) {
            yx = y * pwidth + x;
            chisq[nt][yx] = 0.;
            amp[0] = 0.;
            amp[1] = 0.;
            c[nt][0][yx] = c[nt][0][yx] / crossproduct[2];
            c[nt][1][yx] = c[nt][1][yx] / crossproduct[2];
            // if we can tell the difference between a disk and a bulge, and it's not a star
            if (nRo > 0 && fabs(crossdenom) > 1.e-6) {
                amp[0] =
                    (crossproduct[1] * c[nt][0][yx] - c[nt][1][yx]) / crossdenom;
                amp[1] =
                    (crossproduct[0] * c[nt][1][yx] - c[nt][0][yx]) / crossdenom;
                if (amp[0] < 0.) {
                    amp[0] = 0.;
                    amp[1] = c[nt][1][yx] / crossproduct[1];
                    if (amp[1] < 0.)
                        amp[1] = 0.;
                }
                if (amp[1] < 0.) {
                    amp[1] = 0.;
                    amp[0] = c[nt][0][yx] / crossproduct[0];
                    if (amp[0] < 0.)
                        amp[0] = 0.;
                }
            }
            // otherwise choose the best single-component model (which might be a star)
            else {
                amp[0] = 0.;
                amp[1] = 0.;
                // set single-component model amplitudes
                if (crossproduct[0] > 0.)
                    amp[0] = c[nt][0][yx] / crossproduct[0];
                if (crossproduct[1] > 0.)
                    amp[1] = c[nt][1][yx] / crossproduct[1];
                // choose best-fit single model
                if (amp[0] * c[nt][0][yx] > amp[1] * c[nt][1][yx])
                    amp[1] = 0.;
                else
                    amp[0] = 0.;
                if (amp[0] < 0.)
                    amp[0] = 0.;
                if (amp[1] < 0.)
                    amp[1] = 0.;
            }

            /*
             * best-fit chi-squared value 
             * chisq[nt][yx] = amp[0]*amp[0]*crossproduct[0] +
             * amp[1]*amp[1]*crossproduct[1] +
             * 2*amp[0]*amp[1]*crossproduct[2] -
             * 2.*amp[0]*c[nt][0][yx] -
             * 2.*amp[1]*c[nt][1][yx];
             */

            chisq[nt][yx] =
                (-amp[0] * c[nt][0][yx] -
                 amp[1] * c[nt][1][yx]) * crossproduct[2];

            /*
             * convert to log(likelihood) 
             */
            chisq[nt][yx] = -0.5 * chisq[nt][yx];

	    /*
	    // apply a downweight to outer regions to guard against spurious blending
	    yy = y<pheight/2 ? y : y-pheight;
	    xx = x<pwidth/2  ? x : x-pwidth;
	    rsq = xx*xx + yy*yy;
	    if (rsq > rangesq)
	      {
		chisq[nt][yx] -= 0.5*(rsq - rangesq);
	      }
	    */

        }
    }

    /*
     * starting at the nominal position, work uphill towards the maximum (this forces
     * us to be looking at a maximum associated with the galaxy of interest and not a random
     * maximum elsewhere in the field) 
     */
    maxval = chisq[nt][0];
    ixmax = newixmax = 0;
    iymax = newiymax = 0;
    newmaximum = 1;
    dx = poserror/2;                     // start with a search box of full width poserror pixels
    while (newmaximum == 1) {
        newmaximum = 0;
        ixmax = newixmax;
        iymax = newiymax;
        for(y = iymax - dx; y <= iymax + dx; y++) {
            yy = y;
            if (y < 0) yy += pheight;
            if (y >= pheight) yy -= pheight;
            for(x = ixmax - dx; x <= ixmax + dx; x++) {
                xx = x;
                if (x < 0) xx += pwidth;
                if (x >= pwidth) xx -= pwidth;
                yx = xx + yy * pwidth;
                if (chisq[nt][yx] > maxval) {
                    maxval = chisq[nt][yx];
                    newixmax = xx;
                    newiymax = yy;
                    newmaximum = 1;
                }
            }
        }
        dx = 1;                 // decrease the search tolerance after the first pass
    }
    ixmax = newixmax;
    iymax = newiymax;

    // printf(" %d %d %f \n",ixmax,iymax,maxval); fflush(stdout);

    /*
     * recalculate best-fit amplitudes 
     */
    yx = iymax * pwidth + ixmax;
    maxamp[0] = 0.;
    maxamp[1] = 0.;
    if (nRo>0 && fabs(crossdenom) > 1.e-6) {
        maxamp[0] = (crossproduct[1] * c[nt][0][yx] - c[nt][1][yx]) / crossdenom;
        maxamp[1] = (crossproduct[0] * c[nt][1][yx] - c[nt][0][yx]) / crossdenom;
        if (maxamp[0] < 0.) {
            maxamp[0] = 0.;
            maxamp[1] = c[nt][1][yx] / crossproduct[1];
            if (maxamp[1] < 0.)
                maxamp[1] = 0.;
        }
        if (maxamp[1] < 0.) {
            maxamp[1] = 0.;
            maxamp[0] = c[nt][0][yx] / crossproduct[0];
            if (maxamp[0] < 0.)
                maxamp[0] = 0.;
        }
    } else {
        maxamp[0] = 0.;
        maxamp[1] = 0.;
        // set single-component model amplitudes
        if (crossproduct[0] > 0.)
            maxamp[0] = c[nt][0][yx] / crossproduct[0];
        if (crossproduct[1] > 0.)
            maxamp[1] = c[nt][1][yx] / crossproduct[1];
        // choose best-fit single model
        if (maxamp[0] * c[nt][0][yx] > maxamp[1] * c[nt][1][yx])
            maxamp[1] = 0.;
        else
            maxamp[0] = 0.;
        if (maxamp[0] < 0.)
            maxamp[0] = 0.;
        if (maxamp[1] < 0.)
            maxamp[1] = 0.;
    }

    /*
     * return if maxval <=0 
     */
    if (maxval <= 0.) {
        modelflux[nt][modelnum][0] = 0.;
        modelflux[nt][modelnum][1] = 0.;
        likel = -0.5 * (sumdata[nt]);
	if (currentobject[nt]==printlikel) printf(" likel: maxval = %f\n",maxval);
        return likel;
    }


    xmax = (float) ixmax;
    if (ixmax >= pwidth / 2)
        xmax -= pwidth;
    ymax = (float) iymax;
    if (iymax >= pheight / 2)
        ymax -= pheight;
    rsq = xmax * xmax + ymax * ymax;

    if (rsq > rangesq) {
      likel = UNSATISFACTORY_VALUE; // -0.5 * (sumdata[nt]);
      if (currentobject[nt]==printlikel) printf(" likel: maxval rsq %f > %f\n",rsq,rangesq);
      return likel;
    }

    /*
     * now fit a quadratic surface to the peak, both to measure the 
     * height of the peak more accurately, and also to get its width.
     * Because the array currently holds a quantity which is essentially
     * the square of the x-correlation function, it's better to model
     * the square-root of this function and then square the answer 
     * (possibly)
     */

    /*
     * only select points that are connected to the peak and are above
     * half the peak amplitude (same code as in extractdata_) 
     */


    for(i = 0; i < (pwidth * pheight); i++) {
        objpix[nt][i] = 0;
    }

    /*
     * start with the peak and its immediate neighbours 
     */

    nobjectpixels = 0;
    for(y = iymax - 1; y <= iymax + 1; y++) {
        iy = y;
        if (iy >= pheight)
            iy -= pheight;
        if (iy < 0)
            iy += pheight;
        for(x = ixmax - 1; x <= ixmax + 1; x++) {
            ix = x;
            if (ix >= pwidth)
                ix -= pwidth;
            if (ix < 0)
                ix += pwidth;
            yx = iy * pwidth + ix;
            objpix[nt][yx] = 1;
            connected[nt][nobjectpixels][0] = ix;
            connected[nt][nobjectpixels][1] = iy;
            nobjectpixels++;
        }
    }


    /*
     * add in any other pixels that are above one-sigma 
     */

    more = 1;
    while (more == 1) {
        more = 0;
        for(i = 0; i < nobjectpixels; i++) {
            for(y = connected[nt][i][1] - 1; y <= connected[nt][i][1] + 1;
                y++) {
                iy = y;
                if (iy >= pheight)
                    iy -= pheight;
                if (iy < 0)
                    iy += pheight;
                for(x = connected[nt][i][0] - 1; x <= connected[nt][i][0] + 1;
                    x++) {
                    ix = x;
                    if (ix >= pwidth)
                        ix -= pwidth;
                    if (ix < 0)
                        ix += pwidth;
                    pixel = ix + iy * pwidth;
                    // only allow other pixels to connect if they are bright enough
                    if (chisq[nt][pixel] > maxval / 1.359
                        && chisq[nt][pixel] > 6.0 / 1.359
                        && objpix[nt][pixel] == 0) {
                        connected[nt][nobjectpixels][0] = ix;
                        connected[nt][nobjectpixels][1] = iy;
                        objpix[nt][pixel] = 1;
                        nobjectpixels++;
                        more = 1;
                    }
                }
            }
        }
    }


    /*
     * load up the arrays for the svd fit 
     */
    /*
     * the cross-corelation function should be a Gaussian, so
     * take the log and fit a quadratic surface 
     */

    nfit = 0;
    hsize = sqrt((double) nobjectpixels) / 2.;
    for(y = 0; y < pheight; y++) {
        for(x = 0; x < pwidth; x++) {
            yx = y * pwidth + x;
            if (objpix[nt][yx] == 1) {
                yd = (double) y;
                if (y >= pheight / 2)
                    yd = (double) (y - pheight);
                xd = (double) x;
                if (x >= pwidth / 2)
                    xd = (double) (x - pwidth);
                xfit[nt][nfit] = xd / hsize;
                yfit[nt][nfit] = yd / hsize;
                wfit[nt][nfit] = 1.;
                if (chisq[nt][yx] > 0.) {
                    zfit[nt][nfit] = 0.5 * log(chisq[nt][yx]);
                } else {
                    zfit[nt][nfit] = -100;
                }
                nfit++;
            }
        }
    }

    /*
     * fit bivariate quadratic surface 
     */

    likelorder = 2;
    likelncoeffs = 6;
    crossterm = 0;

    for(i = 0; i <= likelncoeffs; i++) {
        w[nt][i] = 0.;
        for(j = 0; j <= likelncoeffs; j++) {
            u[nt][i][j] = 0.;
            v[nt][i][j] = 0.;
        }
    }

    /*
     * 2D polynomial fit 
     */
    svdfit2dsqc(xfit[nt], yfit[nt], zfit[nt], wfit[nt], nfit, likelorder,
                crossterm, avals[nt], u[nt], v[nt], w[nt]);

    /*
     * test if it's a sensible fit with a maximum within the specified radius 
     */
    denom = 4. * avals[nt][3] * avals[nt][6] - avals[nt][5] * avals[nt][5];
    if (avals[nt][6] < 0. && avals[nt][3] < 0. && denom > 0.) {
        area = hsize * hsize / sqrt(denom) / 2.;        /* s^2 in the notation of Miller et al */
        x0 = (avals[nt][5] * avals[nt][2] - 2. * avals[nt][4] * avals[nt][3]) / denom;
        y0 = (avals[nt][5] * avals[nt][4] - 2. * avals[nt][2] * avals[nt][6]) / denom;
        newmaxval = avals[nt][1] + avals[nt][2] * y0 + avals[nt][3] * y0 * y0
            + avals[nt][4] * x0 + avals[nt][5] * x0 * y0 + avals[nt][6] * x0 * x0;
        newmaxval = exp(2. * newmaxval);
        x0 = x0 * hsize;
        y0 = y0 * hsize;
        mshift[nt][modelnum][0] = x0;
        mshift[nt][modelnum][1] = y0;
        if (x0 * x0 + y0 * y0 > rangesq) {
	  newmaxval = UNSATISFACTORY_VALUE; // -0.5 * (sumdata[nt]);
	  if (currentobject[nt]==printlikel) printf(" likel: fitted maxval rsq %f > %f\n",x0*x0+y0*y0,rangesq);
	  return newmaxval;
        }
    } else {
      newmaxval = UNSATISFACTORY_VALUE; // -0.5 * (sumdata[nt]);
      if (currentobject[nt]==printlikel) printf(" likel: bad fit to cross-correlation");
      return newmaxval;
    }

    /*
     * unfortunately the fitted surfaces don't seem to be accurate
     * enough (I guess they are not well-enough described by
     * Gaussians). Use an FT to shift the chisq array to this fitted
     * peak and remeasure it
     */
    /*
     * since we then only need the peak value we dont need a full
     * inverse transform so just accumulate the required value in the
     * variable smaxval
     */
    /* In this version we are attempting to marginalise over bulge-fraction and
       total galaxy flux, so we need to measure the peak cross-correlation
       in each galaxy component separately.  Then, we marginalise over position
       and accumulate the quantities for the marginalisation.  The bulge fraction
       can be done semi-analytically with erf functions, marginalising over flux
       with a powerlaw prior requires a numerical integration.  In order not to 
       take too long doing this, we assume the spatial position of the peak (i.e
       corresponding to the galaxy position) is as given by the maximum-likelihood
       position that has just been determined from the fitting above */

    if (SUBPIXEL_SHIFT == 1) {

      // for each component, calculate the cross-correlation at the position of the maximum
      complikel[0]=complikel[1]=0.;
      for (mt=mtstart; mt<2; mt++)
	{
	  smaxval = 0.;
	  for(y = 0; y < halfpheight; y++) 
	    {
	      ky = pi * (double) y / (double) (halfpheight);
	      x = 0;
	      yx = y * halfpwidth + x;
	      CC[nt][mt][yx] *= (cos(ky*y0) + I*sin(ky*y0));
	      smaxval += creal(CC[nt][mt][yx]);
	      for(x = 1; x < halfpwidth - 1; x++) 
		{
		  yx = y * halfpwidth + x;
		  kx = pi * (double) x / (double) (halfpwidth - 1);
		  CC[nt][mt][yx] *= (cos(kx*x0) + I*sin(kx*x0));
		  CC[nt][mt][yx] *= (cos(ky*y0) + I*sin(ky*y0));
		  smaxval += 2. * creal(CC[nt][mt][yx]);
		}
	      x = halfpwidth - 1;
	      yx = y * halfpwidth + x;
	      kx = pi;
	      CC[nt][mt][yx] *= (cos(kx*x0) + I*sin(kx*x0));
	      CC[nt][mt][yx] *= (cos(ky*y0) + I*sin(ky*y0));
	      smaxval += creal(CC[nt][mt][yx]);
	    }
	  for(y = halfpheight; y < pheight; y++) 
	    {
	      ky = pi * (double) (y - pheight) / (double) (halfpheight);
	      x = 0;
	      yx = y * halfpwidth + x;
	      CC[nt][mt][yx] *= (cos(ky*y0) + I*sin(ky*y0));
	      smaxval += creal(CC[nt][mt][yx]);
	      for(x = 1; x < halfpwidth - 1; x++) 
		{
		  yx = y * halfpwidth + x;
		  kx = pi * (double) x / (double) (halfpwidth - 1);
		  CC[nt][mt][yx] *= (cos(kx*x0) + I*sin(kx*x0));
		  CC[nt][mt][yx] *= (cos(ky*y0) + I*sin(ky*y0));
		  smaxval += 2. * creal(CC[nt][mt][yx]);
		}
	      x = halfpwidth - 1;
	      yx = y * halfpwidth + x;
	      kx = pi;
	      CC[nt][mt][yx] *= (cos(kx*x0) + I*sin(kx*x0));
	      CC[nt][mt][yx] *= (cos(ky*y0) + I*sin(ky*y0));
	      smaxval += creal(CC[nt][mt][yx]);
	    }
	  // check that this shifted maximum really is higher than the discrete value
	  yx = iymax * pwidth + ixmax;
	  maxval = c[nt][mt][yx] * crossproduct[2];
	  //printf(" maxvals %f %f %d %d %f %f \n",x0,y0,ixmax,iymax,maxval,smaxval); fflush(stdout);
	  if (smaxval > maxval) maxval = smaxval; 
	  complikel[mt] = maxval; 
	}
    }
    else
      {
	// if no sub-pixel shifts allowed, use maximum found without shifts
	yx = iymax * pwidth + ixmax;
	complikel[0] = c[nt][0][yx] * crossproduct[2];
	complikel[1] = c[nt][1][yx] * crossproduct[2];
      }

    // now specify the values in total flux to be chosen for the numerical marginalisation
    totalflux = maxamp[0]+maxamp[1];  // maximum likelihood total flux
    // test whether we can tell the difference between models, or if it's a star
    if (nRo>0 && fabs(crossdenom)>1.e-6)
      {
	//  calculate the error on total flux for two-component model
	fluxvar = (crossproduct[0]+crossproduct[1]-2.)/crossdenom/crossproduct[2];
	fluxerr = 0.;
	if (fluxvar>0.)
	  {
	    fluxerr = sqrt(fluxvar);
	  }
	else
	  {
	    fflush(stdout);
	    fprintf(stderr,"error: flux variance %f \n",fluxvar);
	    exit(EXIT_FAILURE);
	  }
      }
    else
      {
	// calculate the flux error for the case where a single component is required
	fluxerr = 0.;
	for (mt=0; mt<2; mt++)
	  {
	    if (maxamp[mt]>0.)
	      {
		if (crossproduct[mt]>0.)
		  {
		    fluxerr = 1./sqrt(crossproduct[mt]*crossproduct[2]);
		  }
		else
		  {
		    fflush(stdout);
		    fprintf(stderr," maxamp[%d] %f but crossproduct %f \n",mt,maxamp[mt],crossproduct[mt]);
		    exit(EXIT_FAILURE);
		  }
	      }
	  }
      }

    // make sure a finite range of flux has been found
    if (fluxerr <= 0.)
      {
	fflush(stdout);
	fprintf(stderr,"error, zero fluxerr \n");
	exit(EXIT_FAILURE);
      }

    /* now step through in flux to marginalise over both bulge fraction and flux */

    // normalisation of bulge-fraction prior (apart from sqrt(pi/2) factor which cancels)
    erfarg1 = bfpeakval/bfsigma/M_SQRT2;
    erfarg2 = (bfpeakval-1.)/bfsigma/M_SQRT2;
    if (gsl_sf_erf_e(erfarg1, &yc)==0 && gsl_sf_erf_e(erfarg2, &xc)==0)
      {
	bfpriornorm = bfsigma*(yc.val-xc.val);
      }
    else
      {
	fflush(stdout);
	fprintf(stderr," error normalising bulge prior function \n");
	exit(EXIT_FAILURE);
      }
    if (bfpriornorm > 0.)
      {
	logbfpriornorm = log(bfpriornorm);
      }
    else
      {
	fflush(stdout);
	fprintf(stderr," error evaluating bfpriornorm %f \n",bfpriornorm);
	exit(EXIT_FAILURE);
      }
    // default marginalised bulge-fraction
    if (nRo > 0)
      marbt = marbt0 =
	bfpeakval*bfsigma*(yc.val-xc.val)/bfpriornorm + 
	bfsigma*bfsigma*(exp(-erfarg1*erfarg1)-exp(-erfarg2*erfarg2))/
	(sqrt(M_PI_2)*bfpriornorm);
    else
      marbt = marbt0 = 1.;
 
    /* work out relative prior of disk+bulge and bulge-only galaxies.  We can't just multiply by
       the respective priors because we don't marginalise over ellipticity when comparing likelihoods
       of galaxy models with the star model. */
    emod = sqrt(e1[ne] * e1[ne] + e2[ne] * e2[ne]);
    bulgeprior = bulgepopfrac*exp(bulgefunc(emod))/
      (bulgepopfrac*exp(bulgefunc(emod))+(1.-bulgepopfrac)*exp(efunc(emod)));
   
    // integrate over a range of +/-5 sigma in total flux interpolating between 101 measured points
    num_marvals[nt] = 0;
    maxlikel = UNSATISFACTORY_VALUE;

    for (istep=0; istep<=100; istep++)
      {
	flux = totalflux + (istep-50)*fluxerr/10.;
	// only integrate down to 1 percent of maximum-likelihood flux for this model, or -5 sigma, whichever is higher
	if (flux>(totalflux/100.))
	  {
	    // if galaxy models, assume two components
	    if (nRo > 0)
	      {
		/* marginalise over bulge fraction at this flux.  bulge is assumed in component [1], disk in [0]
		   There are two galaxy types, (disk+bulge) and bulge-only */
		// disk+bulge
		arg1 = flux*flux*(crossproduct[0]+crossproduct[1]-2.)*crossproduct[2] + 1./(bfsigma*bfsigma);
		if (arg1>0.)
		  {
		    // peak disk+bulge likelihood value
		    arg2 = flux*(complikel[0]-complikel[1]) + flux*flux*(1.-crossproduct[0])*crossproduct[2];
		    arg2 -= bfpeakval/(bfsigma*bfsigma);
		    arg3 = sumdata[nt] + flux*flux*crossproduct[0]*crossproduct[2] - 2.*flux*complikel[0] - arg2*arg2/arg1;
		    arg3 += bfpeakval*bfpeakval/(bfsigma*bfsigma);
		    r0 = arg2/arg1;
		    erfarg1 = (1.+r0)*sqrt(arg1/2.);
		    erfarg2 = r0*sqrt(arg1/2.);
		    if (gsl_sf_erf_e(erfarg1, &yc)==0 && gsl_sf_erf_e(erfarg2, &xc)==0)
		      {
			// log likelihood, marginalised over bulge fraction at this value of total flux
			erfval = yc.val-xc.val;
			if (erfval > 1.e-6)
			  {
			    likel = -arg3/2. + log(erfval) -0.5*log(arg1) - logbfpriornorm;
			    // expectation value of bulge-fraction
			    marbt = -erfval*r0 +
			      (exp(-erfarg2*erfarg2)-exp(-erfarg1*erfarg1))/sqrt(arg1*pi/2.);
			    marbt /= erfval;
			    erfval = log(erfval);
			  }
			else
			  {
			    // approximation for the tail of erf (see mathworld functions)
			    // http://functions.wolfram.com/GammaBetaErf/Erf/06/02/
			    if (erfarg2 > 1.)
			      {
				erfval = -erfarg2*erfarg2 - log(erfarg2*sqrt(pi))  
				  - r0*exp(-arg1*r0-arg1/2.)/(1+r0);  // log(erfval)
				likel = -arg3/2. 
				  + erfval
				  - 0.5*log(arg1) - logbfpriornorm;
				if ((erfarg2*erfarg2+erfval>EXPMIN/2) && (erfarg2*erfarg2-erfarg1*erfarg1)<EXPMAX/2)
				  {
				    marbt = -r0 +
				      (1.-exp(erfarg2*erfarg2-erfarg1*erfarg1))/sqrt(arg1*pi/2.)/exp(erfarg2*erfarg2+erfval);
				  }
				else
				  {
				    // bulge-fraction marginalised over prior alone
				    marbt = marbt0;
				  }
			      }
			    else if (erfarg1 < -1.)
			      {
				erfval = -erfarg1*erfarg1 - log(fabs(erfarg1)*sqrt(pi)) 
				  - (1+r0)*exp(arg1*r0-arg1/2.)/r0;  // log(erfval)
				likel = -arg3/2. 
				  + erfval
				  - 0.5*log(arg1) - logbfpriornorm;
				if ((erfarg1*erfarg1+erfval)>EXPMIN/2 && (erfarg1*erfarg1-erfarg2*erfarg2)<EXPMAX/2)
				  {
				    marbt = -r0 +
				      (exp(erfarg1*erfarg1-erfarg2*erfarg2)-1.)/sqrt(arg1*pi/2.)/exp(erfarg1*erfarg1+erfval);
				  }
				else
				  {
				    // bulge-fraction marginalised over prior alone
				    marbt = marbt0;
				  }
			      }
			    else
			      {
				fflush(stdout);
				fprintf(stderr," negative erf \n");
				fprintf(stderr," %f %f %f %f %f \n",r0,arg1,erfarg1,erfarg2,erfval);
				likel = UNSATISFACTORY_VALUE;
				if (currentobject[nt]==printlikel) printf(" likel: negative erf \n");
				marbt = bfsigma*bfsigma*(1.-exp(-1./(2.*bfsigma*bfsigma)))/(sqrt(M_PI_2)*bfpriornorm);
			      }
			  }
		      }
		    else
		      {
			//printf(" failed erf generation %f %f \n",erfarg1,erfarg2);
			if (currentobject[nt]==printlikel) printf(" likel: failed erf \n");
			likel=UNSATISFACTORY_VALUE;
			marbt = marbt0;
		      }
		    /*
		    if (currentobject[nt]==printlikel && nRo>0 && flux==totalflux)
		      {
			printf(" nRo %d emod %f bulgeprior %f flux %f ",nRo,emod,bulgeprior,flux);
			printf(" %f %f %f %f %f %f %f %f \n", arg1, arg2, arg3, r0, erfarg1, erfarg2, erfval, marbt);
		      }
		    */
		    // check marginalised bulge-fraction
		    if (marbt<0.) marbt=0.;
		    if (marbt>1.) marbt=1.;

		    // peak disk+bulge pedestal value (cross-correlation -> 0)
		    arg2 = flux*flux*(1.-crossproduct[0])*crossproduct[2];
		    arg2 -= bfpeakval/(bfsigma*bfsigma);
		    arg3 = sumdata[nt] + flux*flux*crossproduct[0]*crossproduct[2] - arg2*arg2/arg1;
		    arg3 += bfpeakval*bfpeakval/(bfsigma*bfsigma);
		    r0 = arg2/arg1;
		    erfarg1 = (1.+r0)*sqrt(arg1/2.);
		    erfarg2 = r0*sqrt(arg1/2.);
		    if (gsl_sf_erf_e(erfarg1, &yc)==0 && gsl_sf_erf_e(erfarg2, &xc)==0)
		      {
			// log likelihood, marginalised over bulge fraction at this value of total flux
			erfval = yc.val-xc.val;
			if (erfval > 1.e-6)
			  {
			    pedval = -arg3/2. + log(erfval) -0.5*log(arg1) - logbfpriornorm;
			  }
			else
			  {
			    // approximation for the tail of erf (see mathworld functions)
			    // http://functions.wolfram.com/GammaBetaErf/Erf/06/02/
			    if (erfarg2 > 1.)
			      {
				pedval = -arg3/2. 
				  -erfarg2*erfarg2 - log(erfarg2*sqrt(pi)) - r0*exp(-arg1*r0-arg1/2.)/(1+r0)
				  -0.5*log(arg1) - logbfpriornorm;
			      }
			    else if (erfarg1 < -1.)
			      {
				pedval = -arg3/2. 
				  -erfarg1*erfarg1 - log(fabs(erfarg1)*sqrt(pi)) - (1+r0)*exp(arg1*r0-arg1/2.)/r0
				  -0.5*log(arg1) - logbfpriornorm;
			      }
			    else
			      {
				fflush(stdout);
				fprintf(stderr," pedestal negative erf \n");
				fprintf(stderr," %f %f %f %f %f \n",r0,arg1,erfarg1,erfarg2,erfval);
				pedval = UNSATISFACTORY_VALUE;
			      }
			  }
		      }
		    else
		      {
			if (currentobject[nt]==printlikel) printf("likel: failed pedestal erf generation %f %f \n",erfarg1,erfarg2);
			pedval=UNSATISFACTORY_VALUE;
		      }

		    // marginalise over position
		    if (likel > UNSATISFACTORY_VALUE && pedval > UNSATISFACTORY_VALUE)
		      {
			likel = likelfunc(likel-pedval);
			if (likel > UNSATISFACTORY_VALUE) likel += pedval;
		      }
		    else
		      {
			if (currentobject[nt]==printlikel) printf(" likel: likel or pedval failed \n");
			likel = pedval = UNSATISFACTORY_VALUE;
		      }
		  }
		else
		  {
		    if (currentobject[nt]==printlikel) printf("likel: arg1 %f %f %f %f \n",arg1,crossproduct[0],crossproduct[1],crossproduct[2]);
		    likel = UNSATISFACTORY_VALUE;
		  }
		// bulge-only galaxy
		bulgelikel = likelfunc(flux*complikel[1]);
		bulgepedval = -0.5*(sumdata[nt] + flux*flux*crossproduct[1]*crossproduct[2]);
		if (bulgelikel > UNSATISFACTORY_VALUE) bulgelikel += bulgepedval;
		dlikel = likel-bulgelikel;
		// store for spline interpolation later, also multiply by flux prior
		if (likel > UNSATISFACTORY_VALUE)
		  {
		    // combine disk+bulge and bulge likelihoods, given the prior bulgepopfrac
		    // allow that likelfunc may have returned default "no value" meaning that the
		    // value is outside the lowest likelihood contour to be integrated
		    if ( bulgelikel>UNSATISFACTORY_VALUE && dlikel < EXPMAX/2)
		      {
			likel = log(bulgeprior + (1.-bulgeprior)*exp(dlikel)) + bulgelikel;
			marbt = log(bulgeprior + marbt*(1.-bulgeprior)*exp(dlikel)) + bulgelikel - likel;
			marbt = exp(marbt);
		      }
		    else
		      {
			// pure disk
			likel += log(1.-bulgeprior);
		      }
		  }
		else
		  {
		    if (bulgelikel > UNSATISFACTORY_VALUE) 
		      {
			// pure bulge
			likel = log(bulgeprior) + bulgelikel;
			marbt = 1.;
		      }
		    else
		      {
			// default bulge-fraction (marginalised over prior alone)
			marbt = marbt0;
		      }
		  }
		/*
		if (currentobject[nt]==printlikel && nRo>0 && flux==totalflux) 
		  printf(" likel %f %f %f %f \n",likel,dlikel+bulgelikel,bulgelikel,marbt);
		*/
		if (marbt<0.) marbt=0.;
		if (marbt>1.) marbt=1.;
		if (likel > UNSATISFACTORY_VALUE)
		  {
		    // multiply likelihood by flux prior
		    fprior = -fluxpriorslope * log(flux);
		    xmarvals[nt][num_marvals[nt]] = flux;
		    likel += fprior;
		    ymarvals[nt][num_marvals[nt]] = likel;
		    marbtvals[nt][num_marvals[nt]] = marbt;
		    num_marvals[nt]++;
		  }
		// remember values at max-likelihood to help numerical integration
		if (likel > maxlikel) 
		  {
		    maxlikel = likel;
		  }
	      }
	    else
	      {
		// star model, single component, no marginalisation over bulge fraction
		likel = likelfunc(flux*complikel[1]);
		pedval = -0.5*(sumdata[nt] + flux*flux*crossproduct[1]*crossproduct[2]);
		marbt = 1.;
		if (likel > UNSATISFACTORY_VALUE)
		  {
		    likel += pedval;
		    // multiply likelihood by flux prior
		    fprior = -fluxpriorslope * log(flux);
		    // if (currentobject[nt]==printlikel) printf("star likel %f %f %f %f \n",flux,fprior,likel,-sumdata[nt]/2.);
		    xmarvals[nt][num_marvals[nt]] = flux;
		    likel += fprior;
		    ymarvals[nt][num_marvals[nt]] = likel;
		    marbtvals[nt][num_marvals[nt]] = 1.;
		    num_marvals[nt]++;
		  }
		// remember values at max-likelihood to help numerical integration
		if (likel > maxlikel) 
		  {
		    maxlikel = likel;
		  }
	      }
	  }
      }

    // variables for marginalised flux and bulge fraction
    fluxmarbt = fluxmar = sumfluxmar = 0.;
    
    // make sure we've got enough values for interpolation and integration (should be 101 normally)
    if (num_marvals[nt] > 5)
      {
	/* now marginalise over flux by numerical integration, both for the
	   likelihood at this best-fit position and also for the pedestal */
	    // cspline for posterior values
	    fspline[nt] = gsl_spline_alloc(gsl_interp_cspline,num_marvals[nt]);
	    if (fspline[nt] == NULL) {
	      fflush(stdout);
	      fprintf(stderr," error from gsl_interp_accel_alloc, fspline in likelihood \n");
	      exit(EXIT_FAILURE);
	    }
	    // renormalise by the maximum values to help the numerical integration, and exponentiate
	    for (istep=0; istep<num_marvals[nt]; istep++)
	      {
		ymarvals[nt][istep] = exp(ymarvals[nt][istep]-maxlikel);
		// create bulge-fraction marginalised over flux, just do straight summation
		expval = exp(ymarvals[nt][istep]);
		fluxmarbt += expval*marbtvals[nt][istep];
		fluxmar += expval*xmarvals[nt][istep];
		sumfluxmar += expval;
	      }
	    if (sumfluxmar>0.)
	      {
		fluxmarbt /= sumfluxmar;
		fluxmar /= sumfluxmar;
	      }
	    // reset the accelerator
	    gsl_status = gsl_interp_accel_reset(facc[nt]);
	    if (gsl_status) {
	      fflush(stdout);
	      fprintf(stderr," error gsl_interp_accel_reset facc[%d] in likelihood \n",nt);
	      fprintf(stderr," %s \n",gsl_strerror(gsl_status));
	      exit(EXIT_FAILURE);
	    }
	    // load flux and posterior values into interpolation arrays
	    gsl_status = gsl_spline_init(fspline[nt],xmarvals[nt],ymarvals[nt],num_marvals[nt]);
	    if (gsl_status) {
	      fflush(stdout);
	      fprintf(stderr," error gsl_spline_init fspline[%d] in likelihood \n",nt);
	      fprintf(stderr," %s \n",gsl_strerror(gsl_status));
	      exit(EXIT_FAILURE);
	    }
	    // define the domain of the integration
	    xmin = xmarvals[nt][0];
	    xmax = xmarvals[nt][num_marvals[nt]-1];
	    // integrate the interpolated posterior array
	    gsl_status = gsl_integration_qag
	      (&marFlux, xmin, xmax, 0., 1.e-3, gsl_work_size,
	       GSL_INTEG_GAUSS41, gsl_work[nt], &likel, &error);
	    // free the allocated spline 
	    gsl_spline_free(fspline[nt]);
	    if (gsl_status) 
	      {
		/* if failed to integrate, go with maximum-likelihood solution
		   marginalised without a flux prior */
		if (currentobject[nt]==printlikel) printf("likel: failed likel marginalisation %d %d %d \n",nt,nRo,ne);
		likel = sqrt(2.*pi)*fluxerr;
	      }
	    // if (currentobject[nt]==printlikel) printf(" mar vals %d %f %f \n",num_marvals[nt],fluxmar,fluxmarbt);
      }
    else
      {
	/* not enough valid values found for integration, 
	   adopt maximum likelihood with simpler marginalisation with flux prior */
	if (maxlikel>UNSATISFACTORY_VALUE)
	  {
	    if (currentobject[nt]==printlikel) printf("likel: not enough values %d %d %d %d \n",nt,nRo,ne,num_marvals[nt]);
	    likel = sqrt(2.*pi)*fluxerr;
	  }
	else
	  {
	    // or set dummy value if absolutely no useful values found
	    if (currentobject[nt]==printlikel) printf("likel: no values %d %d %d %d \n",nt,nRo,ne,num_marvals[nt]);
	    likel = UNSATISFACTORY_VALUE;
	  }
      }
    /* now the likel and pedestal variables hold the marginalised likelihoods
       Now apply the integration over position and return the log of the final 
       marginalised likelihood */
    // if (currentobject[nt]==printlikel) printf(" likels %f %f \n",maxlikel,likel);
    if (likel>0. && maxlikel>UNSATISFACTORY_VALUE)
      {
	// take log and apply maximum offset from above
	likel = log(likel)+maxlikel;
	/*
	if (currentobject[nt]==printlikel)
	  printf(" marginalised likel %f \n",likel);
	*/
      }
    else
      {
	if (currentobject[nt]==printlikel) printf("likel: nRo %d likels %f %f \n",nRo,maxlikel,likel);
	likel = UNSATISFACTORY_VALUE;
      }
    
    // if (currentobject[nt]==printlikel) printf(" %f \n",likel);
    
    // set the modelfluxes to the marginalised values
    if (fluxmar <= 0.) fluxmar = totalflux;
    if (nRo==0) fluxmarbt = 1.;
    modelflux[nt][modelnum][0] = (1.-fluxmarbt)*fluxmar;
    modelflux[nt][modelnum][1] = fluxmarbt*fluxmar;
    
    /* record number of times the marginalisation phase has returned a bad value
       from the marginalisation part of the calculation */
    if (likel<=UNSATISFACTORY_VALUE) 
      {
	nmarfail[nt]++;
      }

    // remember the highest likelihood found in this thread
    if (likel > peaklikel[nt]) peaklikel[nt] = likel;
   
    // return log(likelihood)
    return likel;
}


double rfunc (double r, float mag)
{
// prior function for scalelength as a function of magnitude, derived from
//   Simard et al 2002, assumes quasi-rayleigh distribution in r.  

// The parameters in this function are afit[] and refmag, which are defined and set 
// as global variables in front of the main code

// NB returns ln(prior) 

  // parameters assume r is measured in arcsec
  // nominal fit to aval for exponent 2 from Simard photometry
  // double afit[2]={-1.1448076, -0.26932025};  

  // double asq;

  // quadratic fit from CFHTLS photometry & Simard disk lengths for B/T<0.5
  // double afit[3]={-1.0259867, -0.2760907, -0.053934082};  
  // double tmag0;

  double aval, rprior,tmag;

  if (r<=0.)
    {
      fflush(stdout);
      fprintf(stderr," illegal value given to rfunc: r=%f \n",r);
      exit(EXIT_FAILURE);
    }

  // function of magnitude for parameter a
  tmag = mag-refmag;

  // evaluate a linear fit to median, then rescale to get aval (depends on exponent)
  // the following commented-out lines correspond to various possible
  // choices for the exponent in the distribution.  Data don't strongly
  // indicate which is better, but it doesn't seem to affect results much

  // Rayleigh distribution (exponent 2) normalised out to Rmax
  // aval = exp(afit[0] + afit[1]*tmag)/0.83255461;
  // asq = aval*aval;
  // rprior = 2.*r*exp(-r*r/asq)/(1.-exp(-Rmaxarcsec*Rmaxarcsec/asq))/asq;

  // exponent (3/2), convert median to required scale 
  // normalised to infinity by factor 2.Gamma[4/3]/3.
  // aval = exp(afit[0] + afit[1]*tmag)/1.0125
  // rprior = r*exp(-pow((r/aval),(3./2.)))/(2.*0.89298*aval*aval/3.);

  // exponent (4/3), convert median to required scale 
  // normalised to infinity by factor 3.sqrt(pi)/8.
  aval = exp(afit[0] + afit[1]*tmag)/1.134;
  rprior = r*exp(-pow((r/aval),(4./3.)))/(3.*sqrt(pi)*aval*aval/8.);

  return log(rprior);

}

/*
double rfunc (double r, double Rmaxarcsec, float mag)
{
  // old rfunc prior derived from CFHTLS data alone

  // assumes lognormal distribution in r, r input in arcsec but converted here to pixels


  // correct for Graham & Worley size increase
  //r *= 1.29;
  //Rmaxarcsec *= 1.29;

    double arg1, arg2, sigma, gamma, rfactor, logr,
      logr0, thismag, minmag, maxmag, r0,r1,r2,r3, sig0,sig1,sig2,sig3,
      logrmax, pnorm, refmag;
    gsl_sf_result xc;

    // r prior parameter values from prior_fitparms_hst.dat
    minmag = 21.; refmag = 23.0; maxmag = 25.5;
    r0= 0.42666432; r1= -0.28029862; r2= -0.016912173; r3= 0.002858672;
    sig0= 0.7278578; sig1= -0.2258626; sig2= 0.10106533; sig3= -0.01742189;
    gamma= 2.0000000;

    thismag = mag;
    if (mag < minmag)
        thismag = minmag;
    if (mag > maxmag)
        thismag = maxmag;
    thismag -= refmag;

    logr0 =
        r0 + r1 * thismag + r2 * thismag * thismag +
        r3 * thismag * thismag * thismag;
    sigma =
        sig0 + sig1 * thismag + sig2 * thismag * thismag +
        sig3 * thismag * thismag * thismag;

    if (sigma > 3. || sigma <= 0.) {
        printf
            (" prior sigma outside range, problem at magnitude %f, sigma = %f\n",
             mag, sigma);
        exit(EXIT_FAILURE);
    }

    if (r <= 0.) {
        fflush(stdout);
        fprintf(stderr, " illegal r value=%lf given to efunc\n", r);
        exit(EXIT_FAILURE);
    }

    // convert r back from arcsec to pixels assuming generic cfhtls pixel scale
    logr = log(r/0.186);
    logrmax = log(Rmaxarcsec/0.186);
    arg2 = fabs((logr - logr0) / sigma);
    rfactor = -log(sigma) - pow(arg2, gamma) / 2.;

    arg1 = (sigma*sigma + logr0 - logrmax)/(sqrt(2.)*sigma);
    if (gsl_sf_erfc_e(arg1, &xc)==0)
      {
	pnorm = log(xc.val * exp(sigma*sigma/2. + logr0) * sqrt(pi/2.));
	rfactor -= pnorm;
      }
    else
      {
	fflush(stdout);
	fprintf(stderr," error normalising old rfunc \n");
	exit(EXIT_FAILURE);
      }

    return rfactor;

}
*/

double bulgefunc (double eval)
{
  /* function for log(ellipticity prior) for bulge-dominated galaxies, assumed
     independent of magnitude, based on fits of Simard et al. 2002
  */
  double prior, pnorm, erfarg1, erfarg2;
  gsl_sf_result xc, yc;

  // basic log(prior) function
  prior = -bulgefunc_c*eval*eval - bulgefunc_b*eval;

  // normalisation from mathematica
  erfarg1 = bulgefunc_b/2./sqrt(bulgefunc_c);
  erfarg2 = (bulgefunc_b+2.*bulgefunc_c)/2./sqrt(bulgefunc_c);
  if (gsl_sf_erf_e(erfarg1, &yc)==0 && gsl_sf_erf_e(erfarg2, &xc)==0)
    {
      pnorm = (yc.val-xc.val);
      if (pnorm < 0.)
	{
	  pnorm *= sqrt(pi)*bulgefunc_b*
	    exp(bulgefunc_b*bulgefunc_b/4./bulgefunc_c)/
	    4./bulgefunc_c/sqrt(bulgefunc_c);
	  pnorm += 1./(1.+1./(exp(bulgefunc_b+bulgefunc_c)-1.))/2./bulgefunc_c;
	  pnorm *= 2.*pi;
	  if (pnorm > 0.)
	    {
	      pnorm = log(pnorm);
	    }
	  else
	    {
	      fflush(stdout);
	      fprintf(stderr," negative norm in bulgefunc \n");
	      exit(EXIT_FAILURE);
	    }
	}
      else
	{
	  fflush(stdout);
	  fprintf(stderr," rounding error in erf in bulgefunc\n");
	  exit(EXIT_FAILURE);
	}
    }
  else
    {
      fflush(stdout);
      fprintf(stderr," error calculating erf in bulgefunc \n");
      exit(EXIT_FAILURE);
    }

  // return log(normalised prior)
  prior -= pnorm;
  return (prior);

}

double efunc (double eval)
{
  /* 
   *  function for log(ellipticity prior), for disk galaxies, assumed independent 
   *  of magnitude, based on fit to SDSS disk axis ratios following Unterborn
   *  and Ryden 2008.  This fit is actually based on the distribution of
   *  axis ratios in the g-band DR7 data (see programs qdist.for and mockprior.for)
   */
  /* NB this is only approximately normalised (because it cannot be normalised
   * analytically and we don't want that step to take too long) */
  double prior, pnorm, arg1, arg2;
  gsl_sf_result xc, yc;

  if (eval < efunc_emax)
    {
      // high ellipticity cut-off (note revised functional form with (1+e) term)
      prior = (1.-exp((eval-efunc_emax)/efunc_sigma))/(1.+eval);
      // intrinsic ellipticity term
      prior *= 1./sqrt((eval*eval + efunc_a*efunc_a));
    }
  else
    {
      prior = 1.e-10;
    }

  // approx normalisation assuming efunc_a is small
  //pnorm = 1.-efunc_sigma*(exp((1.-efunc_emax)/efunc_sigma)-exp(-efunc_emax/efunc_sigma));
  // normalisation of revised function with extra (1+e) term
  arg1 = -(1.+efunc_emax)/efunc_sigma;
  arg2 = -1./efunc_sigma;
  if (gsl_sf_expint_E1_e(arg1, &yc)==0 && gsl_sf_expint_E1_e(arg2, &xc)==0)
    {
      pnorm = log(1.+efunc_emax) + exp(arg1)*(yc.val-xc.val);
    }
  else
    {
      fflush(stdout);
      fprintf(stderr," error normalising efunc prior \n");
      exit(EXIT_FAILURE);
    }
  pnorm *= (sqrt(efunc_a*efunc_a+1.)-efunc_a);
  pnorm *= 2.*pi;
	       
  return log(prior/pnorm) ;
}

/*
efuncderiv is not used any more as the differentiation is now done numerically
to deal with discretisation issues

double efuncderiv (double eval)
{
*/
  /* 
   *  derivative of
   *  function for ellipticity prior, for disk galaxies, assumed independent 
   *  of magnitude, based on fit to SDSS disk axis ratios from Unterborn
   *  and Ryden 2008.
   *  Used for sensitivity calculation.
   *  Result from this function is to be multiplied by the prior 
   *  exp(efunc) to get the negative derivative.
   */
/*
  double deriv;

  if (eval < efunc_emax)
    {
      deriv = eval / (eval*eval + efunc_a*efunc_a) +
	exp((eval-efunc_emax)/efunc_sigma)/(1.-exp((eval-efunc_emax)/efunc_sigma))/efunc_sigma;
    }
  else
    {
      deriv = 0.;
    }
	       
  return deriv;
}
*/

/* 
 * variant of getdata routine that makes estimation of pixel noise covariance from the data.
 * not normally used (it is slow) but retained here for future experimentation on
 * non-CFHTLenS datasets
 */
void
getdata_badpix_covar(char *imagename, char *badpixelname, int *dim,
                     float *apix, float *badpix, float *mednoiseval)
{
    fitsfile *afptr, *bfptr;    /* FITS file pointers */
    int status = 0;             /* CFITSIO status value must be initialized to zero */
    int anaxis, bnaxis;
    long anaxes[2] = { 1, 1 }, fpixel[2] = {
    1, 1}, bnaxes[2] = {
    1, 1};
    int size, bsize;
    int i, j, ix, iy, nxbin, nybin, ibin, cbin, ncbin, num[2000];
    int x, y, dx, dy, x2, y2, i2;
    float **sortval;
    float median[2000], covar[121], minval[2000], maxval, ival, i2val,
        val[2000];

/* open input image */
    fits_open_file(&afptr, imagename, READONLY, &status);

/* read dimensions */
    fits_get_img_dim(afptr, &anaxis, &status);
    fits_get_img_size(afptr, 2, anaxes, &status);

    if (status) {
        fits_report_error(stderr, status);      /* print error message */
	exit(EXIT_FAILURE);
    }

    if (anaxis != 2) {
        printf
            ("Error: images with other than 2 dimensions are not supported\n");
        exit(EXIT_FAILURE);
    }

    if (dim[0] != anaxes[0]) {
        fprintf(stderr, " error reading image dimensions \n");
        exit(EXIT_FAILURE);
    }
    if (dim[1] != anaxes[1]) {
        fprintf(stderr, " error reading image dimensions \n");
        exit(EXIT_FAILURE);
    }

    size = dim[0] * dim[1];
    bsize = dim[0] * dim[1];

/* read input data into image array */

    if (fits_read_pix(afptr, TFLOAT, fpixel, size, NULL, apix, NULL, &status)) {
        printf(" error reading pixel data \n");
        exit(EXIT_FAILURE);
    }

/* close main image file */

    fits_close_file(afptr, &status);

    if (status) {
        fits_report_error(stderr, status);      /* print error message */
        exit(EXIT_FAILURE);
    }


/* repeat for the bad pixel mask (which may not exist) */

/* open input images */
    fits_open_file(&bfptr, badpixelname, READONLY, &status);

    if (status == 0) {

/* read dimensions */
        fits_get_img_dim(bfptr, &bnaxis, &status);
        fits_get_img_size(bfptr, 2, bnaxes, &status);

        if (status) {
            fits_report_error(stderr, status);  /* print error message */
            exit(EXIT_FAILURE);
        }

        if (bnaxis != 2) {
            printf
                ("Error: images with other than 2 dimensions are not supported\n");
            exit(EXIT_FAILURE);
        }

        if (dim[0] != bnaxes[0]) {
            fprintf(stderr, " error reading bad pixel image dimensions \n");
            exit(EXIT_FAILURE);
        }
        if (dim[1] != bnaxes[1]) {
            fprintf(stderr, " error reading bad pixel image dimensions \n");
            exit(EXIT_FAILURE);
        }

/* read input data into image array */

        if (fits_read_pix(bfptr, TFLOAT, fpixel, bsize, NULL, badpix,
                          NULL, &status)) {
            printf(" error reading bad pixel mask \n");
            fits_report_error(stderr, status);  /* print error message */
            exit(EXIT_FAILURE);
        }

        fits_close_file(bfptr, &status);

        if (status) {
            fits_report_error(stderr, status);  /* print error message */
            exit(EXIT_FAILURE);
        }

/* dilate the bad pixel mask by one pixel in all directions - takes care
   of inaccuracies in the bad pixel mask */
     for (y=0; y<dim[1]; y++)
       {
	 for (x=1; x<dim[0]; x++)
	   {
	     i = x + y*dim[0];
	     if (badpix[i]<=0.)
	       {
		 badpix[i-1]=0.;
	       }
	   }
	 for (x=dim[0]-2; x>=0; x--)
	   {
	     i = x + y*dim[0];
	     if (badpix[i]<=0.)
	       {
		 badpix[i+1]=0.;
	       }
	   }
       }
     for (x=0; y<dim[0]; x++)
       {
	 for (y=1; y<dim[1]; y++)
	   {
	     i = x + y*dim[0];
	     if (badpix[i]<=0.)
	       {
		 j = x + (y-1)*dim[0];
		 badpix[j]=0.;
	       }
	   }
	 for (y=dim[1]-2; y>=0; y--)
	   {
	     i = x + y*dim[0];
	     if (badpix[i]<=0.)
	       {
		 j = x + (y+1)*dim[0];
		 badpix[j]=0.;
	       }
	   }
       }


    } else {

	if (WEIGHTS_REQUIRED > 0)
	  {
	    fprintf (stderr," bad pixel/weight mask not found \n");
	    printf (" bad pixel/weight mask not found %s \n",badpixelname);
	    exit(EXIT_FAILURE);
	  }
	else
	  {
	    printf (" bad pixel/weight mask not in use, continuing \n");
	    for (i=0; i<bsize; i++) badpix[i]=1.;
	    status=0;
	  }

    }



    nxbin = 1 + (dim[0] - 1) / 100;
    nybin = 1 + (dim[1] - 1) / 100;

    sortval = (float **) calloc(nxbin * nybin, sizeof(float *));

    for(iy = 0; iy < nybin; iy++) {
        for(ix = 0; ix < nxbin; ix++) {
            ibin = ix + iy * nxbin;
            num[ibin] = 0;
            sortval[ibin] = (float *) calloc(10000, sizeof(float));
        }
    }


    for(y = 0; y < dim[1]; y++) {
        iy = y / 100;
        for(x = 0; x < dim[0]; x++) {
            ix = x / 100;
            ibin = ix + iy * nxbin;
            i = y * dim[0] + x;
            if (badpix[i] > 0. && apix[i] < 100. && apix[i] > -100.) {
                sortval[ibin][num[ibin]] = apix[i];
                num[ibin]++;
            }
        }
    }


    for(iy = 0; iy < nybin; iy++) {
        for(ix = 0; ix < nxbin; ix++) {
            ibin = ix + iy * nxbin;
            if (num[ibin] > 0) {
                qsort(sortval[ibin], num[ibin], sizeof(float), compare);
                median[ibin] = sortval[ibin][(num[ibin] / 2)];
                minval[ibin] = sortval[ibin][0];
            }
        }
    }

    printf(" covariance matrix \n");

    for(dy = -5; dy <= 5; dy++) {
        for(dx = -5; dx <= 5; dx++) {
            cbin = (dx + 5) + (dy + 5) * 11;

            for(iy = 0; iy < nybin; iy++) {
                for(ix = 0; ix < nxbin; ix++) {
                    ibin = ix + iy * nxbin;
                    num[ibin] = 0;
                    val[ibin] = 0.;
                }
            }

            for(y = 0; y < dim[1]; y++) {
                y2 = y + dy;
                if (y2 >= 0 && y2 < dim[1]) {
                    iy = y / 100;
                    for(x = 0; x < dim[0]; x++) {
                        x2 = x + dx;
                        if (x2 >= 0 && x2 < dim[0]) {
                            i2 = x2 + y2 * dim[0];
                            ix = x / 100;
                            ibin = ix + iy * nxbin;
                            i = y * dim[0] + x;
                            ival = apix[i] - median[ibin];
                            i2val = apix[i2] - median[ibin];
                            maxval = fabs(minval[ibin]);
                            if (badpix[i] > 0. && ival < maxval
                                && ival > -maxval && i2val < maxval
                                && i2val > -maxval) {
                                val[ibin] += ival * i2val;
                                num[ibin]++;
                            }
                        }
                    }
                }
            }

            ncbin = 0;
            for(iy = 0; iy < nybin; iy++) {
                for(ix = 0; ix < nxbin; ix++) {
                    ibin = ix + iy * nxbin;
                    if (num[ibin] > 0) {
                        sortval[0][ncbin] = val[ibin] / num[ibin];
                        ncbin++;
                    }
                }
            }

            qsort(sortval[0], ncbin, sizeof(float), compare);
            covar[cbin] = sortval[0][ncbin / 2];

            printf(" %f ", covar[cbin]);

        }
        printf("\n");
    }


    free(sortval);

    *mednoiseval = 0.;
    if (covar[60] > 0.)
        *mednoiseval = sqrt(covar[60]);

    return;

}

void
getdata_badpix(char *imagename, char *badpixelname, int *dim, float *apix,
               float *badpix, float *mednoiseval)
{
    fitsfile *afptr, *bfptr;    /* FITS file pointers */
    int status = 0;             /* CFITSIO status value must be initialized to zero */
    int anaxis, bnaxis;
    long anaxes[2] = { 1, 1 }, fpixel[2] = {
    1, 1}, bnaxes[2] = {
    1, 1};
    int size, bsize;
    int i, n, ix, iy, ymin, ymax, xmin, xmax;
    int x, y, medbin;
    float sortval[10201];
    float median, quartile, noiseval[32];

/* open input image */
    fits_open_file(&afptr, imagename, READONLY, &status);
    if (status) {
        fits_report_error(stderr, status);      /* print error message */
        exit(EXIT_FAILURE);
    }

/* read dimensions */
    fits_get_img_dim(afptr, &anaxis, &status);
    fits_get_img_size(afptr, 2, anaxes, &status);

    if (status) {
        fits_report_error(stderr, status);      /* print error message */
        exit(EXIT_FAILURE);
    }

    if (anaxis != 2) {
        printf
            ("Error: images with other than 2 dimensions are not supported\n");
        exit(EXIT_FAILURE);
    }

    if (dim[0] != anaxes[0]) {
        fprintf(stderr, " error reading image dimensions \n");
        exit(EXIT_FAILURE);
    }
    if (dim[1] != anaxes[1]) {
        fprintf(stderr, " error reading image dimensions \n");
        exit(EXIT_FAILURE);
    }

    size = dim[0] * dim[1];
    bsize = dim[0] * dim[1];

/* read input data into image array */

    if (fits_read_pix(afptr, TFLOAT, fpixel, size, NULL, apix, NULL, &status)) {
        printf(" error reading pixel data \n");
        exit(EXIT_FAILURE);
    }

/* close main image file */

    fits_close_file(afptr, &status);

    if (status) {
        fits_report_error(stderr, status);      /* print error message */
        exit(EXIT_FAILURE);
    }


/* repeat for the bad pixel mask (which may not exist) */

/* open input images */
    fits_open_file(&bfptr, badpixelname, READONLY, &status);

    if (status == 0) {

/* read dimensions */
        fits_get_img_dim(bfptr, &bnaxis, &status);
        fits_get_img_size(bfptr, 2, bnaxes, &status);

        if (status) {
            fits_report_error(stderr, status);  /* print error message */
            exit(EXIT_FAILURE);
        }

        if (bnaxis != 2) {
            printf
                ("Error: images with other than 2 dimensions are not supported\n");
            exit(EXIT_FAILURE);
        }

        if (dim[0] != bnaxes[0]) {
            fprintf(stderr, " error reading bad pixel image dimensions \n");
            exit(EXIT_FAILURE);
        }
        if (dim[1] != bnaxes[1]) {
            fprintf(stderr, " error reading bad pixel image dimensions \n");
            exit(EXIT_FAILURE);
        }

/* read input data into image array */

        if (fits_read_pix(bfptr, TFLOAT, fpixel, bsize, NULL, badpix,
                          NULL, &status)) {
            printf(" error reading bad pixel mask \n");
            fits_report_error(stderr, status);  /* print error message */
            exit(EXIT_FAILURE);
        }

        fits_close_file(bfptr, &status);

        if (status) {
            fits_report_error(stderr, status);  /* print error message */
            exit(EXIT_FAILURE);
        }

   /* dilate mask by one pixel in all directions */
	dilatemask(badpix,dim);

    } else {
        if (WEIGHTS_REQUIRED > 0) {
            fprintf(stderr, " bad pixel/weight mask not found \n");
            printf(" bad pixel/weight mask not found %s \n", badpixelname);
            exit(EXIT_FAILURE);
        } else {
            printf(" bad pixel/weight mask not in use, continuing \n");
            for(i = 0; i < bsize; i++)
                badpix[i] = 1.;
            status = 0;
        }
    }

/* sample pixels, fill up an array of values of pixels drawn from
the central region of the image, sort it
and hence find the median and 25-percentile.  If the image has been sky subtracted,
the difference divided by 0.67 will be a good estimate of the rms noise.
If the image has not been subtracted but has a uniform background, this will
still work.  If there are significant background variations, these will contribute
to the noise measurement, making it larger than just the random noise. 
repeat at a number of locations across the image and take the median of these noise
estimates.
*/

    medbin = 0;

    for(iy = 0; iy < 8; iy++) {
        ymin = dim[1] / 16 + (iy * dim[1]) / 8 - 50;
        ymax = ymin + 101;
        if (ymin < 0)
            ymin = 0;
        if (ymax >= dim[1])
            ymax = dim[1] - 1;

        for(ix = 0; ix < 4; ix++) {
            xmin = dim[0] / 8 + (ix * dim[0]) / 4 - 50;
            xmax = xmin + 101;
            if (xmin < 0)
                xmin = 0;
            if (xmax >= dim[0])
                xmax = dim[0] - 1;

            n = 0;
            for(y = ymin; y < ymax; y++) {
                for(x = xmin; x < xmax; x++) {
                    i = y * dim[0] + x;
                    if (badpix[i] > 0.) {
                        sortval[n] = apix[i];
                        n++;
                    }
                }
            }

            if (n > 0) {
                qsort(sortval, n, sizeof(float), compare);
                median = sortval[(n / 2)];
                quartile = sortval[(n / 4)];
                if (median > quartile) {
                    noiseval[medbin] = (median - quartile) / 0.67;
                    medbin++;
                }
            }
        }
    }

    if (medbin > 0) {
        qsort(noiseval, medbin, sizeof(float), compare);
        *mednoiseval = noiseval[(medbin / 2)];
    } else {
        *mednoiseval = 0.;
    }

    status = 0;
    return;

}




int
read_images()
{
    /*
     * extract postage stamps from the set of input images.
     * range of objects in catalogue defined by nmin < i < nmax
     */

    int nt, nvalid, i, ii, pixel;
    int thread_return;
    int number_on_image;
    FILE *ret;

    for(nt = 0; nt < NUM_IMAGE_THREAD; nt++) {
        imagethread[nt] = -1;   // keeps track of which image is current in each thread
        thread_running[nt] = 0; // tells us whether this thread is still busy
        //thread_used[nt] = 0;    // tells us if this thread has ever been used
    }

    nt = 0;                     // initialise thread number (incremented in loop below)
    nvalid = 0;                 // number of valid objects extracted

    for(i = 0; i < nimages; i++) 
      {
        if (VERBOSE == 1) {
            printf(" image %s \n", imagename[i]);
            fflush(stdout);
        }
	// if a valid psf has been read in 
        if (no_psf[i] == 0) 
	  {
	    // check if it flagged as bad, skip to next image if so 
            if (badccd[i] == 1) 
	      {
                if (VERBOSE == 1)
		  printf(" %s flagged as bad, skipping image\n",imagename[i]);
		// break to the next image in the loop 
                continue;
	      }
            /*
             * check that this thread isn't still running from the previous call,
             * wait if it is 
             */
            if (thread_running[nt] == 1) {
                thread_return = pthread_join(threads[nt], &tstatus);
                if (thread_return != 0 && thread_return != ESRCH) {
                    fflush(stdout);
                    fprintf(stderr, " error %d from pthread_join %d \n",
                            thread_return, nt);
                    fprintf(stderr, " %s \n", strerror(thread_return));
                    exit(EXIT_FAILURE);
                }
                thread_running[nt] = 0;
            }

            /*
             * (re)allocate memory now the image sizes are known 
             */
            imagesize[nt] = dim[i][0] * dim[i][1];
            if (imagesize[nt] > allocatedimagesize[nt]) {
                memi -= allocatedimagesize[nt] * sizeof(float) * 2.;
                //memi -= (float) allocatedimagesize[nt] * sizeof(int) * 6;
                //memi -= (float) nmaxregion[nt] * sizeof(unsigned short int) * 4;
                if (SUBTRACT_MEDIAN == 1) {
                    memi -= allocatedimagesize[nt] * sizeof(float);
                    imagesize[nt] = dim[i][0] * dim[i][1];
                    sortarray[nt] =
                        (float *) realloc(sortarray[nt],
                                          imagesize[nt] * sizeof(float));
                    if (sortarray[nt] == NULL) {
                        fflush(stdout);
                        fprintf(stderr,
                                " error allocating memory for sortarray\n");
                        exit(EXIT_FAILURE);
                    }
                    memi += (float) imagesize[nt] * sizeof(float);
                }
                allocatedimagesize[nt] = imagesize[nt];
                //nmaxregion[nt] = imagesize[nt] / lower_area_limit;
                printf(" image size %d \n",imagesize[nt]);
                printf (" realloc apix \n");
                apix[nt] =
                    (float *) realloc(apix[nt],
                                      imagesize[nt] * sizeof(float));
                if (apix[nt] == NULL) {
                    fflush(stdout);
                    fprintf(stderr, " error allocating memory for image\n");
                    fprintf(stderr, " thread %d \n", nt);
                    exit(EXIT_FAILURE);
                }
                memi += (float) imagesize[nt] * sizeof(float);
                printf (" realloc badpix \n");
                badpix[nt] =
                    (float *) realloc(badpix[nt],
                                      imagesize[nt] * sizeof(float));
                if (badpix[nt] == NULL) {
                    fflush(stdout);
                    fprintf(stderr,
                            " error allocating memory for badpixel mask \n");
                    fprintf(stderr, " thread %d \n", nt);
                    fprintf(stderr, " image size %d \n", imagesize[nt]);
                    exit(EXIT_FAILURE);
                }
                memi += (float) imagesize[nt] * sizeof(float);
                /*
                 * work arrays for varylpthresholdf 
                 */
		/*		
                printf (" realloc iwork \n");
                for(iw = 0; iw < 6; iw++) {
                    iwork[nt][iw] =
                        (int *) realloc(iwork[nt][iw],
                                        imagesize[nt] * sizeof(int));
                    if (iwork[nt][iw] == NULL) {
                        fflush(stdout);
                        fprintf(stderr,
                                " error allocating memory for varylpthresholdf arrays %d \n",
                                i);
                        fprintf(stderr, " thread %d \n", nt);
                        fprintf(stderr, " element %d \n", iw);
                        exit(EXIT_FAILURE);
                    }
                    memi += (float) imagesize[nt] * sizeof(int);
                }
                for(iw = 0; iw < 4; iw++) {
                    swork[nt][iw] =
                        (unsigned short int *) realloc(swork[nt][iw],
                                                       nmaxregion[nt] *
                                                       sizeof(unsigned short
                                                              int));
                    if (swork[nt][iw] == NULL) {
                        fflush(stdout);
                        fprintf(stderr,
                                " error allocating memory for varylpthresholdf arrays %d \n",
                                i);
                        fprintf(stderr, " thread %d \n", nt);
                        fprintf(stderr, " element %d \n", iw);
                        exit(EXIT_FAILURE);
                    }
                    memi +=
                        (float) nmaxregion[nt] * sizeof(unsigned short int);
                }
		*/
            }

            /*
             * get the image data.  This has the option of getting the bad pixel mask
             * also, in which case we need a pixel mask for every input image, 
             * which is assumed to be <image name>.weight.fits
             * if the mask cannot be found the pixel weights are all set to good 
             */

            /*
             * if swarp distortion correction has been specified then there must be
             * an accompanying .head file 
             */
            if (USE_SWARP == 1) {
                /*
                 * test headerfile can be opened 
                 */
                ret = fopen(headerfile[i], "r");
                if (ret == NULL) {
                    fflush(stdout);
                    fprintf(stderr, " error opening scamp file %s \n",
                            headerfile[i]);
                    fprintf(stderr,
                            " without these files no further astrometric correction can be applied \n");
                    fprintf(stderr,
                            " and yet USE_SWARP correction has been specified in the code \n");
                    fprintf(stderr,
                            " either define USE_SWARP 0 or supply a set of scamp head files, one per image \n");
                    exit(EXIT_FAILURE);
                }
                fclose(ret);
            } else {
                strcpy(headerfile[i], " ");
            }

            /*
             * check if this thread still has a cat open, close it if so (it must have
             * finished with it by now as we waited for the thread to rejoin) 
             */
            if (imagethread[nt] >= 0) {
                free_cat(&rawcat[imagethread[nt]], 1);
                free(rawfield[imagethread[nt]]);
                free(wcs_raw[imagethread[nt]]);
                imagethread[nt] = -1;
            }
            /*
             * use swarp code to get the full wcs info 
             */
            rawcat[i] = (catstruct *) read_cat(imagename[i]);
            if (rawcat[i] == NULL) {
                fflush(stdout);
                fprintf(stderr, " failed to read fits file %s \n",
                        imagename[i]);
                exit(EXIT_FAILURE);
            }
            QCALLOC(rawfield[i], fieldstruct, 1);
            load_dfield(rawfield[i], rawcat[i], headerfile[i], 0, 0);   // modified version of load_field
            wcs_raw[i] = copy_wcs(rawfield[i]->wcs);    // get the wcs info
            if (rawfield[i]->fscale <= 0.) {
                fflush(stdout);
                fprintf(stderr, " error reading flux scale from image %s \n",
                        imagename[i]);
                exit(EXIT_FAILURE);
            }
            /*
             * now handle the object positions for this image and flag if an object
             * is on or off the image by setting the offscale variable 
             */
            number_on_image = 0;
            if (WCS == 1) {
                /*
                 * convert WCS to pixel positions using swarp WCS library 
                 */
	      // printf(" thread %d searching %s %d < n < %d \n",nt,imagename[i],nmin,nmax);
                for(ii = nmin; ii < nmax; ii++) {
                    objx[i][ii] = -999.;
                    objy[i][ii] = -999.;
                    offscale[nt][ii] = 1;
                    wcspos[nt][0] = wcsx[ii];
                    wcspos[nt][1] = wcsy[ii];
                    if (wcs_to_raw(wcs_raw[i], wcspos[nt], rawpos[nt]) ==
                        RETURN_OK) {
                        // check user-specified magnitude limit
                        if (catmag[ii] >= blim && catmag[ii] <= flim) {
                            if (rawpos[nt][0] > 0.
                                && rawpos[nt][0] <
                                (double) rawfield[i]->width) {
                                if (rawpos[nt][1] > 0.
                                    && rawpos[nt][1] <
                                    (double) rawfield[i]->height) {
                                    objx[i][ii] = (float) rawpos[nt][0];
                                    objy[i][ii] = (float) rawpos[nt][1];
				    //if (ii==91025) printf("%d %d %s %5.2f %f %f \n",ii,i,imagename[i],catmag[ii],objx[i][ii],objy[i][ii]);
                                    offscale[nt][ii] = 0;
                                    number_on_image++;
                                }
                            }
                        }
                    }
                }
            } else {
                for(ii = nmin; ii < nmax; ii++) {
                    // skip if below mag limit or off image
                    if (catmag[ii] > flim || catmag[ii] < blim
			|| objx[i][ii] < 0.
                        || objy[i][ii] < 0.)
                        offscale[nt][ii] = 1;
                    else
                        offscale[nt][ii] = 0;
                    number_on_image++;
                }
            }

            /*
             * if there are none of the current set of objects on this image then skip to the next image 
             */
            if (number_on_image <= 0) {
                if (VERBOSE == 1) {
		  printf(" image %s has no current objects \n",imagename[i]);
                    fflush(stdout);
                }
                free_cat(&rawcat[i], 1);
                free(rawfield[i]);
                free(wcs_raw[i]);
                continue;
            }
	    else
	      {
		if (VERBOSE==1)
		  {
		    printf(" image %s has %d current objects\n",imagename[i],number_on_image);
		  }
	      }

            /*
             * get the pixel values (currently uses cfitsio) 
             */
            getdata_badpix(imagename[i], imageweightname[i], dim[i], apix[nt],
                           badpix[nt], &noise[i]);
            if (VERBOSE == 1)
                printf(" raw noise %f \n", noise[i]);
            // getdata_badpix_covar(imagename[i], imageweightname[i], dim[i], apix[nt], badpix[nt], &noise[i]);
            // printf (" covar noise %f \n",noise[i]);
            /*
             * scale image values by fscale 
             */
            noise[i] *= rawfield[i]->fscale;
            if (noise[i] <= 0.) 
	      {
                fflush(stdout);
                fprintf(stderr, " Erroneous noise value %f, image %s \n", noise[i],image_file[i]);
                exit(EXIT_FAILURE);
	      }
            for(pixel = 0; pixel < dim[i][0] * dim[i][1]; pixel++)
                apix[nt][pixel] *= rawfield[i]->fscale;
	    /* scale previously-obtained saturation level by fscale */
            satlev[i] = rawsatlev[i] * rawfield[i]->fscale;
	    if (satlev[i]<=0.)
	      {
		fflush(stdout);
		fprintf(stderr," error in specified saturation level %f for image %s\n",satlev[i],image_file[i]);
		exit(EXIT_FAILURE);
	      }

	    /*
            fmax_intensity[nt] = satlev[i] / 4.;
            scale[nt] = 2. / noise[i];
            imax_intensity[nt] = (int) (fmax_intensity[nt] * scale[nt]);
	    */

            /*
             * flag that we've got this far in this thread 
             */
            //thread_used[nt] = 1;

            /*
             * (re)allocate linked lists for varylthresholdf 
             */
            //printf (" realloc Istart \n");
	    /*
            Istart[nt] =
                (int *) realloc(Istart[nt],
                                (1 + imax_intensity[nt]) * sizeof(int));
            if (Istart[nt] == NULL) {
                fprintf(stderr, "error cannot allocate memory for Istart\n");
                exit(EXIT_FAILURE);
            }
            //printf (" realloc Ilast \n");
            Ilast[nt] =
                (int *) realloc(Ilast[nt],
                                (1 + imax_intensity[nt]) * sizeof(int));
            if (Ilast[nt] == NULL) {
                fprintf(stderr, "error cannot allocate memory for Ilast\n");
                exit(EXIT_FAILURE);
            }
	    */

            /*
             * set the position scale factors for an individual chip 
             */
            if (GLOBAL_PSF == 0) {
                hxsize[i] = (float) dim[i][0] / 2.;
                hysize[i] = (float) dim[i][1] / 2.;
            }

            /*
             * set the noise reference value, if it has not already been set 
             */
            if (noiserefval <= 0.)
	      {
                noiserefval = noise[i];
		printf(" noise reference value set to %f from image %d\n",noiserefval,i+1);
	      }

            /*
             * set the position angle if specified 
             */
            if (phiset == 0)
                phi = angle[i] * pi / 180.;

            /*
             * set up the image weights.  At the moment, just weight inversely
             * by the noise squared.  In fact, the data are all divided by the
             * noise of the first image, to obtain numerical values in the data
             * of order unity, and hence the weights are all relative to
             * the first valid image  
             */

            weight[i] = noiserefval / noise[i];
            weight[i] = weight[i] * weight[i];

            if (VERBOSE == 1) {
                printf
                    ("weight %s\n size %d x %d\n calibrated noise %f\n saturation %f\n weight %f\n",
                     imageweightname[i], dim[i][0], dim[i][1], noise[i],
                     satlev[i], weight[i]);
                fflush(stdout);
                fflush(stderr);
            }

            /*
             * set a new thread going to extract the postage stamps 
             */
            threadarg[nt].objectnum = i;        // image number
            threadarg[nt].threadnum = nt;       // threadnumber
            imagethread[nt] = i;        // keep track of which image is in which thread
            thread_return =
                pthread_create(&threads[nt], &attr, imageloop,
                               (void *) &threadarg[nt]);
            if (thread_return) {
                fflush(stdout);
                fprintf(stderr, " error %d from pthread_create %d \n",
                        thread_return, nt);
                fprintf(stderr, " %s \n", strerror(thread_return));
                exit(EXIT_FAILURE);
            }
            thread_running[nt] = 1;

            nvalid++;           // number of valid image/PSF combinations

            /*
             * increment the thread counter 
             */
            nt++;
            /*
             * reset it if more than NUM_IMAGE_THREAD 
             */
            if (nt >= NUM_IMAGE_THREAD) {
                nt = 0;
            }
	  } 
	else 
	  {
            if (VERBOSE == 1) 
	      {
                printf(" skipping image %s no PSF \n", imagename[i]);
                fflush(stdout);
	      }
            /*
             * test if the CCD is OK but there's no PSF available (but if the PSF
             * has been disqualified no_psf=2 then don't make this check) 
             */
            if (no_psf[i] == 1 && badccd[i] == 0) 
	      {
                fflush(stdout);
                fprintf(stderr,
                        " %s flagged as good, but no PSF file exists\n",
                        imagename[i]);
                fflush(stderr);
                exit(EXIT_FAILURE);
	      }
	  }
      }
    
    /*
     * check that some valid images were found 
     */
    if (nvalid <= 0 && VERBOSE == 1) {
        printf
            (" no valid image/PSF combinations were found when reading in data \n");
        fflush(stdout);
    }

    /*
     * check that no threads are still running, wait if there are 
     */
    for(nt = 0; nt < NUM_IMAGE_THREAD; nt++) {
        if (thread_running[nt] == 1) {
            thread_return = pthread_join(threads[nt], &tstatus);
            if (thread_return != 0 && thread_return != ESRCH) {
                fflush(stdout);
                fprintf(stderr, " error %d from pthread_join %d \n",
                        thread_return, nt);
                fprintf(stderr, " %s \n", strerror(thread_return));
                exit(EXIT_FAILURE);
            }
        }
    }

    //  printf(" data all read in \n");

    /*
     * free remaining memory 
     */

    for(nt = 0; nt < NUM_IMAGE_THREAD; nt++) {
        i = imagethread[nt];
        if (i >= 0) {
            free_cat(&rawcat[i], 1);
            free(rawfield[i]);
            free(wcs_raw[i]);
        }
    }


    return nvalid;

}

double
likelfunc(double x)
{
  double y, Delta, DeltaChiSquared;
  gsl_sf_result yc, ys;

    /*
     * exact integration of equation 4 of Miller et al 2007.
     * The DeltaChiSquared=5.99 term assumes we want to integrate out to
     * a radius where the positional confidence interval is 95 percent.
     * uses gnu scientific library routine for ExpIntegralEi
     */
    DeltaChiSquared = 5.991;
    // convert to delta-log(L)
    Delta = DeltaChiSquared/2.;

    /*
     * if chi-squared max below 5.99 the 95 percent confidence region
     * on the galaxy's position is unconstrained so the shape measurement
     * carries no signal 
     */
    if (x <= Delta) 
      {
        y = UNSATISFACTORY_VALUE;
        return y;
      }
    // deal with very large values using asymptotic approximation
    if (x > 100.) 
      {
	y = x - log(Delta) - exp(-Delta);
        return y;
      }

    // do not let x be too close to Delta
    if ( (x-Delta)<0.0001 ) x = Delta+0.0001;

    // evaluate exponential integral and normalise by prior area
    if ( gsl_sf_expint_Ei_e(x, &yc) == 0 && 
	 gsl_sf_expint_Ei_e((x-Delta), &ys) == 0 )
      {
	y = log( (yc.val - ys.val)/log(x/(x-Delta)) );
      } 
    else 
      {
	// error from gsl_sf: don't halt, just return "bad" value
	y =  UNSATISFACTORY_VALUE;
      }
    return y;
    
}


/* function to make a stack of all postage stamps for a single object,
   detect background object pixels, and flag them out.  LM Dec 2009 */

int
detectobject(int nt,            /* thread number */
             int obj,           /* object number */
             double **Dpix      /* stack of quadrant swapped postage stamps */
    )
{
    int i, j, k, kk, ii, jj, x, y, xx, yy, pixel, size, status, nlist, more, iter,
      idx, idy, tobj, sobj, itemp;
    int n, n2, ncol, dx, dy, numlimit, target, neighbour, nfit, dorder,
        dncoeffs, dcrossterm;
    int useful, niter, idsnlimit;
    int nswap, ntcol, found, nkcol[9], kcol[9], nmaxcol, better_colour;
    double radius, minradius, maxr, dsnlimit, ldsnlimit, stop_dsn, meanx, meany, sumw;
    double hsize, xd, yd, sgauss[4][4], smooth;
    double signoise, sigweight;

    /* status return values are:
       0 - good fit
       2 - weighted centroid outside central region defined by radius poserror
       4 - no useful images left after background object pixels flagged out etc (often bad background subtraction)
       5 - object isophotes fill postage stamp

       These codes are transferred through to the output lensfit flags, such that
       the output flag is -4-status for 0 < status < 5

     */

    // set return status
    status = 0;

    size = pwidth * pheight;

    // minimum number of pixels in an object
    numlimit = 8;

    // default signal-to-noise ratio of the data
    snratio[obj] = 0.;

    // make a symmetric gaussian smoothing function of FWHM the same as the Moffat-assumption FWHM
    smooth = moffatfwhm/2.35;      
    if (smooth > 0.)
      {
	for(dy = 0; dy <= 2; dy++) {
	  for(dx = 0; dx <= 2; dx++) {
            sgauss[dy][dx] =
	      exp(-(double) (dx * dx + dy * dy) / 2. / smooth / smooth);
	  }
	}
      }
    else
      {
	fflush(stdout);
	fprintf(stderr," error, nominal PSF smoothing size is %f in detectobject\n", smooth);
	exit(EXIT_FAILURE);
      }

    // do 3 iterations to improve the background determination and object rejection
    niter=1;
    if (subtract_background==1) niter=4;
    for(iter = 0; iter < niter; iter++) {

        for(ii = 0; ii < size; ii++) {
            sn[nt][ii] = 0.;
            sw[nt][ii] = 0.;
            sn1[nt][ii] = 0.;
            sw1[nt][ii] = 0.;
            colour[nt][ii] = 0;
	    objnum[nt][ii] = 0;
	    objpix[nt][ii] = 0;
        }
	objnum[nt][size] = 0;
	objpix[nt][size] = 0;

        // summations for S/N array (note - quadrant-swapping undone at thispoint) 
        for(j = 0; j < nimages; j++) {
            // choose valid images from the stack and coadd them
            jj = extractedobject[j][obj];
            if (jj >= 0) {
                // create S/N array
                for(i = 0; i < size; i++) {
                    // exclude pixels set to exactly 0
                    if (Dpix[jj][i] != 0.) {
                        // swap quadrants back to usual arrangement with 0 in centre
                        y = i / pwidth;
                        x = i - y * pwidth;
                        y += pheight / 2;
                        x += pwidth / 2;
                        if (y >= pheight)
                            y -= pheight;
                        if (x >= pwidth)
                            x -= pwidth;
                        // weighted summation takes account of different noise on each image
                        // first without smoothing
                        ii = x + y * pwidth;
                        sn1[nt][ii] += weight[j] * Dpix[jj][i];
                        sw1[nt][ii] += weight[j];
                        // apply a small smoothing kernel also
                        for(dy = -2; dy <= 2; dy++) {
                            idy = abs(dy);
                            yy = y + dy;
                            if (yy >= 0 && yy < pheight) {
                                for(dx = -2; dx <= 2; dx++) {
                                    idx = abs(dx);
                                    xx = x + dx;
                                    if (xx >= 0 && xx < pwidth) {
                                        ii = xx + yy * pwidth;
                                        sn[nt][ii] +=
                                            sgauss[idy][idx] * weight[j] *
                                            Dpix[jj][i];
                                        sw[nt][ii] +=
                                            sgauss[idy][idx] * weight[j];
                                    }
                                }
                            }
                        }
                    }
                }
            }
        }

        // make list of bright pixels
        nlist = 0;
        for(i = 0; i < size; i++) {
            // if valid pixels, convert summed array into S/N, choose highest of sn or sn1
            if (sw[nt][i] > 0.)
                sn[nt][i] = sn[nt][i] / sqrt(sw[nt][i]);
            else
                sn[nt][i] = 0.;

            if (sw1[nt][i] > 0.)
                sn1[nt][i] = sn1[nt][i] / sqrt(sw1[nt][i]);
            else
                sn1[nt][i] = 0.;

            if (sn1[nt][i] > sn[nt][i])
                sn[nt][i] = sn1[nt][i];

            /*
             * flag pixels that have S/N greater than dsnlimit in the weighted stack
             * and that have at least one neighbour greater than dsnlimit (this
             * speeds things up later) 
             */
	    ldsnlimit = 2.;
            if (sn[nt][i] > ldsnlimit) {
                neighbour = 0;
                y = i / pwidth;
                x = i - y * pwidth;
                for(dy = -1; dy <= 1; dy++) {
                    yy = y + dy;
                    if (yy >= 0 && yy < pheight) {
                        for(dx = -1; dx <= 1; dx++) {
                            xx = x + dx;
                            if (xx >= 0 && xx < pwidth) {
                                j = xx + yy * pwidth;
                                if (sn[nt][j] > ldsnlimit) {
                                    neighbour++;
                                }
                            }
                        }
                    }
                }
                if (neighbour > 1)      // pixel i has included itself in the above loop hence test > 1
                {
                    objpix[nt][nlist] = i;
                    nlist++;
                }
            }
        }

	// go through these pixels and rank them by brightness
	more = 1;
	while (more == 1)
	  {
	    more = 0;
	    for(jj = 1; jj < nlist; jj++) {
	      tobj = objpix[nt][jj];
	      sobj = objpix[nt][jj-1];
	      if (sn[nt][tobj] > sn[nt][sobj]) {
		itemp = objpix[nt][jj];
		objpix[nt][jj] = objpix[nt][jj-1];
		objpix[nt][jj-1] = itemp;
		more = 1;
	      }
	    }
	  }

	// go through and create objects of connected pixels starting with the brightest objects
	// and working down by unity in S/N at each step
	n = 0; // colour
	stop_dsn = 3.;
	if (subtract_background==1 && iter==niter-4) stop_dsn = 15.;
	if (subtract_background==1 && iter==niter-3) stop_dsn = 10.;
	if (subtract_background==1 && iter==niter-2) stop_dsn = 6.;
	for (idsnlimit=20; idsnlimit>=stop_dsn; idsnlimit--)
	  {
	    dsnlimit = (double)idsnlimit;
	    // go through list and find connected sets of bright pixels
	    for(jj = 0; jj < nlist; jj++) {
	      // if this pixel is not coloured and its sn is above the higher limit
	      if (colour[nt][objpix[nt][jj]] == 0 && sn[nt][objpix[nt][jj]] > dsnlimit) {
                // start a new colour
                n++;
                colour[nt][objpix[nt][jj]] = n;
                objnum[nt][n] = 1;
                // keep looping through bright pixels until no new additions are made
                more = 1;
                while (more == 1) {
		  more = 0;
		  for(i = 0; i < nlist; i++) {
		    if (colour[nt][objpix[nt][i]] == n) {
		      y = objpix[nt][i] / pwidth;
		      x = objpix[nt][i] - y * pwidth;
		      for(dy = -1; dy <= 1; dy++) {
			yy = y + dy;
			if (yy >= 0 && yy < pheight) {
			  for(dx = -1; dx <= 1; dx++) {
			    xx = x + dx;
			    if (xx >= 0 && xx < pwidth) {
			      j = xx + yy * pwidth;
			      // use the higher limit on sn for this colour assignment
			      if (sn[nt][j] > dsnlimit
				  && colour[nt][j] == 0) {
				colour[nt][j] = n;
				objnum[nt][n]++;
				more = 1;
			      }
			    }
			  }
			}
		      }
		    }
		  }
                }
	      }
	    }
	    // go through all remaining pixels in the list that do yet have an assigned colour, and attempt
	    // to assign them colours of neighbouring pixels, until they have all been assigned 
	    // use a lower threshold on S/N for this colour assignment.
	    // don't create any new colours, however
	    ldsnlimit = dsnlimit-2;
	    if (ldsnlimit<2.) ldsnlimit=2.;
	    more = 1;
	    while (more==1)
	      {
		more = 0;
		for(jj = 0; jj < nlist; jj++) {
		  i = objpix[nt][jj];
		  if (colour[nt][i] == 0 && sn[nt][i] > ldsnlimit) {
		    y = i / pwidth;
		    x = i - y * pwidth;
		    for(dy = -1; dy <= 1; dy++) {
		      yy = y + dy;
		      if (yy >= 0 && yy < pheight) {
			for(dx = -1; dx <= 1; dx++) {
			  xx = x + dx;
			  if (xx >= 0 && xx < pwidth) {
			    j = xx + yy * pwidth;
			    ncol = colour[nt][j];
			    if (ncol > 0 && colour[nt][i]==0) {
			      colour[nt][i] = ncol;
			      objnum[nt][ncol]++;
			      more = 1;
			    }
			  }
			}
		      }
		    }
		  }
		}
	      }
	    // merge any small objects with sizes below numlimit into larger ones if possible
	    more = 1;
	    while (more==1)
	      {
		more=0;
		for(jj = 0; jj < nlist; jj++) {
		  i = objpix[nt][jj];
		  ncol = colour[nt][i];
		  if (ncol > 0) {	
		    // if this is a small object then test for neighbours of other colours and reassign them
		    if (objnum[nt][ncol] < numlimit)
		      {
			y = i/pwidth;
			x = i - y * pwidth;
			for(dy = -1; dy <= 1; dy++) {
			  yy = y + dy;
			  if (yy >= 0 && yy < pheight) {
			    for(dx = -1; dx <= 1; dx++) {
			      xx = x + dx;
			      if (xx >= 0 && xx < pwidth) {
				j = xx + yy * pwidth;
				n2 = colour[nt][j];
				if (n2 > 0 && n2 != ncol)
				  {
				    // switch all pixels with this colour to prevent endless looping
				    for(kk = 0; kk < nlist; kk++) {
				      k = objpix[nt][kk];
				      if (colour[nt][k] == ncol)
					{
					  colour[nt][k] = n2;
					  objnum[nt][n2]++;
					  objnum[nt][ncol]--;
					  more = 1;
					}
				    }
				    ncol = n2;
				  }
			      }
			    }		
			  }
			}
		      }
		  }
		}
	      }
	    // tidy up the segmented regions by checking if any coloured pixels would be
	    // better assigned to another colour
	    nswap = 0;
	    more = 1;
	    while (more==1 && nswap<pwidth*pheight)
	      {
		more = 0;
		for(jj = 0; jj < nlist; jj++) {
		  i = objpix[nt][jj];
		  ncol = colour[nt][i];
		  if (ncol > 0) {	
		    // test for neighbours of other colours 
		    y = i/pwidth;
		    x = i - y * pwidth;
		    ntcol = 0;
		    for(dy = -1; dy <= 1; dy++) {
		      yy = y + dy;
		      if (yy >= 0 && yy < pheight) {
			for(dx = -1; dx <= 1; dx++) {
			  xx = x + dx;
			  if (xx >= 0 && xx < pwidth) {
			    j = xx + yy * pwidth;
			    n2 = colour[nt][j];
			    if (n2 > 0)
			      {
				found = 0;
				for (k=0; k<ntcol; k++)
				  {
				    if (n2 == kcol[k]) 
				      {
					nkcol[k]++;
					found = 1;
				      }
				  }
				if (found==0)
				  {
				    kcol[ntcol] = n2;
				    nkcol[ntcol] = 1;
				    ntcol++;
				  }
			      }
			  }
			}
		      }
		    }
		    nmaxcol = 0;
		    better_colour = ncol;
		    for (k=0; k<ntcol; k++)
		      {
			if (nkcol[k] > nmaxcol)
			  {
			    nmaxcol = nkcol[k];
			    better_colour = kcol[k];
			  }
		      }
		    if (better_colour > 0 && better_colour != ncol)
		      {
			ncol = colour[nt][i] = better_colour;			
			more = 1;
			nswap++;
		      }
		  }
		}
	      }
	    /*
	    if (nswap > 20)
	      printf(" swapped %d pixel colours for object %d level %d \n",nswap,obj,idsnlimit); fflush(stdout);
	    */
	    if (nswap >= (pwidth*pheight-1))
	      {
		printf(" warning, too many colour swaps for object %d \n",obj+1); fflush(stdout);
	      }

	  }

        /*
         * now all bright pixels have been assigned a colour.  work through
         * each image in the stack and recalculate the background (optional)
         */

        hsize = (double) pwidth / 2.;
        /*
         * fit linear surface 
         */
	if (subtract_background==1)
	  {
	    dorder = 1;
	    dncoeffs = 3;
	    dcrossterm = 0;

	    for(k = 0; k < nimages; k++) {
	      jj = extractedobject[k][obj];
	      if (jj >= 0) {
                nfit = 0;
                for(j = 0; j < size; j++) {
		  y = j / pwidth;
		  x = j - y * pwidth;
		  // coords wrt origin
		  xd = x - pwidth / 2;
		  yd = y - pheight / 2;
		  // quadrant-swap pixel ID back to swapped-coords for Dreal
		  y += pheight / 2;
		  x += pwidth / 2;
		  if (y >= pheight)
		    y -= pheight;
		  if (x >= pwidth)
		    x -= pwidth;
		  pixel = x + y * pwidth;
		  // if pixels are valid and not part of any object, increment for fitting
		  if ((colour[nt][j] == 0
		       || objnum[nt][colour[nt][j]] < numlimit)
		      && Dpix[jj][pixel] != 0.) {
		    xfit[nt][nfit] = xd / hsize;
		    yfit[nt][nfit] = yd / hsize;
		    wfit[nt][nfit] = 1.;
		    zfit[nt][nfit] = Dpix[jj][pixel];
		    nfit++;
		  }
                }
                /*
                 * only if there's enough pixels, subtract the fitted background 
                 */
                if (nfit > 10) {
		  for(i = 0; i <= dncoeffs; i++) {
		    w[nt][i] = 0.;
 		    for(j = 0; j <= dncoeffs; j++) {
		      u[nt][i][j] = 0.;
		      v[nt][i][j] = 0.;
		    }
		  }
		  svdfit2dsqc(xfit[nt], yfit[nt], zfit[nt], wfit[nt], nfit,
			      dorder, dcrossterm, avals[nt], u[nt], v[nt], w[nt]);
		  nfit = 0;
		  for(j = 0; j < size; j++) {
		    y = j / pwidth;
		    x = j - y * pwidth;
		    xd = x - pwidth / 2;
		    yd = y - pheight / 2;
		    // quadrant swap back to swapped-coords for Dreal
		    y += pheight / 2;
		    x += pwidth / 2;
		    if (y >= pheight)
		      y -= pheight;
		    if (x >= pwidth)
		      x -= pwidth;
		    pixel = x + y * pwidth;
		    if (Dpix[jj][pixel] != 0.) {
		      xfit[nt][nfit] = xd / hsize;
		      yfit[nt][nfit] = yd / hsize;
		      zfit[nt][nfit] =
			avals[nt][1] + avals[nt][2] * yfit[nt][nfit] +
			avals[nt][3] * xfit[nt][nfit];
		      Dpix[jj][pixel] -= zfit[nt][nfit];
		    }
		  }
                }
	      }
	    }
	  }

        // next iteration
    }

    /*
     * Work through each colour,
     * if the colour has enough pixels, find if any of these are inside poserror.
     * If they are not, this is a background object, set all its pixels to zero.
     * If it has pixels inside poserror, it is a target object and its pixels remain.
     * But if more than one such target object is found inside poserror, an error status
     * is generated 
     */

    // find the maximum colour that is still in use
    n=0;
    for (i=0; i<size; i++)
      {
	if (colour[nt][i] > n) n = colour[nt][i];
      }

    // find the object whose centroid is closest to the centre and designate this as the target
    target = -1;
    minradius = pwidth;
    for (i=1; i<=n; i++)
      {
	// work out weighted centroid and maximum extent of this object
	meanx = 0.;
	meany = 0.;
	sumw = 0.;
	for(j = 0; j < size; j++) {
	  if (colour[nt][j] == i) {
	    y = j / pwidth;
	    x = j - y * pwidth;
	    yd = y - pheight / 2;
	    xd = x - pwidth / 2;
	    meanx += xd * sn[nt][j];
	    meany += yd * sn[nt][j];
	    sumw += sn[nt][j];
	  }
	}
	if (sumw > 0.) {
	  meanx = meanx / sumw;
	  meany = meany / sumw;
	  radius = sqrt(meanx*meanx+meany*meany);
	  if (radius<minradius) {
	    minradius = radius;
	    target = i;
	  }
	}
      }

    // if the centroid is outside poserror set no target found
    if (minradius > poserror) target = -1;

    // test if other objects have pixels within poserror	  
    maxr = 0.;
    for(i = 1; i <= n; i++) {
      for(j = 0; j < size; j++) {
	if (colour[nt][j] == i) {
	  y = j / pwidth;
	  x = j - y * pwidth;
	  // radius from centre (remember we have quadrant swapped)
	  radius =
	    sqrt((double) (y - pheight / 2) * (y - pheight / 2) +
		 (double) (x - pwidth / 2) * (x - pwidth / 2));
	  // test against poserror
	  if (radius < poserror) {
	    // set the confused flag if this is not the designated target
	    if (target > 0 && i != target) status = 2;
	    // or if no designated target exists but pixels exist within poserror
	    if (target == -1){
	      target = i;
	      status = 2;
	    }
	  }
	  // test if the target object has an excessive extent
	  if (i==target && radius>maxr) maxr=radius;
	}
      }
    }
    // flag target objects that have pixels extending too far across postage stamp
    if (maxr >= 0.8*pwidth/2 && status==0) status=5;

    // measure S/N of integrated light in the selected unsmoothed pixels
    signoise = sigweight = 0.;
    for(k = 0; k < nimages; k++) {
      jj = extractedobject[k][obj];
      if (jj >= 0) {
	for(j = 0; j < size; j++) {
	  y = j / pwidth;
	  x = j - y * pwidth;
	  yd = y - pheight / 2;
	  xd = x - pwidth / 2;
	  radius = sqrt(xd*xd+yd*yd);
	  if (colour[nt][j] == target || (target==-1 && radius<poserror)) {
	    if (xd < 0) xd += pwidth;
	    if (yd < 0) yd += pheight;
	    pixel = xd + yd * pwidth;
	    if (Dpix[jj][pixel] != 0.) {
	      signoise += weight[k] * Dpix[jj][pixel];
	      sigweight += weight[k];
	    }
	  }
	}
	}
    }
    if (sigweight > 0.)
      snratio[obj] = signoise / sqrt(sigweight);

    // set pixels of background objects to zero
    for(j = 0; j < size; j++) {
      if (colour[nt][j]>0 && colour[nt][j] != target) {
	y = j / pwidth;
	x = j - y * pwidth;
	// quadrant swap
	y += pheight / 2;
	x += pwidth / 2;
	if (y >= pheight) y -= pheight;
	if (x >= pwidth) x -= pwidth;
	pixel = x + y * pwidth;
	for(k = 0; k < nimages; k++) {
	  jj = extractedobject[k][obj];
	  if (jj >= 0) {
	    Dpix[jj][pixel] = 0.;
	  }
	}
      }
    }

    /*
     * recalculate number of good pixels and sum of data-squared 
     */
    for(k = 0; k < nimages; k++) {
        jj = extractedobject[k][obj];
        if (jj >= 0) {
            datasq[obj][jj] = 0.;
            numgoodpix[obj][jj] = 0;
            for(i = 0; i < size; i++) {
                if (Dpix[jj][i] != 0.) {
                    numgoodpix[obj][jj]++;
                    datasq[obj][jj] += Dpix[jj][i] * Dpix[jj][i];
                }
            }
            if (numgoodpix[obj][jj] > 0)
                datasq[obj][jj] =
                    datasq[obj][jj] / (double) numgoodpix[obj][jj];
            else
                datasq[obj][jj] = 0.;
        }
    }

    // check if there are any good images left
    useful = 0;
    for(k = 0; k < nimages; k++) {
        jj = extractedobject[k][obj];
        if (jj >= 0) {
	  if (numgoodpix[obj][jj] > (pwidth*pheight/2)) {
                useful = 1;
                break;
            }
        }
    }
    if (useful == 0)
        status = 4;

    return status;

}



void
make2Dgalaxymodel(int nt,
                       float **modelft, 
                       double e1, double e2, double Ro
                       )
{
    int i, mt, halfmwidth, x, y, yp, xp, xx, yx, yxp;
    int ix, iy, yy, pheight, opixel, ipixel;
    int msf;
    // int gsl_status;
    double r, sb, etasq, factor, expfactor, ScaledRo, bScaledRo, bulgeRo;
    double rdisk, rbulge, diskRo; 
    // double extcoeff, kappa;
    double eta, etat, beta, e1t, e2t;
    double etab, etabt, etaobs, betab, e1bt, e2bt, etabsq, bfactor, brmax;
    double mflux, bflux, rmax;
    double nfactor, galaxyextent, psfextent;
    double rval, pval, wbulge, C;
    //double dflux, wdisk;
    double cosi, sini;
    double diskbeta0, cosisq, emod;
    // double betaobs;

    /*
     * the model is created on a finer grid than the actual data
     * in an attempt to reduce problems caused by
     * having an undersampled model galaxy with a sharp central
     * cusp.  For the problemtic r=0 point in a de Vaucouleurs profile,
     * the value is replaced by that needed to ensure the total flux
     * within the half-light radius comes out correct. So the model
     * is initially created with a larger size, mheight*mwidth, the
     * model is Fourier transformed, and the high spatial frequencies
     * are then removed.  Because the model is a real, even function
     * its Fourier transform is also real and even, so we only need
     * store the real component, and we only need store half the array 
     */

    /*
     * this version fits bulge+disk profile assuming a fixed T and size ratio
     */

    etasq = e1*e1 + e2*e2;

    /* convert disk ellipticity to inclination assuming a fixed thickness model,
       then pedict what the corresponding bulge ellipticity will be given
       that inclination and assuming the bulge to be a fixed prolate ellipsoid.

       This procedure has the aim of building in the know ellipticity gradient
       caused by bulges of disk galaxies not being as flattened as the disks
       at high inclinations.  However, it makes the calculation of effective
       ellipticity and sensitivity problematic, so for now this enhancement is
       commented-out, although we still need cosi for the extinction correction */

    if (etasq>0.) 
      {
	emod = sqrt(etasq);
	beta = (1.-emod)/(1.+emod);
	diskbeta0 = (1.-efunc_emax)/(1.+efunc_emax);
	cosisq = (beta*beta-diskbeta0*diskbeta0)/(1.-diskbeta0*diskbeta0);
	if (cosisq<0.) cosisq = 0.;
	if (cosisq>1.) cosisq = 1.;
	cosi = sqrt(cosisq);
	sini=0.;
	if (cosisq<1.) sini = sqrt(1.-cosisq);
      }
    else
      {
	cosi = 1.;
	sini = 0.;
      }
    
    /*
    // apparent bulge axis ratio for this inclination
    betaobs = sqrt(cosi*cosi + beta0*beta0*sini*sini);      
    // convert to ellipticity:
    etaobs = (1.-betaobs)/(1.+betaobs);;
    */

    /* alternatively, simply make the bulge ellipticity the same as the disk */

    etaobs = sqrt(etasq);

    /*
     * this version transforms input e1, e2 values assuming they are
     * in the STEP convention into e1, e2 values assuming the heymans-thesis
     * convention, which is how this code was first created. 
     */

    etasq = e1 * e1 + e2 * e2;
    if (etasq > 0.) {
      // disk
      eta = sqrt(etasq);
      beta = (1. - eta) / (1. + eta);
      etat = (1. - beta * beta) / (1. + beta * beta);
      e1t = e1 * etat / eta;
      e2t = e2 * etat / eta;

      // similarly for the bulge, taking the value etaobs from above
      betab = (1.-etaobs)/(1.+etaobs);
      etabt = (1.-betab*betab)/(1.+betab*betab);
      e1bt = e1 * etabt / eta;
      e2bt = e2 * etabt / eta;
      etabsq = e1bt * e1bt + e2bt * e2bt;
      etab = sqrt(etabsq);

      // disk
      etasq = e1t * e1t + e2t * e2t;
      eta = sqrt(etasq);

    } else {
        beta = betab = 1.;
        eta = etab = 0.;
        etasq = etabsq = 0.;
        e1t = e1bt = 0.;
        e2t = e2bt = 0.;
    }

    /*
     * fix the sign of e1 - in the following we assume a 
     * non-standard definition of position angle, so this fix
     * makes the galaxy model orientation come out in the 
     * conventional way 
     */
    e1t = -e1t;
    e1bt = -e1bt;

    // set some scalings
    pheight = 2 * halfpheight;
    // find the scale factor needed to fit this galaxy into the model array
    galaxyextent = Ro*Rcutoff*4;
    // find also some maximum scalefactor before the PSF overfills the array
    //psfextent = 1.13*sqrt(mm[0])*8;
    psfextent = 0.870*sqrt(mm[0])*8;
    if (psfextent > galaxyextent) galaxyextent = psfextent;
    if (Ro > 0.)
      {
	if (galaxyextent>0.)
	  {
	    msf = 1 + 2 * ((int)(mwidth/galaxyextent)/2);      // must be an odd integer multiplier
	  }
	else
	  {
	    fflush(stdout);
	    fprintf(stderr," error, galaxyextent %f \n",galaxyextent);
	    exit(EXIT_FAILURE);
	  }
      }
    else
      {
	// star model
	msf = mheight/pheight;
      }
    if (MODEL_OVERSAMPLING == 0) msf=1;

    /*
     * the input scale-length is assumed to be semi-major axis.  In the following
     * we convert to a scalelength which is flux- and area-invariant with
     * ellipticity (this is different for 3D models).  Also scale up the model size by msf
     */
    ScaledRo = Ro * sqrt(beta) * msf;
    bScaledRo = Ro * sqrt(betab) * msf;

    /*
     * the model/data oversampling factor must be an odd integer to preserve symmetry 
     */
    if (msf - 2 * (msf / 2) != 1) 
      {
        fflush(stdout);
        fprintf(stderr,
                " error: 2D model oversampling factor %d must be an odd integer \n",msf);
        exit(EXIT_FAILURE);
      }


    /*
     * scale the bulge half-light radius by some constant factor 
     * relative to the disk scalelength
     */
    diskRo = ScaledRo;
    bulgeRo = bScaledRo * bscalefactor;

    /* calculate an I-band inclination-dependent extinction factor based on Table 1 of
       Graham & Worley 2008, truncated at extreme inclinations 
    // delta-magnitude
    // I-band relation
    //    extcoeff = cosi>0.1 ? 0.24 + (0.46-1.)*2.5*log10(cosi) : 0.24 + (0.46-1.)*2.5*log10(0.1);
    // V-band relation
    extcoeff = cosi>0.1 ? 0.43 + (0.43-1.)*2.5*log10(cosi) : 0.43 + (0.43-1.)*2.5*log10(0.1);
    // B-band relation
    // extcoeff = cosi>0.1 ? 0.59 + (0.44-1.)*2.5*log10(cosi) : 0.59 + (0.44-1.)*2.5*log10(0.1);
    // log_e factor in flux
    extcoeff *= 0.4*M_LN10;
    // convert back to factor in flux
    extcoeff = exp(-extcoeff);
    // now we need to find the root of the equation exp(-kappa)=1-kappa*extcoeff, do this approx
    
    kappa = 1./extcoeff;
    while ( kappa > 0. && (1.-kappa*extcoeff)<exp(-kappa) )
      {
	kappa -= 0.001;
      }
    if (kappa<=0.) kappa=0.001;

    */    

    halfmwidth = 1 + mwidth / 2;

    if (etasq >= 1.) {
        //printf(" !!! eta squared = %g \n", etasq);
        //exit(EXIT_FAILURE);
        return;
    }

    factor = sqrt(1. - etasq);
    bfactor = sqrt(1. - etabsq);

    if (Sindex==0.25)
      {
	C = 7.67;    // de Vauc factor
      }
    else if (Sindex==0.5)
      {
	C = 3.672;   // Sersic n=2 factor
      }
    else
      {
	fflush(stdout);
	fprintf(stderr," invalid inverse Sersic index, must be 0.25 or 0.5 \n");
	exit(EXIT_FAILURE);
      }

    if (ScaledRo > 0.) {
        /*
         * set the maximum r that fits inside the array for any arbitrary orientation
         * of this ellipse 
         */
        rmax = (mwidth / 2 - 1) * sqrt((1. - eta) / factor);
        brmax = (mwidth / 2 - 1) * sqrt((1. - etab) / bfactor);

        /*
         * initialise 
         */
        bflux = 0.;
        //dflux = 0.;
        for(y = 0; y < mheight; y++) {
            for(x = 0; x < mwidth; x++) {
                yx = y * mwidth + x;
                disk[nt][yx] = bulge[nt][yx] = 0.;
            }
        }

	// bulge
        for(y = 1; y < mheight; y++) {
            yp = mheight - y;
            for(x = 1; x < (1 + mwidth / 2); x++) {
                xp = mwidth - x;
                yx = y * mwidth + x;
                yxp = yp * mwidth + xp;
                r = sqrt((rp[yx] + rd[yx] * e1bt - rc[yx] * e2bt) / bfactor);
                if (r <= brmax) {
                    rbulge = r / bulgeRo;
                    if (rbulge <= Rcutoff) {
                        expfactor = C * (pow(rbulge, Sindex) - 1.);
                        sb = exp(-expfactor);
                        bulge[nt][yx] = sb;
                        bulge[nt][yxp] = sb;
                        bflux += bulge[nt][yx];
                        if (xp != x)
                            bflux += bulge[nt][yxp];
                    }
                }
            }
        }

        y = 0;
        yp = 0;
        for(x = 1; x < (1 + mwidth / 2); x++) {
            yx = y * mwidth + x;
            xp = mwidth - x;
            yxp = yp * mwidth + xp;
            r = sqrt((rp[yx] + rd[yx] * e1bt - rc[yx] * e2bt) / bfactor);
            if (r <= brmax) {
                rbulge = r / bulgeRo;
                if (rbulge <= Rcutoff) {
                    expfactor = C * (pow(rbulge, Sindex) - 1.);
                    sb = exp(-expfactor);
                    bulge[nt][yx] = sb;
                    bulge[nt][yxp] = sb;
                    bflux += bulge[nt][yx];
                    if (xp != x)
                        bflux += bulge[nt][yxp];
                }
            }
        }

        for(y = 0; y < mheight; y++) {
            x = 0;
            yx = y * mwidth + x;
            r = sqrt((rp[yx] + rd[yx] * e1bt + rc[yx] * e2bt) / bfactor);
            if (r <= brmax) {
                rbulge = r / bulgeRo;
                if (rbulge <= Rcutoff) {
                    expfactor = C * (pow(rbulge, Sindex) - 1.);
                    sb = exp(-expfactor);
                    bulge[nt][yx] = sb;
                    if (y > 0)
                        bflux += bulge[nt][yx];
                }
            }
        }

	// disk
        for(y = 1; y < mheight; y++) {
            yp = mheight - y;
            for(x = 1; x < (1 + mwidth / 2); x++) {
                xp = mwidth - x;
                yx = y * mwidth + x;
                yxp = yp * mwidth + xp;
                r = sqrt((rp[yx] + rd[yx] * e1t - rc[yx] * e2t) / factor);
                if (r <= rmax) {
                    rdisk = r / diskRo;
                    if (rdisk <= Rcutoff) {
                        sb = exp(-rdisk);
			/* apply the extinction correction: this is evaluated for central
			   surface brightness in the I band from Graham&Worley 2008 as
			   above, but now we apply this to all pixels assuming simple abs model*/
			//sb = (1.-exp(-kappa*sb))/kappa;
                        disk[nt][yx] = sb;
                        disk[nt][yxp] = sb;
			/*
                        dflux += disk[nt][yx];
                        if (xp != x)
                            dflux += disk[nt][yxp];
			*/
                    }
                }
            }
        }

        y = 0;
        yp = 0;
        for(x = 1; x < (1 + mwidth / 2); x++) {
            yx = y * mwidth + x;
            xp = mwidth - x;
            yxp = yp * mwidth + xp;
            r = sqrt((rp[yx] + rd[yx] * e1t - rc[yx] * e2t) / factor);
            if (r <= rmax) {
                rdisk = r / diskRo;
                if (rdisk <= Rcutoff) {
                    sb = exp(-rdisk);
		    // sb = (1.-exp(-kappa*sb))/kappa;  
                    disk[nt][yx] = sb;
                    disk[nt][yxp] = sb;
		    /*
                    dflux += disk[nt][yx];
                    if (xp != x)
                        dflux += disk[nt][yxp];
		    */
                }
            }
        }

        for(y = 0; y < mheight; y++) {
            x = 0;
            yx = y * mwidth + x;
            r = sqrt((rp[yx] + rd[yx] * e1t + rc[yx] * e2t) / factor);
            if (r <= rmax) {
                rdisk = r / diskRo;
                if (rdisk <= Rcutoff) {
                    sb = exp(-rdisk);
		    // sb = (1.-exp(-kappa*sb))/kappa;  
                    disk[nt][yx] = sb;
		    /*
                    if (y > 0)
                        dflux += disk[nt][yx];
		    */
                }
            }
        }

        /*
         * work out the central pixel flux required to match the integrated light 
         */
        // bulge
        rval = rmax / bulgeRo;
        if (rval > Rcutoff) rval = Rcutoff;

	if (Sindex==0.25)
	  {
	    /* de vauc integration */
	    pval = pow(rval, Sindex);
	    wbulge = ((6. + pval*C*(6.+pval*C*(3.+C*pval)))/6.
		      + rval*C*C*C*C * (210. + pval*C * (42. + pval*C * (7. + pval*C))) /
		      5040.)*exp(-C*pval);
	    wbulge = 1. - wbulge;
	    mflux = 2. * pi * bulgeRo * bulgeRo * exp(C) * wbulge * 20160. / pow(C, 8.);
	  }
	else if (Sindex==0.5)
	  {
	    /* Sersic index=2 */
	    pval = C*sqrt(rval);
	    wbulge = (6.-(6.+(6.+3*pval+C*C*rval)*pval)*exp(-pval))/6.;
	    mflux = 2. * pi * bulgeRo * bulgeRo * exp(C) * wbulge * 12. / pow(C, 4.);
	  }
	else
	  {
	    fflush(stdout);
	    fprintf(stderr," invalid bulge inverse Sersic index, must be 1/2 or 1/4 \n");
	    exit(EXIT_FAILURE);
	  }

	/* correct central pixel for flux difference */
        bulge[nt][0] = mflux - bflux;

        //psfellipticitycentroid(bulge,mheight,mwidth,psfe,centroid);
        //printf("bulge %f %f %f %f %f %f %f %f \n",bulgeRo,e1,e2,betab,wbulge,mflux,bflux,bulge[nt][0]);

        // disk

	/*
        rval = rmax / diskRo;
        if (rval > Rcutoff) rval = Rcutoff;
        wdisk = 1. - (1. + rval) * exp(-rval);
        mflux = 2. * pi * diskRo * diskRo * wdisk;
        disk[nt][0] = mflux - dflux;
	//psfellipticitycentroid(disk,mheight,mwidth,psfe,centroid);
        printf("disk  %f %f %f %f %f %f %f %f \n",diskRo,e1,e2,beta,wdisk,mflux,dflux,disk[nt][0]);
	*/

        /*
         * uncomment the following part to write out fits images of the models 
         * 
         * float mbulge[147456];
         * int anaxis=2;
         * long fpixel[2]={1,1}, lrow;
         * long anaxes[2]; 
         * anaxes[0]=mwidth;
         * anaxes[1]=mheight;
         * int bitpix=-32;
         * int testsize=mwidth*mheight;
         * fitsfile *tfptr;
         * int status=0;
         * char stampname[300];
         * 
         * // swap!!!
         * for (iy=0; iy<mheight; iy++)
         * {
         * yy=iy+mheight/2;
         * if (yy>=mheight)yy-=mheight;
         * {
         * for (ix=0; ix<mwidth; ix++)
         * {
         * xx=ix+mwidth/2;
         * if (xx>=mwidth)xx-=mwidth;
         * {
         * j=xx+yy*mwidth;
         * i=ix+iy*mwidth;
         * mbulge[j]=bulge[nt][i];
         * }
         * }
         * }
         * }
         * 
         * // create a unique filename for the postage stamps 
         * pthread_mutex_lock (&fitsfilelock);
         * strcpy(stampname,"model.1.fits");
         * i=0;
         * // if this file already exists make a new name
         * while (access(stampname,F_OK) == 0)
         * {
         * i++;
         * bzero(stampname,300);
         * sprintf(stampname, "model.%d.fits", i);
         * }
         * if (i<1000)
         * {
         * //printf(" writing mean postage stamps to file %s \n",stampname);
         * // create the file and write the postage stamps array 
         * fits_create_file(&tfptr, stampname, &status); 
         * fits_create_img(tfptr, bitpix, anaxis, anaxes, &status);
         * if (status) {
         * printf(" error writing postagestamp test pixel data %s \n",stampname);
         * fits_report_error(stderr, status); 
         * }
         * if (fits_write_pix(tfptr, TFLOAT, fpixel, testsize, mbulge, &status) )
         * {
         * printf(" error writing postagestamp test pixel data %s \n",stampname);
         * fits_report_error(stderr, status); 
         * }
         * fits_close_file(tfptr, &status);
         * if (status) {
         * printf(" error writing postagestamp test pixel data %s \n",stampname);
         * fits_report_error(stderr, status); 
         * }
         * }
         * pthread_mutex_unlock (&fitsfilelock);
         */

    } else {
        for(y = 0; y < mheight; y++) {
            for(x = 0; x < mwidth; x++) {
                yx = y * mwidth + x;
                bulge[nt][yx] = 0.;
                disk[nt][yx] = 0.;
            }
        }
        bulge[nt][0] = 1.;
    }

    /*
     * normalise 
     */
    /*
     * the total counts on the final postage stamp should be unity for
     * all models.  However because of pixelisation effects there is
     * some size-dependent variation at the level of 5 percent.  The
     * disk model typically is 7 percent too bright, so correct that here.
     * For accurate flux measurements the flux should be measured
     * from the actual final pixelised model, not assumed to be unity 
     * 
     * if (Ro > 0.)
     * {
     * bulgenorm = (22.66*bulgeRo*bulgeRo);
     * disknorm = (2.*pi*diskRo*diskRo);
     * for (y=0; y<mheight; y++)
     * {
     * for (x=0; x<mwidth; x++)
     * {
     * yx = y*mwidth + x;
     * {
     * bulge[nt][yx] = bulge[nt][yx]/bulgenorm;
     * disk[nt][yx] = disk[nt][yx]/disknorm;
     * }
     * }
     * }
     * }
     */

/* FT the disk and bulge components*/
    for (mt=0; mt<2; mt++)
      {
	// fft real-space model (disk or bulge) into FT domain 
	// bulge or disk -> AA
	// in this version, mt=0 is the disk model, mt=1 is the bulge (or star) model 
	fftw_execute(pmodel[nt][mt]);
	if (Ro>0. && creal(AA[nt][mt][0])<=0.)
	  {
	    fflush(stdout);
	    fprintf(stderr," error, FT of model %d is zero \n",mt);
	    exit(EXIT_FAILURE);
	  }
      }

/* create final model Fourier components */
    if (MODEL_OVERSAMPLING == 1)
      {
	// make a Moffat PSF, with parameter "a" scaled to second moment of true PSF
	// allowing for the oversampling
	for (y=0; y<mheight; y++)
	  {
	    yy = y<mheight/2 ? y : y-mheight;
	    for (x=0; x<mwidth; x++)
	      {
		xx = x<mwidth/2 ? x : x-mwidth;
		ipixel = x + y*mwidth;
		star[nt][ipixel] = 
		  (moffatbeta-1.)*pow( (1. + (double)(xx*xx+yy*yy)/mm[0]/(double)(msf*msf)), -moffatbeta )
		  /(pi*mm[0]*msf*msf);
	      }
	  }
	// FFT the Moffat psf and put it into array starA
	fftw_execute(moffatpsf[nt]);
	if (creal(starA[nt][0])<=0.)
	  {
	    fflush(stdout);
	    fprintf(stderr," error making FT of pseudo-star \n");
	    exit(EXIT_FAILURE);
	  }
	// initialise the downsampled star array		
	for(opixel = 0; opixel < pwidth * pheight; opixel++)
	  stardmodel[nt][opixel] = 0.;
	// downsample the star array
	for(y = 0; y < mheight; y++) 
	  {
	    // work out downsampled pixel
	    if (y<mheight/2)
	      {
		iy = (y + msf/2)/msf;
	      }
	    else
	      {
		iy = (mheight - y + msf/2)/msf;
		iy = -iy;
	      }
	    // check the new array element lies inside pheight
	    yy = iy + pheight/2;
	    if (yy >= 0 && yy < pheight)
	      {
		// shift the negative quadrant up to the top
		if (iy < 0) iy += pheight;
		// now the x-coordinate
		for(x = 0; x < mwidth; x++) 
		  {
		    if (x<mwidth/2)
		      {
			ix = (x + msf/2)/msf;
		      }
		    else
		      {
			ix = (mwidth - x +msf/2)/msf;
			ix = -ix;
		      }
		    xx = ix + pwidth/2;
		    if (xx >=0 && xx < pwidth)
		      {
			if (ix < 0) ix += pwidth;
			// aggregate the high-res pixels into the downsampled ones
			opixel = ix + iy * pwidth;
			ipixel = x + y * mwidth;
			stardmodel[nt][opixel] += star[nt][ipixel]/(msf*msf);
		      }
		  }
	      }
	  }
	// fft this small array back to fourier space into dstarA complex array
	fftw_execute(starsmodel[nt]);
	if (creal(dstarA[nt][0])<=0.)
	  {
	    fflush(stdout);
	    fprintf(stderr," error making downsampled pseudo-star model \n");
	    exit(EXIT_FAILURE);
	  }

		// apply to each of disk and bulge models
		for(mt = 0; mt < 2; mt++) 
		  {
		    /*
		     * now create models at data sampling by smoothing and downsampling.
		     * the data will also be smoothed equivalently (although because of
		     * aliasing it is not possible for this process to be exact) 
		     */
		    
		    /* If the model is higher resolution than the data, 
		       convolve with a pseudo-PSF of FWHM the same as the data, and downsample.
		       For speed this is done using Fourier smoothing.  The model
		       arrays should have been made large enough to avoid wrap-around effects.
		       After creating the FT of the models, remove the effect of the
		       pseudo-PSF on the observed pixel scale */
		    if (Ro>0. && creal(AA[nt][mt][0])<=0.)
		      {
			fflush(stdout);
			fprintf(stderr," error, FT of model %d is zero \n",mt);
			exit(EXIT_FAILURE);
		      }
		    for (y = 0; y < mheight; y++) 
		      {
			for(x = 0; x < halfmwidth; x++) 
			  {
			    yx = x + y * halfmwidth;
			    A[nt][yx] = AA[nt][mt][yx]*starA[nt][yx]/mfsize;
			  }
		      }
		    if (Ro>0. && creal(A[nt][0])<=0.)
		      {
			fflush(stdout);
			fprintf(stderr," error making FT of model convolved with pseudo-star \n");
			exit(EXIT_FAILURE);
		      }
		    // put smoothed model back into a real array, re-use "disk"
		    // A -> disk (same for disk or bulge, doesn't matter now)
		    fftw_execute(fmodel[nt]);
		    // downsample in real space
		    for(opixel = 0; opixel < pwidth * pheight; opixel++)
		      dmodel[nt][opixel] = 0.;
		    for(y = 0; y < mheight; y++) 
		      {
			// work out downsampled pixel
			if (y<mheight/2)
			  {
			    iy = (y + msf/2)/msf;
			  }
			else
			  {
			    iy = (mheight - y + msf/2)/msf;
			    iy = -iy;
			  }
			// check the new array element lies inside pheight
			yy = iy + pheight/2;
			if (yy >= 0 && yy < pheight)
			  {
			    // shift the negative quadrant up to the top
			    if (iy < 0) iy += pheight;
			    // now the x-coordinate
			    for(x = 0; x < mwidth; x++) 
			      {
				if (x<mwidth/2)
				  {
				    ix = (x + msf/2)/msf;
				  }
				else
				  {
				    ix = (mwidth - x +msf/2)/msf;
				    ix = -ix;
				  }
				xx = ix + pwidth/2;
				if (xx >=0 && xx < pwidth)
				  {
				    if (ix < 0) ix += pwidth;
				    // aggregate the high-res pixels into the downsampled ones
				    opixel = ix + iy * pwidth;
				    ipixel = x + y * mwidth;
				    dmodel[nt][opixel] += disk[nt][ipixel]/(msf*msf);
				  }
			      }
			  }
		      }
		    // fft this small array back to fourier space
		    // dmodel -> A (uses only part of this array)
		    fftw_execute(smodel[nt]);
		    // renormalise and write real part into modelft
		    nfactor = 1.;
		    if (creal(A[nt][0]) > 0. && creal(dstarA[nt][0])>0.)
		      nfactor = creal(A[nt][0])/creal(dstarA[nt][0]);
		    // deconvolve by the downsampled star model 
		    for (y=0; y<pheight; y++)
		      {
			for (x=0; x<halfpwidth; x++)
			  {
			    i = y*halfpwidth + x;
			    if (cabs(dstarA[nt][i]) != 0.)
			      {
				modelft[mt][i] += creal(A[nt][i]/dstarA[nt][i])/nfactor;
			      }
			    else
			      {
				fflush(stdout);
				fprintf(stderr," starA[%d]=%f \n",i,creal(dstarA[nt][i]));
				exit(EXIT_FAILURE);
			      }
			  }
		      }
		    // renormalise after the above aggregation 
		    nfactor = modelft[mt][0];
		    // if star model then one component will be zero, so check we dont bomb out
		    if (Ro==0. && nfactor<=0.)
		      nfactor = 1.;
		    // now we should be able to divide by nfactor in all cases, check
		    if (nfactor<=0.)
		      {
			fflush(stdout);
			fprintf(stderr," error renormalising models \n");
			fprintf(stderr," mt %d, A %f %f , dstarA %f %f , modelft %f \n", mt,
				creal(A[nt][0]),cimag(A[nt][0]),creal(dstarA[nt][0]),cimag(dstarA[nt][0]),modelft[mt][0]);
			exit(EXIT_FAILURE);
		      }
		    for (y=0; y<pheight; y++)
		      {
			for (x=0; x<halfpwidth; x++)
			  {
			    i = y*halfpwidth + x;
			    modelft[mt][i] /= nfactor;
			  }
		      }
		    // next model, bulge or disk
		  }
      }
    else 
      {
	// no model oversampling
	for(mt = 0; mt < 2; mt++) 
	  {
            // no oversampling
            // renormalise and write real part into modelft
            nfactor = 1.;
            if (creal(AA[nt][mt][0]) > 0. && Ro > 0.)
	      nfactor = creal(AA[nt][mt][0]);
	    for (y=0; y<pheight; y++)
	      {
		for (x=0; x<halfpwidth; x++)
		  {
		    i = y*halfpwidth + x;
		    modelft[mt][i] = creal(AA[nt][mt][i])/nfactor;
		  }
	      }
	  }
      }

}

/* integration kernel used within likelihood function for integrating posterior */
double
marflux (double x, void *params)
{
    int nt = *(int *) params;   // calling thread number
    // interpolate posterior
    double yval;
    int gsl_status = gsl_spline_eval_e(fspline[nt], x, facc[nt], &yval);
    if (gsl_status) yval = 0.;
    return yval;
}


/* integration kernel used by marginalisation step for integrating posterior */
double
marf(double x, void *params)
{
    int nt = *(int *) params;   // calling thread number
    // interpolate log(posterior)
    double yval;
    int gsl_status = gsl_spline_eval_e(fspline[nt], x, facc[nt], &yval);
    if (gsl_status)
        yval = 0.;
    else
        // return exponentiated function
        yval = exp(yval);
    return yval;
}


/* integration kernel used by marginalisation step for marginalising r values */
double
marr(double x, void *params)
{
    int nt = *(int *) params;   // calling thread number
    // interpolate log(posterior)
    double yval;
    int gsl_status = gsl_spline_eval_e(fspline[nt], x, facc[nt], &yval);
    if (gsl_status) {
        yval = 0.;
        return yval;
    }
    // exponentiate to get posterior
    yval = exp(yval);
    // return kernel value
    return yval * x;
}



void *ellipticity_lookup(void *threadargs)
{
  int ne, nt;
  double cosi, modele[2];

  /* extract object and thread number from argument */
  struct threadindex *this_thread;
  this_thread = (struct threadindex *)threadargs;
  ne = this_thread->objectnum;
  nt = this_thread->threadnum;

  cosi = 1. - (double)ne/(double)(numlookup-1);
  /* this function returns ellipticity for inclined disk and bulge components and stores
     them in modelelookup.  actually because the bulge ellipticity-inclination relation
     is analytic, the bulge part of the lookup table is never used */
  galaxy_ellipticity (nt, cosi, modele);
  // printf (" lookup %d %f %f %f \n",ne,cosi,modelelookup[ne][0],modelelookup[ne][1]); fflush(stdout);

  mu_array[ne] = cosi;
  modelelookup[0][ne] = modele[0];
  modelelookup[1][ne] = modele[1];

  pthread_exit((void*) 0);
      
}

/* 3D disk galaxy model based on simple model of
   van der Kruit and Searle (1981).  */
struct parameters 
{
  double scalelength; 
  double scaleheight;
  double cost;
  double u;
  double v;
};

/* integration kernel used by make3Dgalaxy model and galaxy_ellipticity */
double f (double x, void * params) {
  struct parameters *parvals;
  parvals = (struct parameters *)params;
  double scalelength = parvals->scalelength;
  double scaleheight = parvals->scaleheight; 
  double cost = parvals->cost;
  double u = parvals->u;
  double v = parvals->v; 
  // work out 3D coordinate within galaxy given the current viewing angle and position
  double sint = sqrt(1.-cost*cost);
  double zd = x*cost + v*sint;
  double yd = x*sint - v*cost;
  double r = sqrt(u*u + yd*yd);
  // return local disk emissivity for sech^2 profile
  double ze = exp(zd/scaleheight);
  double sechz = 2.*ze/(1.+ze*ze);
  double f = exp(-r/scalelength)*sechz*sechz;
  // or return exponential disk emissivity
  // double f = exp(-r/scalelength - fabs(zd)/scaleheight);
  return f;
}

void make3Dgalaxymodel (int nt, float **ft, double e1, double e2, double Ro)
{
  int i, mt, x, y, yp, y0, xp, xx, yx, yxp;
  int ix,iy,yy,pheight,opixel,ipixel;
  int msf;
  double galaxyextent, psfextent;
  double r, sb, etasq, expfactor, ScaledRo, bulgeRo;
  double diskRo, kappa;
  double eta, betaobs, asq, bsq;
  double mflux, bflux, rmax;
  double nfactor;
  double pval, wbulge, C, dflux;
  double xd, yd, arg, xmin, xmax, result, error;
  double cosi, sini, cosangle, sinangle, iangle;
  gsl_function F;
  int gsl_status;
  struct parameters parvals;

  // gsl integration kernel function
  F.function = &f;
  F.params = &parvals;

  /* make a 3D galaxy model and calculate its projected surface brightness */

  /* the model is created on a finer grid than the actual data
     in an attempt to reduce problems caused by
     having an undersampled model galaxy with a sharp central
     cusp.  For the problemtic r=0 point in a de Vaucouleurs profile,
     the value is replaced by that needed to ensure the total flux
     within the half-light radius comes out correct. So the model
     is initially created with a larger size, mheight*mwidth, the
     model is Fourier transformed, and the high spatial frequencies
     are then removed.  Because the model is a real, even function
     its Fourier transform is also real and even, so we only need
     store the real component, and we only need store half the array */

  /* this version fits bulge+disk profile assuming a fixed size ratio*/

  /* assume the input e1,e2 values yield the following orientation parameters:

     orientation angle theta anticlockwise from EW given by tan(2.theta) = e2/e1
     inclination angle i given by cos(i) = 1.-sqrt(e1^2 + e2^2)

     i.e. e1, e2 are NOT the usual lensing ellipticity parameters!

  */

  if (beta0<=0.)
    {
      fflush(stdout);
      fprintf (stderr," error, minimum bulge axial ratio <=0 \n");
      exit(EXIT_FAILURE);
    }

  etasq = e1*e1 + e2*e2;

  if (etasq > 1.) etasq = 1.;

  if (etasq>0.) 
    {
      // ellipticity modulus
      eta = sqrt(etasq);
      
      if (MODELS_3D==1)
	{
	  // interpolate relationship between ellipticity and inclination
	  // make sure request ellipticity does not exceed maximum calculated in table
	  if (eta>modelelookup[0][numlookup-1]) eta=modelelookup[0][numlookup-1];
	  // use lookup table to find cosine disk inclination for this ellipticity
	  gsl_status = gsl_spline_eval_e(rspline,eta,racc,&cosi);
	  if (gsl_status)
	    {
	      fflush(stdout);
	      fprintf(stderr," error gsl_spline_eval rspline at eta = %f\n",eta);
	      fprintf(stderr," %s \n",gsl_strerror(gsl_status));
	      exit(EXIT_FAILURE);
	    }
	  // sin inclination angle
	  sini=0.;
	  if (cosi<1.)
	    {
	      sini = sqrt(1.-cosi*cosi);
	    }
	}
      else
	{
	  // assume thin disk relation between inclination and ellipticity
	  if (eta>0.)
	    {
	      cosi = (1.-eta)/(1.+eta);
	      sini = 2*sqrt(eta)/(1.+eta);
	    }
	  else
	    {
	      sini = 0.;
	      cosi = 1.;
	    }
	}

      // either calculate apparent axis ratio for oblate ellipsoid model at this inclination
      betaobs = sqrt(cosi*cosi + beta0*beta0*sini*sini);      
      // or assume bulge ellipticity same as disk
      // betaobs = (1.-eta)/(1.+eta);
      
      // orientation on sky
      iangle = atan2(e2,e1)/2.;  
      cosangle = cos(iangle);
      sinangle = sin(iangle);
    }
  else
    {
      // set defaults for face-on system
      eta = etasq = 0.;
      cosi = 1.;
      sini = 0.;
      betaobs = 1.;
      iangle = 0.;
      cosangle = 1.;
      sinangle = 0.;
    }

  // set some scalings
  pheight = 2*halfpheight;

  // find the scale factor needed to fit this galaxy into the model array
  galaxyextent = Ro*Rcutoff*4;
  // find also some maximum scalefactor before the PSF overfills the array
  // psfextent = 1.13*sqrt(mm[0])*8;
  psfextent = 0.870*sqrt(mm[0])*8;
  if (psfextent > galaxyextent) galaxyextent = psfextent;
  if (Ro > 0.)
    {
      if (galaxyextent>0.)
	{
	  msf = 1 + 2 * ((int)(mwidth/galaxyextent)/2);      // must be an odd integer multiplier
	}
      else
	{
	  fflush(stdout);
	  fprintf(stderr," error, galaxyextent %f \n",galaxyextent);
	  exit(EXIT_FAILURE);
	}
    }
  else
    {
      // star model
      msf = mheight/pheight;
    }

  if (MODEL_OVERSAMPLING == 0) msf=1;

  /*
    printf(" thread %d 3D model: %f %f %f %f %f %d \n",nt,Ro,e1,e2,eta,cosi,msf);
    fflush(stdout);
  */

  // scale the galaxy accordingly
  ScaledRo = Ro*msf;

  /* the model/data oversampling factor must be an odd integer to preserve symmetry */
  if ( msf-2*(msf/2) != 1 )
    {
      fflush(stdout);
      fprintf(stderr," error: 3D model oversampling factor %d must be an odd integer \n",msf);
      fprintf(stderr," galaxy extent = %f \n",galaxyextent);
      fprintf(stderr," model array size = %d \n",mwidth);
      exit(EXIT_FAILURE);
    }

  /* scale the bulge half-light radius by some constant factor 
     relative the disk scalelength */
  diskRo = ScaledRo;
  bulgeRo = ScaledRo*bscalefactor;

  /* now create the galaxy models */

       C = 7.67; // de Vauc factor

       if (ScaledRo > 0.)
	 {
	   /* initialise */
	   bflux = 0.;
	   dflux = 0.;
	   for (y=0; y<mheight; y++)
	     {
	       for (x=0; x<mwidth; x++)
		 {
		   yx = y*mwidth+x;
		   disk[nt][yx]=bulge[nt][yx]=0.;
		 }
	     }
	   /* start with bulge component */

	   /* set some lengths */
	   asq = bulgeRo*bulgeRo;
	   bsq = asq*betaobs*betaobs;
	   // maximum radius of model postage stamp in scalelengths
	   rmax = (double)mwidth/2./bulgeRo;
	   /* set the maximum cutoff radius to Rcutoff scalelengths */
	   if (rmax>Rcutoff) rmax=Rcutoff;

	   for (y=1; y<mheight; y++)
	     {
	       yp = mheight-y;
	       y0 = y>mheight/2 ? -yp : y;
	       for (x=1; x<(1+mwidth/2); x++)
		 {
		   // calculate the two conjugate pixel numbers
		   xp = mwidth-x;
		   yx = y*mwidth + x;
		   yxp = yp*mwidth + xp;
		   // rotate coordinates to a frame where major axis is along x-axis
		   xd = (double)x*cosangle + (double)y0*sinangle;
		   yd = -(double)x*sinangle + (double)y0*cosangle;
		   // calculate the radius in scaled units
		   r = sqrt(xd*xd/asq + yd*yd/bsq);
		   if (r <= rmax)
		     {
		       expfactor = C*(pow(r,0.25)-1.);
		       sb = exp(-expfactor);
		       bulge[nt][yx] = sb;
		       bulge[nt][yxp] = sb;
		       bflux += bulge[nt][yx];
		       if (xp!=x) bflux+= bulge[nt][yxp];
		     }
		 }
	     }
	   y = 0;
	   yp = 0;
	   for (x=1; x<(1+mwidth/2); x++)
	     {
	       yx = y*mwidth + x;
	       xp = mwidth-x;
	       yxp = yp*mwidth + xp;
	       // rotate coordinates to a frame where major axis is along x-axis
	       xd = (double)x*cosangle + (double)y*sinangle;
	       yd = -(double)x*sinangle + (double)y*cosangle;
	       // calculate the radius in scaled units
	       r = sqrt(xd*xd/asq + yd*yd/bsq);
	       if (r <= rmax)
		 {
		   expfactor = C*(pow(r,0.25)-1.);
		   sb = exp(-expfactor);
		   bulge[nt][yx] = sb;
		   bulge[nt][yxp] = sb;
		   bflux += bulge[nt][yx];
		   if (xp!=x) bflux+= bulge[nt][yxp];
		 }
	     }
	   x = 0;
	   for (y=0; y<mheight; y++)
	     {
	       yp = mheight-y;
	       y0 = y>mheight/2 ? -yp : y;
	       yx = y*mwidth + x;
	       // rotate coordinates to a frame where major axis is along x-axis
	       xd = (double)x*cosangle + (double)y0*sinangle;
	       yd = -(double)x*sinangle + (double)y0*cosangle;
	       // calculate the radius in scaled units
	       r = sqrt(xd*xd/asq + yd*yd/bsq);
	       if (r <= rmax)
		 {
		   expfactor = C*(pow(r,0.25)-1.);
		   sb = exp(-expfactor);
		   bulge[nt][yx] = sb;
		   if (y>0) bflux += bulge[nt][yx];
		 }
	     }
	   /* work out the central pixel flux required to match the integrated light */
	   pval = pow(rmax,0.25);
	   wbulge = ((6+pval*C*(6.+pval*C*(3.+C*pval)))/6.
		     +rmax*C*C*C*C*(210.+pval*C*(42.+pval*C*(7.+pval*C)))/5040.)*exp(-C*pval);
	   wbulge = 1.-wbulge;
	   mflux = 2.*pi*wbulge*bulgeRo*bulgeRo*betaobs*exp(C)*20160./pow(C,8.);
	   bulge[nt][0] = mflux - bflux;

	   // printf(" bulge %f %f %f %f %f %f \n",rmax,wbulge,mflux,bflux,bulge[nt][0],exp(C));

	   /* now create galaxy disk integrating through the van der Kruit & Searle model  */
	   // set some lengths
	   parvals.scalelength = diskRo;
	   parvals.scaleheight = diskRo/diskratio; // assume height is scalelength/diskratio
	   // set extinction term relative to size of the galaxy
	   kappa = kappaval/parvals.scaleheight;
	   // pass the cosine(inclination) to the function
	   parvals.cost = cosi;
	   // maximum radius of model postage stamp in model pixels (i.e. different from the bulge case)
	   rmax = Rcutoff*diskRo;
	   if (rmax > mwidth/2.) rmax = mwidth/2.;
	   // don't try to integrate over too big a range, approximate anything with sini<0.01 as pure face-on
	   if (sini > 0.01)
	     {
	       for (y=1; y<mheight; y++)
		 {
		   yp = mheight-y;
		   y0 = y>mheight/2 ? -yp : y;
		   for (x=1; x<(1+mwidth/2); x++)
		     {
		       // calculate the two conjugate pixel numbers
		       xp = mwidth-x;
		       yx = y*mwidth + x;
		       yxp = yp*mwidth + xp;
		       // rotate coordinates to a frame where major axis is along x-axis
		       xd = (double)x*cosangle + (double)y0*sinangle;
		       yd = -(double)x*sinangle + (double)y0*cosangle;
		       r = sqrt(xd*xd + yd*yd);
		       result = 0.;
		       if (r<=rmax)
			 {
			   parvals.v = yd;
			   parvals.u = xd;
			   arg = yd*sini*cosi*yd*sini*cosi - sini*sini*(xd*xd+yd*yd*cosi*cosi-rmax*rmax);
			   if (arg>0.)
			     {
			       xmin = (yd*sini*cosi-sqrt(arg))/(sini*sini);
			       xmax = (yd*sini*cosi+sqrt(arg))/(sini*sini);
			       if (xmin < -10*rmax) xmin = -10*rmax;
			       if (xmax >  10*rmax) xmax = 10*rmax;
			       gsl_status = gsl_integration_qag (&F, xmin, xmax, 0., 1.e-4, 
								 gsl_work_size, GSL_INTEG_GAUSS41,
								 gsl_work[nt], &result, &error);
			       if (gsl_status)
				 {
				   fflush(stdout);
				   fprintf(stderr," error gsl_integration_qag in make3Dgalaxymodel \n");
				   fprintf(stderr," %s \n",gsl_strerror(gsl_status));
				   exit(EXIT_FAILURE);
				 }
			       // apply extinction with coefficient kappa
			       if (kappa>0.)
				 result = (1.-exp(-kappa*result))/kappa;
			     }
			   disk[nt][yx] = result;
			   disk[nt][yxp] = result;
			 }
		     }
		 }
	       y = 0;
	       yp = 0;
	       for (x=1; x<(1+mwidth/2); x++)
		 {
		   yx = y*mwidth + x;
		   xp = mwidth-x;
		   yxp = yp*mwidth + xp;
		   // rotate coordinates to a frame where major axis is along x-axis
		   xd = (double)x*cosangle + (double)y*sinangle;
		   yd = -(double)x*sinangle + (double)y*cosangle;
		   r = sqrt(xd*xd + yd*yd);
		   result=0.;
		   if (r<=rmax)
		     {
		       parvals.v = yd;
		       parvals.u = xd;
		       arg = yd*sini*cosi*yd*sini*cosi - sini*sini*(xd*xd+yd*yd*cosi*cosi-rmax*rmax);
		       if (arg>0.)
			 {
			   xmin = (yd*sini*cosi-sqrt(arg))/(sini*sini);
			   xmax = (yd*sini*cosi+sqrt(arg))/(sini*sini);	  
			   if (xmin < -10*rmax) xmin = -10*rmax;
			   if (xmax >  10*rmax) xmax = 10*rmax;
			   gsl_status = gsl_integration_qag (&F, xmin, xmax, 0, 1e-4, 
							     gsl_work_size, GSL_INTEG_GAUSS41,
							     gsl_work[nt], &result, &error);
			   if (gsl_status)
			     {
			       fflush(stdout);
			       fprintf(stderr," error gsl_integration_qag in make3Dgalaxymodel \n");
			       fprintf(stderr," %s \n",gsl_strerror(gsl_status));
			       exit(EXIT_FAILURE);
			     }
			   // apply extinction with coefficient kappa
			   if (kappa>0.)
			     result = (1.-exp(-kappa*result))/kappa;
			 }
		       disk[nt][yx] = result;
		       disk[nt][yxp] = result;
		     }
		 }
	       x = 0;
	       for (y=0; y<mheight; y++)
		 {
		   yp = mheight-y;
		   y0 = y>mheight/2 ? -yp : y;
		   yx = y*mwidth + x;
		   // rotate coordinates to a frame where major axis is along x-axis
		   xd = (double)x*cosangle + (double)y0*sinangle;
		   yd = -(double)x*sinangle + (double)y0*cosangle;
		   r = sqrt(xd*xd + yd*yd);
		   result = 0.;
		   if (r<=rmax)
		     {
		       parvals.v = yd;
		       parvals.u = xd;
		       arg = yd*sini*cosi*yd*sini*cosi - sini*sini*(xd*xd+yd*yd*cosi*cosi-rmax*rmax);
		       if (arg>0.)
			 {
			   xmin = (yd*sini*cosi-sqrt(arg))/(sini*sini);
			   xmax = (yd*sini*cosi+sqrt(arg))/(sini*sini);	  
			   if (xmin < -10*rmax) xmin = -10*rmax;
			   if (xmax >  10*rmax) xmax = 10*rmax;
			   gsl_status = gsl_integration_qag (&F, xmin, xmax, 0, 1e-4, 
							     gsl_work_size, GSL_INTEG_GAUSS41,
							     gsl_work[nt], &result, &error);
			   if (gsl_status)
			     {
			       fflush(stdout);
			       fprintf(stderr," error gsl_integration_qag in make3Dgalaxymodel \n");
			       fprintf(stderr," %s \n",gsl_strerror(gsl_status));
			       exit(EXIT_FAILURE);
			     }
			   // apply extinction with coefficient kappa
			   if (kappa>0.)
			     result = (1.-exp(-kappa*result))/kappa;
			 }
		       disk[nt][yx] = result;
		     }
		 }
	     }
	   else
	     {
	       // face-on galaxy
	       for (y=1; y<mheight; y++)
		 {
		   yp = mheight-y;
		   y0 = y>mheight/2 ? -yp : y;
		   for (x=1; x<(1+mwidth/2); x++)
		     {
		       // calculate the two conjugate pixel numbers
		       xp = mwidth-x;
		       yx = y*mwidth + x;
		       yxp = yp*mwidth + xp;
		       r = sqrt((double)(x*x) + (double)(y0*y0));
		       if (r <= rmax)
			 {
			   result = 2.*parvals.scaleheight*exp(-r/diskRo);
			   // apply extinction with coefficient kappa
			   if (kappa>0.)
			     result = (1.-exp(-kappa*result))/kappa;
			   disk[nt][yx] = result;
			   disk[nt][yxp] = result;
			 }
		     }
		 }
	       y = 0;
	       yp = 0;
	       for (x=1; x<(1+mwidth/2); x++)
		 {
		   yx = y*mwidth + x;
		   xp = mwidth-x;
		   yxp = yp*mwidth + xp;
		   r = sqrt((double)(x*x) + (double)(y*y));
		   if (r <= rmax)
		     {
		       result = 2.*parvals.scaleheight*exp(-r/diskRo);
		       // apply extinction with coefficient kappa
		       if (kappa>0.)
			 result = (1.-exp(-kappa*result))/kappa;
		       disk[nt][yx] = result;
		       disk[nt][yxp] = result;
		     }
		 }
	       x = 0;
	       for (y=0; y<mheight; y++)
		 {
		   yp = mheight-y;
		   y0 = y>mheight/2 ? -yp : y;
		   yx = y*mwidth + x;
		   r = sqrt((double)(x*x) + (double)(y0*y0));
		   if (r <= rmax)
		     {
		       disk[nt][yx] = 2.*parvals.scaleheight*exp(-r/diskRo);
		     }
		 }
	     }

	   
	   /*
	     psfellipticitycentroid(bulge,mheight,mwidth,psfe,centroid);
	     printf("bulge %f %f %f %f %f %f %f %f %f %f %f\n",bulgeRo,e1,e2,e1t,e2t,mflux,bflux,bulge[nt][0],bulge[nt][1],psfe[0],psfe[1]);
	     
	     psfellipticitycentroid(disk,mheight,mwidth,psfe,centroid);
	     printf("disk  %f %f %f %f %f %f %f %f %f %f %f\n",diskRo,e1,e2,e1t,e2t,mflux,dflux,disk[nt][0],disk[nt][1],psfe[0],psfe[1]);
	   */

	   /* uncomment the following part to write out fits images of the models 

	      float *mbulge;
	      int testsize=mwidth*mheight*2;
	      mbulge = (float*)calloc(testsize, sizeof(float));
	      int anaxis=3;
	      long fpixel[3]={1,1,1}, lrow;
	      long anaxes[3]; 
	      anaxes[0]=mwidth;
	      anaxes[1]=mheight;
	      anaxes[2]=2;
	      int bitpix=-32;
	      fitsfile *tfptr;
	      int status=0;
	      char stampname[300];

	   // swap!!!
	   for (iy=0; iy<mheight; iy++)
	     {
	       yy=iy+mheight/2;
	       if (yy>=mheight)yy-=mheight;
	       {
		 for (ix=0; ix<mwidth; ix++)
		   {
		     xx=ix+mwidth/2;
		     if (xx>=mwidth)xx-=mwidth;
		     {
		       j=xx+yy*mwidth;
		       i=ix+iy*mwidth;
		       mbulge[j]=bulge[nt][i];
		       mbulge[j+mwidth*mheight]=disk[nt][i]; 
		     }
		   }
	       }
	     }

	     // create a unique filename for the postage stamps 
	     pthread_mutex_lock (&fitsfilelock);
	     strcpy(stampname,"rawmodel.1.fits");
	     i=0;
	     // if this file already exists make a new name
	     while (access(stampname,F_OK) == 0)
	     {
	     i++;
	     bzero(stampname,300);
	     sprintf(stampname, "rawmodel.%d.fits", i);
	     }
	     if (i<1000)
	     {
	       // printf(" writing mean postage stamps to file %s \n",stampname); fflush(stdout);
	     // create the file and write the postage stamps array 
	     fits_create_file(&tfptr, stampname, &status); 
	     fits_create_img(tfptr, bitpix, anaxis, anaxes, &status);
	     if (status) {
	     printf(" error writing postagestamp test pixel data %s \n",stampname);
	     fits_report_error(stderr, status); 
	     }
	     if (fits_write_pix(tfptr, TFLOAT, fpixel, testsize, mbulge, &status) )
	     {
	     printf(" error writing postagestamp test pixel data %s \n",stampname);
	     fits_report_error(stderr, status); 
	     }
	     fits_close_file(tfptr, &status);
	     if (status) {
	     printf(" error writing postagestamp test pixel data %s \n",stampname);
	     fits_report_error(stderr, status); 
	     }
	     }
	     pthread_mutex_unlock (&fitsfilelock);

	     free(mbulge);
	   */
	   
	 }
       else
	 {
	   // star model, zero scalelength, write delta function into "bulge"
           for (y=0; y<mheight; y++)
             {
	       for (x=0; x<mwidth; x++)
		 {
		   yx = y*mwidth + x;
		   bulge[nt][yx] = 0.;
		   disk[nt][yx]=0.;
		 }
             }
	   bulge[nt][0] = 1.;
	 }

    if (MODEL_OVERSAMPLING == 1)
      {
	// make a Moffat PSF, with parameter "a" scaled to second moment of true PSF
	// allowing for the oversampling
	for (y=0; y<mheight; y++)
	  {
	    yy = y<mheight/2 ? y : y-mheight;
	    for (x=0; x<mwidth; x++)
	      {
		xx = x<mwidth/2 ? x : x-mwidth;
		ipixel = x + y*mwidth;
		star[nt][ipixel] = 
		  (moffatbeta-1.)*pow( (1. + (double)(xx*xx+yy*yy)/mm[0]/(double)(msf*msf)), -moffatbeta )
		  /(pi*mm[0]*msf*msf);
	      }
	  }
	// FFT the Moffat psf and put it into array starA
	fftw_execute(moffatpsf[nt]);
      }


/* Create the FT of the disk (mt=0) and bulge or star (mt=1) components.  There are two
   ways of doing this, depending on the value of msf, the oversampling factor.  For oversampled
   models, they are fourier transformed into an array of the same size (i.e. oversampled),
   which are multiplied by the FT of the nominal PSF, transformed back, downsampled by averaging
   in real-space.  The idea is to mimic as closely as possible the real process that happened
   to the data.  However, in the likelihood function the model FTs are multiplied by the actual
   PSF FT, and also we want a delta function to come out the same as the PSF after this process,
   so we divide by the FT of a delta-function that has been downsampled in the same way, thus
   accounting exactly for the sampling effects that exist for a star.  This cannot be exactly
   correct for an extended object, but hopefully should be close.
   
   In the case of no oversampling, none of the above applies, but the problem then is that
   surface brightness distribution of the models is not correct (and in the case of the disk
   is not guaranteed to conserve flux even).
*/

       for (mt=0; mt<2; mt++)
	 {

	   // fft real-space model (disk or bulge) into FT domain 
	   // bulge or disk -> A
	   // in this version, mt=0 is the disk model, mt=1 is the bulge (or star) model 

	   fftw_execute(pmodel[nt][mt]);
	   
	   if (MODEL_OVERSAMPLING == 1)
	     {
	       /* If the model is higher resolution than the data, 
		  convolve with a pseudo-PSF of FWHM the same as the data, and downsample.
		  For speed this is done using Fourier smoothing.  The model
		  arrays should have been made large enough to avoid wrap-around effects.
		  After creating the FT of the models, remove the effect of the
		  pseudo-PSF on the observed pixel scale */
	       
	       for (y=0; y<mheight; y++)
		 {
		   for (x=0; x<halfmwidth; x++)
		     {
		       yx = x + y*halfmwidth;
		       A[nt][yx] = AA[nt][mt][yx] * creal(starA[nt][yx])/mfsize;
		     }
		 }
	       
	       // put smoothed model back into original array
	       // A -> disk (same for disk or bulge, doesnt matter now, as disk comes first)
	       fftw_execute(fmodel[nt]);
	       // downsample in real space
	       // initialise downsampled model array
	       for (opixel=0; opixel<pwidth*pheight; opixel++) 
		 {
		   dmodel[nt][opixel]=stardmodel[nt][opixel]=0.;
		 }
            for(y = 0; y < mheight; y++) 
	      {
		// work out downsampled pixel
		if (y<mheight/2)
		  {
		    iy = (y + msf/2)/msf;
		  }
		else
		  {
		    iy = (mheight - y + msf/2)/msf;
		    iy = -iy;
		  }
		// check the new array element lies inside pheight
		yy = iy + pheight/2;
		if (yy >= 0 && yy < pheight)
		  {
		    // shift the negative quadrant up to the top
		    if (iy < 0) iy += pheight;
		    // now the x-coordinate
		    for(x = 0; x < mwidth; x++) 
		      {
			if (x<mwidth/2)
			  {
			    ix = (x + msf/2)/msf;
			  }
			else
			  {
			    ix = (mwidth - x +msf/2)/msf;
			    ix = -ix;
			  }
			xx = ix + pwidth/2;
			if (xx >=0 && xx < pwidth)
			  {
			    if (ix < 0) ix += pwidth;
			    // aggregate the high-res pixels into the downsampled ones
			    opixel = ix + iy * pwidth;
			    ipixel = x + y * mwidth;
			    dmodel[nt][opixel] += disk[nt][ipixel]/(msf*msf);
			    if (mt==0) stardmodel[nt][opixel] += star[nt][ipixel]/(msf*msf);
			  }
		      }
		  }
	      }
	     
	   /* uncomment the following part to write out fits images of the models 

	      float *mbulge;
	      int testsize=pwidth*pheight;
	      mbulge = (float*)calloc(testsize, sizeof(float));
	      int anaxis=2;
	      long fpixel[2]={1,1}, lrow;
	      long anaxes[2]; 
	      anaxes[0]=pwidth;
	      anaxes[1]=pheight;
	      int bitpix=-32;
	      fitsfile *tfptr;
	      int status=0;
	      char stampname[300];


	   // swap!!!
	   for (iy=0; iy<pheight; iy++)
	     {
	       yy=iy+pheight/2;
	       if (yy>=pheight)yy-=pheight;
	       {
		 for (ix=0; ix<pwidth; ix++)
		   {
		     xx=ix+pwidth/2;
		     if (xx>=pwidth)xx-=pwidth;
		     {
		       j=xx+yy*pwidth;
		       i=ix+iy*pwidth;
		       mbulge[j]=dmodel[nt][i];
		     }
		   }
	       }
	     }

	     // create a unique filename for the postage stamps 
	     pthread_mutex_lock (&fitsfilelock);
	     strcpy(stampname,"dsmodel.1.fits");
	     i=0;
	     // if this file already exists make a new name
	     while (access(stampname,F_OK) == 0)
	     {
	     i++;
	     bzero(stampname,300);
	     sprintf(stampname, "dsmodel.%d.fits", i);
	     }
	     if (i<1000)
	     {
	       // printf(" writing mean postage stamps to file %s \n",stampname); fflush(stdout);
	     // create the file and write the postage stamps array 
	     fits_create_file(&tfptr, stampname, &status); 
	     fits_create_img(tfptr, bitpix, anaxis, anaxes, &status);
	     if (status) {
	     printf(" error writing postagestamp test pixel data %s \n",stampname);
	     fits_report_error(stderr, status); 
	     }
	     if (fits_write_pix(tfptr, TFLOAT, fpixel, testsize, mbulge, &status) )
	     {
	     printf(" error writing postagestamp test pixel data %s \n",stampname);
	     fits_report_error(stderr, status); 
	     }
	     fits_close_file(tfptr, &status);
	     if (status) {
	     printf(" error writing postagestamp test pixel data %s \n",stampname);
	     fits_report_error(stderr, status); 
	     }
	     printf(" model image %f %f %f %d %d %f %s \n",Ro,e1,e2,mt,msf,dmodel[nt][0],stampname);
	     }
	     pthread_mutex_unlock (&fitsfilelock);

	     free(mbulge);
	   
	   end of section to write out fits images of models */

	       // fft this small array back to fourier space
	       // dmodel -> A (uses only part of this array)
	       fftw_execute(smodel[nt]);
	       // star FT into starA
	       if (mt==0)
		 fftw_execute(starsmodel[nt]);
	       /* renormalise to FT of delta function processed the same way, 
		  and write real part into modelft */
	       nfactor = 1.;
	       if (creal(A[nt][0]) > 0. && creal(dstarA[nt][0]) > 0.) 
		 nfactor = creal(A[nt][0])/creal(dstarA[nt][0]);
	       else
		 if (Ro>0. || mt==1)
		   printf(" normalisation error: %f %f \n",creal(A[nt][0]),creal(dstarA[nt][0]));
	       for (y=0; y<pheight; y++)
		 {
		   for (x=0; x<halfpwidth; x++)
		     {
		       i = y*halfpwidth + x;
		       if (creal(dstarA[nt][i]) != 0.)
			 {
			   ft[mt][i] = creal(A[nt][i])/nfactor/creal(dstarA[nt][i]);               
			 }
		       else
			 {
			   fflush(stdout);
			   fprintf(stderr," dstarA[%d]=%f \n",i,creal(dstarA[nt][i]));
			   exit(EXIT_FAILURE);
			 }
		     }
		 }
	     }
	   else
	     {
	       // no oversampling
	       // renormalise and write real part into modelft
	       nfactor = 1.;
	       if (creal(A[nt][0])>0. && Ro>0.) nfactor = creal(A[nt][0]);
	       for (y=0; y<pheight; y++)
		 {
		   for (x=0; x<halfpwidth; x++)
		     {
		       i = y*halfpwidth + x;
		       ft[mt][i] = creal(A[nt][i])/nfactor;               
		     }
		 }
	     }
	   // printf(" made model %f %f %f component %d %f \n",Ro,e1,e2,mt,ft[mt][0]);
	 }

}

void galaxy_ellipticity(int nt, double cost, double *modele)
{
  /* calculate model ellipticities only (dont generate models) */
  int x, y, mpwidth, mpheight;
  double result, error, rmax, beta, denom, kappa;
  double arg, xmin, xmax, u, v, sint;
  double Q_norm,Q11,Q22;
  gsl_function F;
  int gsl_status;
  struct parameters parvals;

  if (beta0<=0.) 
    {
      fprintf(stderr," error, bulge minimum axial ratio <=0 \n");
      exit(EXIT_FAILURE);
    }


  F.function = &f;
  F.params = &parvals;

  /* diskratio ratio of scalelength to scaleheight, and truncated disk at Rcutoff scalelengths */
  parvals.scaleheight = 4.; // make sure scaleheight is oversampled
  parvals.scalelength = diskratio*parvals.scaleheight;
  rmax = Rcutoff*parvals.scalelength;
  kappa = kappaval/parvals.scaleheight;

  /* set size of array making sure it's bigger than the galaxy */
  mpwidth = mpheight = (int)(2.1*rmax);

  // initialise 
  Q11=Q22=Q_norm=0.;
  modele[0]=modele[1]=0.;
  
  // integrate through 3D disk model if it is inclined
  if (cost<1.)
    {
      sint = sqrt(1.-cost*cost);
      if (sint<0.1)
	{
	  modele[0] = (1.-cost)/(1.+cost);
	}
      else
	{
	  parvals.cost=cost;
	  for (y=0; y<mpheight; y++)
	    {
	      parvals.v = v = y-mpheight/2;
	      for (x=0; x<mpwidth; x++)
		{
		  result = 0.;
		  parvals.u = u = x-mpwidth/2;
		  arg = v*sint*cost*v*sint*cost - sint*sint*(u*u+v*v*cost*cost-rmax*rmax);
		  if (arg>0. && u*u+v*v < rmax*rmax)
		    {
		      xmin = (v*sint*cost-sqrt(arg))/(sint*sint);
		      xmax = (v*sint*cost+sqrt(arg))/(sint*sint);	  
		      if (xmin < -10*rmax) xmin = -10*rmax;
		      if (xmax >  10*rmax) xmax = 10*rmax;
		      gsl_status = gsl_integration_qag (&F, xmin, xmax, 0, 1e-6, 
							gsl_work_size, GSL_INTEG_GAUSS41,
							gsl_work[nt], &result, &error);
		      if (gsl_status)
			{
			  fflush(stdout);
			  fprintf(stderr," error gsl_integration_qag in galaxy_ellipticity \n");
			  fprintf(stderr," %s \n",gsl_strerror(gsl_status));
			  exit(EXIT_FAILURE);
			}
		    }
		  // apply extinction with coefficient kappa
		  if (kappa>0.)
		    result = (1.-exp(-kappa*result))/kappa;
		  Q11 += result*u*u;
		  Q22 += result*v*v;
		  Q_norm += result;
		}
	    }
	  denom = Q11 + Q22 + 2.*sqrt(Q11*Q22);
	  modele[0] = (Q11-Q22)/denom;
	}

      // oblate ellipsoid model for bulges
      beta = sqrt(cost*cost + beta0*beta0*sint*sint);
      modele[1] = (1.-beta)/(1.+beta);

    }
}


void dilatemask(float *badpix, int *dim)
{
  int x, y, i, j;
  
  /* dilate the bad pixel mask by one pixel in all directions - takes care
     of inaccuracies in the bad pixel mask */
  for (y=0; y<dim[1]; y++)
    {
      for (x=1; x<dim[0]; x++)
	{
	  i = x + y*dim[0];
	  if (badpix[i]<=0.)
	    {
	      badpix[i-1]=0.;
	    }
	}
      for (x=dim[0]-2; x>=0; x--)
	{
	  i = x + y*dim[0];
	  if (badpix[i]<=0.)
	    {
	      badpix[i+1]=0.;
	    }
	}
    }
  for (x=0; y<dim[0]; x++)
    {
      for (y=1; y<dim[1]; y++)
	{
	  i = x + y*dim[0];
	  if (badpix[i]<=0.)
	    {
	      j = x + (y-1)*dim[0];
	      badpix[j]=0.;
	    }
	}
      for (y=dim[1]-2; y>=0; y--)
	{
	  i = x + y*dim[0];
	  if (badpix[i]<=0.)
	    {
	      j = x + (y+1)*dim[0];
	      badpix[j]=0.;
	    }
	}
    }

}




int expand_wanted(int nt, int sampling, int oldsampling)
{
  // function to take the initial array of "wanted" ellipticity samples
  // and expand around each point to make a new, higher-resolution, sampling
  // uses global arrays wanted[nt], new_wanted[nt] for thread nt
  int nlist, ne, ie1, ie2, iie1, iie2, ii, jj;

  nlist = 0;
  for(ne = 0; ne < nume; ne++)
    new_wanted[nt][ne] = 0;
               
  for(ie1 = -edim; ie1 <= edim; ie1++) {
    for(ie2 = -edim; ie2 <= edim; ie2++) {
      ne = elookup[edim + ie1][edim + ie2];
      if (ne >= 0) {
	if (wanted[nt][ne] == 1) {
	  for(iie1 = ie1 - oldsampling; iie1 <= ie1 + oldsampling; iie1 += sampling) {
	    for(iie2 = ie2 - oldsampling; iie2 <= ie2 + oldsampling; iie2 += sampling) {
	      ii = edim + iie1;
	      jj = edim + iie2;
	      if (ii >= 0 && ii < (1 + 2 * edim) && 
		  jj >= 0 && jj < (1 + 2 * edim)) {
		ne = elookup[ii][jj];
		if (ne >= 0) {
		  if (new_wanted[nt][ne]==0 && wanted[nt][ne]==0) nlist++;
		  new_wanted[nt][ne] = 1;
		}
	      }
	    }
	  }
	}
      }
    }
  }

  for(ne = 0; ne < nume; ne++)
    wanted[nt][ne] = new_wanted[nt][ne];

  return nlist;

}



int findmaxr (int Pselect, int nt, int nimcheck, int startnRo, int ne, int rstep, double *fvals)
{
  // estimate the position of the maximum posterior in r at a given ellipticity
  // If Pselect set to zero, will calculate posterior values,
  // if set to unity will calculate likelihood

  int nRo, modelnum, rfit_ok, increasing, foundmax;
  int maxpos, minuspos, pluspos;
  double posterior, maxposterior, pfactor;
  double xvals[3], yvals[3];
  double minval, maxval, xminval, xmaxval;

  if (Pselect==0) {
    pfactor = 1.; 
  }
  else {
    if (Pselect==1) {
      pfactor = 0.;
    }
    else {
      {
	fflush(stdout);
	fprintf(stderr," error in findmaxr, Pselect %d \n",Pselect);
	exit(EXIT_FAILURE);
      }
    }
  }

  // set default return value
  rfit_ok=2;
  // 0=success
  // 1=valid values found, but no quadratic fit
  // 2=no valid values found

  // measure the likelihood at the starting position
  nRo = startnRo;
  maxpos = -1;
  modelnum = nRo*nume + ne;
  maxposterior = posterior = NOT_MEASURED;
  if (likel[nt][modelnum] == NOT_MEASURED)
    {
      likel[nt][modelnum] =
	likelihood(nt, nimcheck, nRo, ne, modelft[modelnum][0], modelft[modelnum][1]);
      if (currentobject[nt]==printlikel)
	{
	  printf(" likel: %d %d %d %d %g \n",nimcheck, nRo, ne, modelnum, likel[nt][modelnum]);
	}
      /*printf(" likel: %d %d %d %d %g %g %g %g \n", nt, iobj,
	ne,nRo,Ro[nRo],likel[nt][modelnum],modelflux[nt][modelnum][0],modelflux[nt][modelnum][1]);*/
    }
  if (likel[nt][modelnum] > NOT_MEASURED)
    {
      posterior = likel[nt][modelnum] + rprior[nt][nRo] + pfactor*eprior[nt][ne];
      maxposterior = posterior;
      maxpos = nRo;
    }

  // now step to smaller r either until the new posterior is below the maximum found 
  // or the end of the array is reached
  foundmax = increasing = pluspos = minuspos = 0;
  while (nRo > 1 && foundmax==0)
    {
      nRo -= rstep;
      if (nRo < 1) nRo = 1;
      if (nRo > 0)
	{
	  modelnum = nRo*nume + ne;
	  if (likel[nt][modelnum] == NOT_MEASURED)
	    {
	      likel[nt][modelnum] =
		likelihood(nt, nimcheck, nRo, ne, modelft[modelnum][0], modelft[modelnum][1]);
	      if (currentobject[nt]==printlikel)
		{
		  printf(" likel: %d %d %d %d %g \n",nimcheck, nRo, ne, modelnum, likel[nt][modelnum]);
		}
	      /*printf(" likel: %d %d %d %d %g %g %g %g \n", nt, iobj,
		ne,nRo,Ro[nRo],likel[nt][modelnum],modelflux[nt][modelnum][0],modelflux[nt][modelnum][1]);*/
	    }
	  if (likel[nt][modelnum] > NOT_MEASURED)
	    {
	      posterior = likel[nt][modelnum] + rprior[nt][nRo] + pfactor*eprior[nt][ne];
	      // test and remember if the posterior is increasing at this step
	      if (posterior>maxposterior) 
		{
		  pluspos = maxpos;
		  maxpos = nRo;
		  maxposterior = posterior;
		  increasing = 1;
		}
	      // test if the posterior is decreasing (=maximum found)
	      if (posterior<maxposterior) 
		{
		  foundmax = 1;
		  minuspos=nRo;
		}
	    }
	}
    }
  //printf ("end of decreasing search: %d %d \n",increasing,foundmax);
  // if the increasing flag is set, then either a maximum has
  // been found, or the end of the valid values was exhausted
  // otherwise, step to larger r to search for the maximum
  if (increasing==0)
    {
      nRo = startnRo;
      // if previously a decreasing posterior was found, from this
      // direction this is an increasing posterior, reset flag accordingly
      if (foundmax==1) increasing=1;
      foundmax = 0;
      while (nRo < numR && foundmax==0)
	{
	  nRo += rstep;
	  if (nRo < numR)
	    {
	      modelnum = nRo*nume + ne;
	      if (likel[nt][modelnum] == NOT_MEASURED)
		{
		  likel[nt][modelnum] =
		    likelihood(nt, nimcheck, nRo, ne, modelft[modelnum][0], modelft[modelnum][1]);
		  if (currentobject[nt]==printlikel)
		    {
		      printf(" likel: %d %d %d %d %g \n",nimcheck, nRo, ne, modelnum, likel[nt][modelnum]);
		    }
		  /*printf(" likel: %d %d %d %d %g %g %g %g \n", nt, iobj,
		    ne,nRo,Ro[nRo],likel[nt][modelnum],modelflux[nt][modelnum][0],modelflux[nt][modelnum][1]);*/
		}
	      if (likel[nt][modelnum] > NOT_MEASURED)
		{
		  posterior = likel[nt][modelnum] + rprior[nt][nRo] + pfactor*eprior[nt][ne];
		  // test and remember if the posterior is increasing at this step
		  if (posterior>maxposterior) 
		    {
		      minuspos = maxpos;
		      maxpos = nRo;
		      maxposterior = posterior;
		      increasing = 1;
		    }
		  // test if the posterior is decreasing (=maximum found)
		  if (posterior<maxposterior) 
		    {
		      foundmax = 1;
		      pluspos = nRo;
		    }
		}
	      // break out this loop if a bad likelihood value is encountered - indicates
	      // large model fits are dominated by cinfusing background objects
	      // and the fitting should not proceed to larger sizes
	      if (likel[nt][modelnum] == UNSATISFACTORY_VALUE) break;
	    }
	}
    }

  xvals[0] = xvals[1] = xvals[2] = -1;
  minval = 2.e10;
  maxval = NOT_MEASURED;
  if (minuspos>0 && minuspos<numR )
    {
      nRo = minuspos;
      modelnum = nRo*nume + ne;
      xvals[0] = Ro[nRo];
      yvals[0] = likel[nt][modelnum] + rprior[nt][nRo] + pfactor*eprior[nt][ne]; 
      if (yvals[0] < minval) {minval = yvals[0]; xminval = xvals[0];}
      if (yvals[0] > maxval) {maxval = yvals[0]; xmaxval = xvals[0];}
    }
  if (maxpos>0 && maxpos<numR)
    {
      nRo = maxpos;
      modelnum = nRo*nume + ne;
      xvals[1] = Ro[nRo];
      yvals[1] = likel[nt][modelnum] + rprior[nt][nRo] + pfactor*eprior[nt][ne]; 
      if (yvals[1] < minval) {minval = yvals[1]; xminval = xvals[1];}
      if (yvals[1] > maxval) {maxval = yvals[1]; xmaxval = xvals[1];}
    }
  if (pluspos>0 && pluspos<numR)
    {
      nRo = pluspos;
      modelnum = nRo*nume + ne;
      xvals[2] = Ro[nRo];
      yvals[2] = likel[nt][modelnum] + rprior[nt][nRo] + pfactor*eprior[nt][ne];      
      if (yvals[2] < minval) {minval = yvals[2]; xminval = xvals[2];}
      if (yvals[2] > maxval) {maxval = yvals[2]; xmaxval = xvals[2];}
    }

  // if a maximum is found, select the three points that bracket the maximum
  // and fit a quadratic  
  if (foundmax==1 && 
      maxpos>0 && maxpos<numR && 
      minuspos>0 && minuspos<numR && 
      pluspos>0 && pluspos<numR )
    {
      // quadratic fit to these three points, function quadfit provides
      // the returned values for findmaxr
      rfit_ok = quadfit (nt, 3, xvals, yvals, fvals);
      if (currentobject[nt]==printlikel)
	{
	  printf(" quadfit x %f %f %f y %f %f %f f %f %f %f \n",xvals[0],xvals[1],xvals[2],yvals[0],yvals[1],yvals[2],
		 fvals[0],fvals[1],fvals[2]);
	}
    }

  // set an extra value of fvals which is the value of the discrete maximum
  fvals[4] = maxposterior;
      
  // if the fit was not successful, find the measured maximum and return that value
  // with an error flag
  if (rfit_ok > 0)
    {
      if (maxpos>0 && maxpos<numR)
	{
	  nRo = maxpos;
	  modelnum = nRo*nume + ne;
	  fvals[0] = Ro[nRo];
	  fvals[1] = likel[nt][modelnum] + rprior[nt][nRo] + pfactor*eprior[nt][ne]; 
	  // if some range of values has been found make a crude estimate of a better sampling
	  if (maxval>minval)
	    {
	      if (maxval-minval > 2.)
		fvals[2] = (xmaxval-xminval)/(maxval-minval);
	      else
		fvals[2] = (xmaxval-xminval)/2.35;
	    }
	  else
	    {
	      // otherwise arrange fvals[2] so as to leave the step interval unchanged
	      if (nRo < numR-rstep)
		fvals[2] = Ro[nRo+rstep]-Ro[nRo]-0.01;
	      else
		fvals[2] = Ro[nRo]-Ro[nRo-rstep]-0.01;
	    }
	  //printf(" fit not successful, returning %g %g \n",fvals[0],fvals[1]);
	  rfit_ok = 1;
	}
      else
	{
	  fvals[0] = fvals[1] = UNSATISFACTORY_VALUE;
	  // otherwise arrange fvals[2] so as to leave the step interval unchanged
	  if (nRo < numR-rstep)
	    fvals[2] = Ro[nRo+rstep]-Ro[nRo]-0.01;
	  else
	    fvals[2] = Ro[nRo]-Ro[nRo-rstep]-0.01;
	  //printf(" no valid points found\n");
	  rfit_ok = 2;
	}
    }

  // return success flag
  return rfit_ok;

}

void propagate_scalelengths(int nt)
{
  // propagate the best-fit scalelength values across the whole array
  // The aim is to file in holes in the measured distribution with estimates
  // from neighbouring points, to speed up the measurement

  int propagate, i, j, ii, jj, ne, nne;

  // first null out any pseudo values
  for (ne=0; ne<nume; ne++)
    {
      if (fittedrstep[nt][ne] < 0) fittednRo[nt][ne] = -1;
    }

  // now iterate through the array, trying to propagate filled values of nRo
  propagate = 1;
  while (propagate==1)
    {
      propagate = 0;
      
      for (ii=-edim; ii<=edim; ii++)
	{
	  for (jj=-edim; jj<=edim; jj++)
	    {
	      ne = elookup[edim+ii][edim+jj];
	      if (ne >= 0)
		{
		  // if this ellipticity point does not have a best-fit
		  // scalelength, look for neighbours that do, and copy
		  // don't worry about multiple matches, just take one of them
		  if (fittednRo[nt][ne] < 0)
		    {
		      for (i=ii-1; i<=ii+1; i++)
			{
			  if (i>=-edim && i<=edim)
			    {
			      for (j=jj-1; j<=jj+1; j++)
				{
				  if (j>=-edim && j<=edim)
				    {
				      nne = elookup[edim+i][edim+j];
				      if (nne >= 0)
					{
					  if (fittednRo[nt][nne] > 0)
					    {
					      fittednRo[nt][ne] = fittednRo[nt][nne];
					      propagate = 1;
					    }
					}
				    }
				}
			    }
			}
		    }
		}
	    }
	}
    }

}


void propagate_rstep_values(int nt)
{
  // propagate the best-fit rstep values across the whole array
  // also replace bestnRo values as these now should be better estimates
  // The aim is to file in holes in the measured distribution with estimates
  // from neighbouring points, to speed up the measurement

  int propagate, i, j, ii, jj, ne, nne;

  propagate = 1;
  while (propagate==1)
    {
      propagate = 0;
      
      for (ii=-edim; ii<=edim; ii++)
	{
	  for (jj=-edim; jj<=edim; jj++)
	    {
	      ne = elookup[edim+ii][edim+jj];
	      if (ne >= 0)
		{
		  // if this ellipticity point does not have a best-fit
		  // scalelength, look for neighbours that do, and copy
		  // don't worry about multiple matches, just take one of them
		  if (fittedrstep[nt][ne] < 0)
		    {
		      for (i=ii-1; i<=ii+1; i++)
			{
			  if (i>=-edim && i<=edim)
			    {
			      for (j=jj-1; j<=jj+1; j++)
				{
				  if (j>=-edim && j<=edim)
				    {
				      nne = elookup[edim+i][edim+j];
				      if (nne >= 0)
					{
					  if (fittedrstep[nt][nne] > 0)
					    {
					      fittedrstep[nt][ne] = fittedrstep[nt][nne];
					      propagate = 1;
					      if (fittednRo[nt][nne] > 0)
						fittednRo[nt][ne] = fittednRo[nt][nne];
					    }
					}
				    }
				}
			    }
			}
		    }
		}
	    }
	}
    }

}


int marginaliser(int nt, int iobj, int nimcheck, int bestnRo, int rstep, int ne, double zerolikel)
{
  // function to sample the distribution of posterior as a function of scalelength
  // fit a spline to those values and marginalise, all at fixed ellipticity

  int nRo, modelnum, nRmax, nRmin, ii, jj, exception, ymaxpos; 
  double priorval, posterior, sump, result, error;
  double likelval, Rarcsec, xmval, ymval, ymax, yval;
  double xmin, xmax, logPcut;
  gsl_function marF, marR;
  marF.function = &marf;
  marF.params = &nt;
  marR.function = &marr;
  marR.params = &nt;
  int gsl_status;

  // first stage: measure some sampled posterior values above a threshold

  logPcut = log(Pcut);
  nRo = bestnRo;
  modelnum = nRo*nume + ne;
  priorval = rprior[nt][nRo]; // + eprior[nt][ne];
  rmarvals[nt][ne] = 0.;
  sump = 0.;
  exception = 0;
  if (likel[nt][modelnum] > NOT_MEASURED)
    {
      posterior = likel[nt][modelnum] + priorval;
      if (posterior > maxrposterior[nt]) maxrposterior[nt] = posterior;
    }
  else if (likel[nt][modelnum] == NOT_MEASURED)
    {
      likel[nt][modelnum] = likelihood(nt,nimcheck,nRo,ne,modelft[modelnum][0],modelft[modelnum][1]);
      likelval = likel[nt][modelnum];
      posterior = likelval + priorval;
      if (posterior > maxrposterior[nt]) maxrposterior[nt] = posterior;
    }

  // now step above and below the maximum and accumulate posterior values
  // which must be at least +/- 2 steps from starting position
  // if likelihood values do not currently exist, calculate them
  // stop when posterior has dropped below threshold defined by log(Pcut)
  nRmax = bestnRo + rstep;
  while ( nRmax<numR && ( (nRmax-bestnRo)<2 || posterior>maxrposterior[nt]+logPcut ) )
    {
      nRo = nRmax;
      modelnum = nRo*nume + ne;
      priorval = rprior[nt][nRo]; //+eprior[nt][ne];
      if (likel[nt][modelnum] > NOT_MEASURED)
	{
	  posterior = likel[nt][modelnum] + priorval;
	  if (posterior>maxrposterior[nt]) maxrposterior[nt] = posterior;
	}
      else if (likel[nt][modelnum] == NOT_MEASURED)
	{
	  likel[nt][modelnum] = likelihood(nt,nimcheck,nRo,ne,modelft[modelnum][0],modelft[modelnum][1]);
	  likelval = likel[nt][modelnum];
	  posterior = likelval + priorval;
	  if (posterior>maxrposterior[nt]) maxrposterior[nt] = posterior;
	}
      // break out of the loop if unsatisfactory likelihoods are encountered
      // indicates large object fits are dominated by confusing background objects
      if (likel[nt][modelnum] == UNSATISFACTORY_VALUE) break;
      nRmax += rstep;
    }
  if (nRmax>=numR) nRmax = numR-1;
  // similarly for stepping to smaller scalelength
  nRmin = bestnRo-1;
  posterior = maxrposterior[nt];
  while (nRmin>0 && ( (bestnRo-nRmin)<2 || posterior>maxrposterior[nt]+logPcut ) )
    {
      nRo = nRmin;
      modelnum = nRo*nume + ne;
      priorval = rprior[nt][nRo]; // + eprior[nt][ne];
      if (likel[nt][modelnum] > NOT_MEASURED)
	{
	  posterior = likel[nt][modelnum] + priorval;
	  if (posterior>maxrposterior[nt]) maxrposterior[nt] = posterior;
	}
      else if (likel[nt][modelnum] == NOT_MEASURED)
	{
	  likel[nt][modelnum] = likelihood(nt,nimcheck,nRo,ne,modelft[modelnum][0],modelft[modelnum][1]);
	  likelval = likel[nt][modelnum];
	  posterior = likelval + priorval;
	  if (posterior>maxrposterior[nt]) maxrposterior[nt] = posterior;
	}
      nRmin -= rstep;
    }
  if (nRmin<1) nRmin=1;

  // marginalise over scalelength (need maximum posterior first to keep values in
  // range such that they can be summed).  Check that some maximum has been found:
  if (maxrposterior[nt] > NOT_MEASURED) {

    // adjust the maxposterior so that we only consider the r prior component
    // i.e. what is returned to the main program will be marginalised over 
    // scalelength but the ellipticity prior will not be applied
    // maxposterior -= eprior[nt][ne];

    // find first valid measurement
    nRo = 1;
    modelnum = nRo * nume + ne;
    priorval = rprior[nt][nRo];
    likelval = likel[nt][modelnum];
    posterior = exp(likelval + priorval - maxrposterior[nt]);
    while (nRo < numR && ( likel[nt][modelnum] <= NOT_MEASURED || posterior<=0. ) ) 
      {
	nRo++;
	modelnum = nRo * nume + ne;
	priorval = rprior[nt][nRo];
	likelval = likel[nt][modelnum];
	posterior = exp(likelval + priorval - maxrposterior[nt]);
      }
    /*
     * if found OK, make linearly interpolated array at intervals R/5 from  R/10 to
     * the first measured value R using zerolikel as the r=0 value.  As the prior
     * has not been defined on this finer grid, and as the log(posterior) value
     * at r=0 is -infinity, interpolate the likelihood and then apply the prior. 
     */
    num_marvals[nt] = 0;
    if (nRo < numR) {
      /*
       * now create the extra values at small r 
       */
      // (the current Ro[nRo] is the smallest measured scalelength)
      Rarcsec = Ro[nRo]*defaultmeanscalefactor;
      // only consider r component of prior
      priorval = rprior[nt][nRo] - rfunc(Rarcsec, catmag[iobj]);  // adjust for varying Ro
      xmval = Ro[nRo] / 10.;      // set start point
      while (xmval < Ro[nRo]) {
	// linear interpolate log(likelihood) between r=0 value and Ro[nRo] value
	ymval =  zerolikel + (xmval/Ro[nRo]) * (likel[nt][modelnum]-zerolikel);
	xmarvals[nt][num_marvals[nt]] = xmval;
	Rarcsec = xmval*defaultmeanscalefactor;
	ymarvals[nt][num_marvals[nt]] = ymval + priorval + rfunc(Rarcsec, catmag[iobj]) - maxrposterior[nt];
	num_marvals[nt]++;
	xmval += Ro[nRo] / 5.;
      }
      /*
       * go through the measured points, in order of increasing R, adding into the
       * interpolation array, but stop if a bad likelihood value is found as this
       * marks the point at which background objects are starting to dominate
       */
      for(nRo = 1; nRo < numR; nRo++) 
	{
	  modelnum = nRo * nume + ne;
	  priorval = rprior[nt][nRo];
	  likelval = likel[nt][modelnum];
	  // if likelihood previously measured successfully...
	  if (likelval > NOT_MEASURED) 
	    {
	      posterior = exp(likelval + priorval - maxrposterior[nt]);
	      if (posterior>0.)
		{
		  // store in local array the log(posterior) values to be marginalised over
		  xmarvals[nt][num_marvals[nt]] = Ro[nRo];
		  ymarvals[nt][num_marvals[nt]] = log(posterior);
		  num_marvals[nt]++;
		  //printf("   %f %f %f %f \n",Ro[nRo],log(posterior),ee1,ee2);
		}
	    }
	  if (likelval == UNSATISFACTORY_VALUE) break;
	}
      /*
       * marginalisation is done over r by numerical integration of the posterior, where
       * the posterior value at any arbitrary r value is obtained by cubic-spline
       * interpolation of the log(posterior) values 
       */
      // check ordering 
      for(ii = 1; ii < num_marvals[nt]; ii++) {
	if (xmarvals[nt][ii] <= xmarvals[nt][ii-1]) {
	  fflush(stdout);
	  fprintf(stderr," interp array out of order at object %d ne %d \n", iobj+1, ne);
	  for(jj = 0; jj < num_marvals[nt]; jj++)
	    fprintf (stderr," %f %f \n", xmarvals[nt][jj],ymarvals[nt][jj]);
	  exit(EXIT_FAILURE);
	}
      }
      // recheck the maximum value is OK after the extra values have been added
      ymax = 0.;
      for(ii = 0; ii < num_marvals[nt]; ii++)
	if (ymarvals[nt][ii] > ymax) ymax = ymarvals[nt][ii];
      if (ymax > 0.) 
	{
	  for(ii = 0; ii < num_marvals[nt]; ii++) ymarvals[nt][ii] -= ymax;
	  maxrposterior[nt] += ymax;
	}
      // find the position of the maximum
      ymax = -10.;
      ymaxpos = 0;
      for(ii = 0; ii < num_marvals[nt]; ii++)
	{
	  if (ymarvals[nt][ii] > ymax) 
	    {
	      ymax = ymarvals[nt][ii];
	      ymaxpos = ii;
	    }
	}
      // set integration limits
      xmin = xmax = xmarvals[nt][ymaxpos];
      if (ymaxpos < num_marvals[nt]-1) xmax = xmarvals[nt][ymaxpos+1];
      if (ymaxpos > 0) xmin = xmarvals[nt][ymaxpos-1];
      for (ii=0; ii < num_marvals[nt]; ii++)
	{
	  if (ymarvals[nt][ii] > -70. && ymarvals[nt][ii] > EXPMIN)
	    {
	      if (xmarvals[nt][ii] < xmin) xmin = xmarvals[nt][ii];
	      if (xmarvals[nt][ii] > xmax) xmax = xmarvals[nt][ii];
	    }
	}
      // check number of interpolation points and integration limits
      if (num_marvals[nt] < 5 || xmax <= xmin) {
	fflush(stdout);
	fprintf(stderr," error in function, object %d %d \n",iobj+1, ne);
	fprintf(stderr," num = %d xmin,max = %f %f \n",num_marvals[nt], xmin, xmax);
	exit(EXIT_FAILURE);
      }
      if (currentobject[nt]==printlikel)
	{
	  printf(" marginaliser values %d %f %f %f %f %d \n",ne,
	       xmin,xmax,xmarvals[nt][0],xmarvals[nt][num_marvals[nt]-1],num_marvals[nt]);
	  for (ii=0; ii<num_marvals[nt]; ii++)
	    printf("   %f %f \n",xmarvals[nt][ii],ymarvals[nt][ii]);
	  fflush(stdout);
	}    
      /*
       * allocate the interpolation objects (in the gsl routine this object
       * must be equal in dimension to the data array so we cannot simply keep
       * reusing a single object, sadly) 
       */
      // cspline for log(posterior) values
      fspline[nt] = gsl_spline_alloc(gsl_interp_cspline,num_marvals[nt]);
      if (fspline[nt] == NULL) {
	fflush(stdout);
	fprintf(stderr," error from gsl_interp_accel_alloc, fspline \n");
	exit(EXIT_FAILURE);
      }
      // reset the accelerator
      gsl_status = gsl_interp_accel_reset(facc[nt]);
      if (gsl_status) {
	fflush(stdout);
	fprintf(stderr," error gsl_interp_accel_reset facc[%d] \n",nt);
	fprintf(stderr," %s \n",gsl_strerror(gsl_status));
	exit(EXIT_FAILURE);
      }
      // load R and log(posterior) values into interpolation arrays
      gsl_status = gsl_spline_init(fspline[nt],xmarvals[nt],ymarvals[nt],num_marvals[nt]);
      if (gsl_status) {
	fflush(stdout);
	fprintf(stderr," error gsl_spline_init fspline[%d] \n",nt);
	fprintf(stderr," %s \n",gsl_strerror(gsl_status));
	exit(EXIT_FAILURE);
      }
      // create an array of values at the sampled points, to be used for output of the 
      // posterior distribution of scalelength
      for (nRo=1; nRo<numR; nRo++)
	{
	  yval = NOT_MEASURED;
	  if (Ro[nRo] > xmin && Ro[nRo] < xmax)
	    {
	      gsl_status = gsl_spline_eval_e(fspline[nt], Ro[nRo], facc[nt], &yval);
	      if (gsl_status) { 
		yval = UNSATISFACTORY_VALUE;} else {
		// put the offset back in, also in this array include the ellipticity prior
		yval += (maxrposterior[nt] + eprior[nt][ne]);}
	    }
	  modelnum = nRo*nume + ne;
	  interp_rval[nt][modelnum] = yval;
	}
      // integrate the exponential of the interpolated log(posterior) array
      gsl_status = gsl_integration_qag
	(&marF, xmin, xmax,0., 1.e-3, gsl_work_size,
	 GSL_INTEG_GAUSS41,gsl_work[nt], &sump, &error);
      if (gsl_status) {
	// occasionally cannot integrate 
	// try again with linear interpolation
	gsl_spline_free(fspline[nt]);
	fspline[nt] = gsl_spline_alloc(gsl_interp_linear,num_marvals[nt]);
	if (fspline[nt] == NULL) {
	  fflush(stdout);
	  fprintf(stderr," error from linear gsl_interp_accel_alloc, fspline \n");
	  exit(EXIT_FAILURE);
	}
	// reset the accelerator
	gsl_status = gsl_interp_accel_reset(facc[nt]);
	if (gsl_status) {
	  fflush(stdout);
	  fprintf(stderr," error linear gsl_interp_accel_reset facc[%d] \n",nt);
	  fprintf(stderr," %s \n",gsl_strerror(gsl_status));
	  exit(EXIT_FAILURE);
	}
	// load R and log(posterior) values into interpolation arrays
	gsl_status = gsl_spline_init(fspline[nt],xmarvals[nt],ymarvals[nt],num_marvals[nt]);
	if (gsl_status) {
	  fflush(stdout);
	  fprintf(stderr," error linear gsl_spline_init fspline[%d] \n",nt);
	  fprintf(stderr," %s \n",gsl_strerror(gsl_status));
	  exit(EXIT_FAILURE);
	}
	// integrate the exponential of the interpolated log(posterior) array
	gsl_status = gsl_integration_qag
	  (&marF, xmin, xmax,0., 1.e-3, gsl_work_size,
	   GSL_INTEG_GAUSS41,gsl_work[nt], &sump, &error);
	if (gsl_status) {
	  // return a null value, no marginalised values will be computed at this point
	  sump = 0.;
	  exception++;
	  /*
	   * occasional extreme posterior distributions, with essentially
	   * only a single valid point and all other points many thousands
	   * lower in log(p), cause trouble for the integrator.  By
	   * default null values are returned in these cases, but if you
	   * want to look at the problem cases you can uncomment this section 
           
	   printf(" warning, integration error gsl_integration_qag marF ");
	   printf(" %s \n",gsl_strerror(gsl_status));
	   printf("object %d ne %d xmin, max %f %f %d \n",i,ne,xmin,xmax,num_marvals[nt]);
	   for (ii=0; ii<num_marvals[nt]; ii++)
	   printf("   %f %f \n",xmarvals[nt][ii],ymarvals[nt][ii]);
	   sump = 0.;
	   printf(" continuing \n");
	   fflush(stdout);
	  */
	}
      }
      if (sump > 0.) {
	// no_exception++;
	// marginalise over r
	gsl_status = gsl_integration_qag
	  (&marR, xmin, xmax, 0., 1.e-3, gsl_work_size,
	   GSL_INTEG_GAUSS41, gsl_work[nt], &result,&error);
	if (gsl_status) {
	  // if marginalisation over r has failed
	  if (VERBOSE == 1)
	    {
	      fflush(stdout);
	      printf(" warning gsl_integration_qag marR \n");
	      printf(" thread %d object %d \n",nt,iobj+1);
	      printf(" %s \n",gsl_strerror(gsl_status));
	      fflush(stdout);
	    }
	  // set marginalised r to maximum posterior value
	  ymax = NOT_MEASURED;
	  rmarvals[nt][ne] = 0.;
	  for(ii = 0; ii < num_marvals[nt]; ii++) {
	    if (ymarvals[nt][ii] > ymax) {
	      ymax = ymarvals[nt][ii];
	      rmarvals[nt][ne] = xmarvals[nt][ii];
	    }
	  }
	  if (VERBOSE == 1)
	    {
	      printf(" object %d r(mar) set to %f \n",currentobject[nt]+1,rmarvals[nt][ne]);
	      fflush(stdout);
	    }
	} else {
	  rmarvals[nt][ne] = result / sump;
	}
	
	// rescale marginalised probability
	marP[nt][ne] = log(sump) + maxrposterior[nt];
      }
      else 
	{
	  marP[nt][ne] = UNSATISFACTORY_VALUE;
	}
      // free the interpolation object
      gsl_spline_free(fspline[nt]);
    }
    
  }

  return exception;
  
}


int quadfit(int nt, int np, double *xvals, double *yvals, double *fvals)
{
  // least-squares quadratic fit to a set of chisq values, returns marginalised chi-squared
  // and location of maximum, sigma
  int i,j,k,ns,retval;
  double sumx[5],sumxy[3],wmax,a[3],lambda[3],xoffset,yoffset,evali;

  // set return value
  retval = 0;

  a[0] = a[1] = a[2] = 0.;

  if (np < 3)
    {
      fflush(stdout);
      fprintf(stderr," too few values passed to quadfit, np = %d\n",np);
      exit(2);
    }

  xoffset = xvals[1];
  yoffset = yvals[1];

  for (j=0; j<np; j++)
    {
      xvals[j] -= xoffset;
      yvals[j] -= yoffset;
    }

  for (j=0; j<5; j++) sumx[j]=0.;
  for (i=0; i<np; i++)
    {
      sumx[0]++;
      for (j=1; j<5; j++)
	{
	  sumx[j] += pow(xvals[i],j);
	}
    }
  for (j=0; j<3; j++) sumxy[j] = 0.;
  for (i=0; i<np; i++)
    {
      sumxy[0] += yvals[i];
      sumxy[1] += yvals[i]*xvals[i];
      sumxy[2] += yvals[i]*pow(xvals[i],2);
    }
  // number of coefficients (quadratic polynomial)
  ns = 3;
  for (i=0; i<ns; i++)
    {
      k=i;
      for (j=0; j<ns; j++)
	{
	  //  printf(" setting %d %g to element %d %d \n",k,sumx[k],i,j);
	  gsl_matrix_set(umatrix[nt],i,j,sumx[k]);
	  k++;
	}
    }
  for (i=0; i<ns; i++)
    {
      //      printf(" setting vector %g %d \n",sumxy[i],i);
      gsl_vector_set(bvec[nt],i,sumxy[i]);
    }
  // find eigenvalues
  gsl_eigen_symmv(umatrix[nt], eval[nt], evec[nt], gsl_eigen_work[nt]);
  // create inverse eigenvalues
  wmax = 0.;
  for (i=0; i<ns; i++)
    {
      evali = gsl_vector_get(eval[nt],i);
      if (evali > wmax) wmax = evali;
    }
  for (i=0; i<ns; i++)
    {
      evali = gsl_vector_get(eval[nt],i);
      if (evali > wmax*1.e-6) 
	{
	  lambda[i] = 1./evali;
	}
      else
	{
	  lambda[i] = 0.;
	  retval = 1;
	}
      //printf(" lambda %g \n",lambda[i]); fflush(stdout);
    }

  // check if matrix is near-singular, return error code if it is
  // otherwise find best quadratic fit
  if (retval==0)
    {
      // calculate solution vector
      gsl_blas_dgemv(CblasTrans, 1., evec[nt], bvec[nt], 0., yvec[nt]);
      for (i=0; i<ns; i++)
	{
	  evali = gsl_vector_get(yvec[nt],i);
	  gsl_vector_set(yvec[nt],i,(evali*lambda[i]));
	}
      gsl_blas_dgemv(CblasNoTrans, 1., evec[nt], yvec[nt], 0., eval[nt]);
      
      for (i=0; i<ns; i++)
	a[i] = gsl_vector_get(eval[nt],i);
    }

  // recreate input data: in the case of retval=1, these will be used in
  // the main program      
  for (j=0; j<np; j++)
    {
      xvals[j] += xoffset;
      yvals[j] += yoffset;
    }

  // check that a maximum log(likelihood) has been found
  if (a[2] >= 0. || retval==1)
    {
      retval = 1;
      //fflush(stdout);
      //fprintf(stderr," error in 2nd derivative coeffs in quadfit\n");
      /*
      for (j=0; j<np; j++)
	{
	  printf(" values %g %g \n",xvals[j],yvals[j]);
	}
      */
      return retval;
    }

  //printf(" quadfit %g %g %g \n",a[0],a[1],a[2]);
  
  // location of maximum
  fvals[0] = xoffset - a[1]/2./a[2];
  // value of maximum
  fvals[1] = yoffset + a[0] -a[1]*a[1]/4./a[2];
  // sigma of gaussian  distribution
  fvals[2] = sqrt(-1./2./a[2]);
  // ln(marginalised likelihood)
  fvals[3] = (fvals[1] + log(fvals[2]));
  
  return retval;
      
}


